"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ox";
exports.ids = ["vendor-chunks/ox"];
exports.modules = {

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiConstructor.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiConstructor.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbiItem.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decode(...parameters) {\n    const [abiConstructor, options] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [\n                fromAbi(abi),\n                options\n            ];\n        }\n        return parameters;\n    })();\n    const { bytecode } = options;\n    if (abiConstructor.inputs?.length === 0) return undefined;\n    const data = options.data.replace(bytecode, \"0x\");\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.decode(abiConstructor.inputs, data);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction encode(...parameters) {\n    const [abiConstructor, options] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [\n                fromAbi(abi),\n                options\n            ];\n        }\n        return parameters;\n    })();\n    const { bytecode, args } = options;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(bytecode, abiConstructor.inputs?.length && args?.length ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.encode(abiConstructor.inputs, args) : \"0x\");\n}\n/** @internal */ function format(abiConstructor) {\n    return abitype__WEBPACK_IMPORTED_MODULE_2__.formatAbiItem(abiConstructor);\n}\n/** @internal */ function from(abiConstructor) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.from(abiConstructor);\n}\n/** @internal */ function fromAbi(abi) {\n    const item = abi.find((item)=>item.type === \"constructor\");\n    if (!item) throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.NotFoundError({\n        name: \"constructor\"\n    });\n    return item;\n} //# sourceMappingURL=AbiConstructor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUNvbnN0cnVjdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFtQztBQUNLO0FBQ1k7QUFDcEI7QUFDaEMsK0NBQStDO0FBQ3hDLFNBQVNJLE9BQU8sR0FBR0MsVUFBVTtJQUNoQyxNQUFNLENBQUNDLGdCQUFnQkMsUUFBUSxHQUFHLENBQUM7UUFDL0IsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSixVQUFVLENBQUMsRUFBRSxHQUFHO1lBQzlCLE1BQU0sQ0FBQ0ssS0FBS0gsUUFBUSxHQUFHRjtZQUN2QixPQUFPO2dCQUFDTSxRQUFRRDtnQkFBTUg7YUFBUTtRQUNsQztRQUNBLE9BQU9GO0lBQ1g7SUFDQSxNQUFNLEVBQUVPLFFBQVEsRUFBRSxHQUFHTDtJQUNyQixJQUFJRCxlQUFlTyxNQUFNLEVBQUVDLFdBQVcsR0FDbEMsT0FBT0M7SUFDWCxNQUFNQyxPQUFPVCxRQUFRUyxJQUFJLENBQUNDLE9BQU8sQ0FBQ0wsVUFBVTtJQUM1QyxPQUFPVixxREFBb0IsQ0FBQ0ksZUFBZU8sTUFBTSxFQUFFRztBQUN2RDtBQUNBLCtDQUErQztBQUN4QyxTQUFTRSxPQUFPLEdBQUdiLFVBQVU7SUFDaEMsTUFBTSxDQUFDQyxnQkFBZ0JDLFFBQVEsR0FBRyxDQUFDO1FBQy9CLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0osVUFBVSxDQUFDLEVBQUUsR0FBRztZQUM5QixNQUFNLENBQUNLLEtBQUtILFFBQVEsR0FBR0Y7WUFDdkIsT0FBTztnQkFBQ00sUUFBUUQ7Z0JBQU1IO2FBQVE7UUFDbEM7UUFDQSxPQUFPRjtJQUNYO0lBQ0EsTUFBTSxFQUFFTyxRQUFRLEVBQUVPLElBQUksRUFBRSxHQUFHWjtJQUMzQixPQUFPSiwyQ0FBVSxDQUFDUyxVQUFVTixlQUFlTyxNQUFNLEVBQUVDLFVBQVVLLE1BQU1MLFNBQzdEWixxREFBb0IsQ0FBQ0ksZUFBZU8sTUFBTSxFQUFFTSxRQUM1QztBQUNWO0FBQ0EsY0FBYyxHQUNQLFNBQVNFLE9BQU9mLGNBQWM7SUFDakMsT0FBT04sa0RBQXFCLENBQUNNO0FBQ2pDO0FBQ0EsY0FBYyxHQUNQLFNBQVNpQixLQUFLakIsY0FBYztJQUMvQixPQUFPTCw2Q0FBWSxDQUFDSztBQUN4QjtBQUNBLGNBQWMsR0FDUCxTQUFTSyxRQUFRRCxHQUFHO0lBQ3ZCLE1BQU1jLE9BQU9kLElBQUllLElBQUksQ0FBQyxDQUFDRCxPQUFTQSxLQUFLRSxJQUFJLEtBQUs7SUFDOUMsSUFBSSxDQUFDRixNQUNELE1BQU0sSUFBSXZCLHNEQUFxQixDQUFDO1FBQUUyQixNQUFNO0lBQWM7SUFDMUQsT0FBT0o7QUFDWCxFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYzQzMzctZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUNvbnN0cnVjdG9yLmpzPzZjZTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYWJpdHlwZSBmcm9tICdhYml0eXBlJztcbmltcG9ydCAqIGFzIEFiaUl0ZW0gZnJvbSAnLi9BYmlJdGVtLmpzJztcbmltcG9ydCAqIGFzIEFiaVBhcmFtZXRlcnMgZnJvbSAnLi9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZSguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgW2FiaUNvbnN0cnVjdG9yLCBvcHRpb25zXSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBvcHRpb25zXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gW2Zyb21BYmkoYWJpKSwgb3B0aW9uc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfSkoKTtcbiAgICBjb25zdCB7IGJ5dGVjb2RlIH0gPSBvcHRpb25zO1xuICAgIGlmIChhYmlDb25zdHJ1Y3Rvci5pbnB1dHM/Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBkYXRhID0gb3B0aW9ucy5kYXRhLnJlcGxhY2UoYnl0ZWNvZGUsICcweCcpO1xuICAgIHJldHVybiBBYmlQYXJhbWV0ZXJzLmRlY29kZShhYmlDb25zdHJ1Y3Rvci5pbnB1dHMsIGRhdGEpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlDb25zdHJ1Y3Rvciwgb3B0aW9uc10gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgb3B0aW9uc10gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIFtmcm9tQWJpKGFiaSksIG9wdGlvbnNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICAgIH0pKCk7XG4gICAgY29uc3QgeyBieXRlY29kZSwgYXJncyB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGV4LmNvbmNhdChieXRlY29kZSwgYWJpQ29uc3RydWN0b3IuaW5wdXRzPy5sZW5ndGggJiYgYXJncz8ubGVuZ3RoXG4gICAgICAgID8gQWJpUGFyYW1ldGVycy5lbmNvZGUoYWJpQ29uc3RydWN0b3IuaW5wdXRzLCBhcmdzKVxuICAgICAgICA6ICcweCcpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChhYmlDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpQ29uc3RydWN0b3IpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oYWJpQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gQWJpSXRlbS5mcm9tKGFiaUNvbnN0cnVjdG9yKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWJpKGFiaSkge1xuICAgIGNvbnN0IGl0ZW0gPSBhYmkuZmluZCgoaXRlbSkgPT4gaXRlbS50eXBlID09PSAnY29uc3RydWN0b3InKTtcbiAgICBpZiAoIWl0ZW0pXG4gICAgICAgIHRocm93IG5ldyBBYmlJdGVtLk5vdEZvdW5kRXJyb3IoeyBuYW1lOiAnY29uc3RydWN0b3InIH0pO1xuICAgIHJldHVybiBpdGVtO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJpQ29uc3RydWN0b3IuanMubWFwIl0sIm5hbWVzIjpbImFiaXR5cGUiLCJBYmlJdGVtIiwiQWJpUGFyYW1ldGVycyIsIkhleCIsImRlY29kZSIsInBhcmFtZXRlcnMiLCJhYmlDb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJhYmkiLCJmcm9tQWJpIiwiYnl0ZWNvZGUiLCJpbnB1dHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJkYXRhIiwicmVwbGFjZSIsImVuY29kZSIsImFyZ3MiLCJjb25jYXQiLCJmb3JtYXQiLCJmb3JtYXRBYmlJdGVtIiwiZnJvbSIsIml0ZW0iLCJmaW5kIiwidHlwZSIsIk5vdEZvdW5kRXJyb3IiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiConstructor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiFunction.js":
/*!**************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiFunction.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeData: () => (/* binding */ decodeData),\n/* harmony export */   decodeResult: () => (/* binding */ decodeResult),\n/* harmony export */   encodeData: () => (/* binding */ encodeData),\n/* harmony export */   encodeResult: () => (/* binding */ encodeResult),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbiItem.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decodeData(...parameters) {\n    const [abiFunction, data] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data] = parameters;\n            return [\n                fromAbi(abi, name),\n                data\n            ];\n        }\n        return parameters;\n    })();\n    const { overloads } = abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(data) < 4) throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSelectorSizeError({\n        data\n    });\n    if (abiFunction.inputs?.length === 0) return undefined;\n    const item = overloads ? fromAbi([\n        abiFunction,\n        ...overloads\n    ], data) : abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(data) <= 4) return undefined;\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.decode(item.inputs, _Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(data, 4));\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decodeResult(...parameters) {\n    const [abiFunction, data, options = {}] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data, options] = parameters;\n            return [\n                fromAbi(abi, name),\n                data,\n                options\n            ];\n        }\n        return parameters;\n    })();\n    const values = _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0) return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values)) return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction encodeData(...parameters) {\n    const [abiFunction, args = []] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, args] = parameters;\n            return [\n                fromAbi(abi, name, {\n                    args\n                }),\n                args\n            ];\n        }\n        const [abiFunction, args] = parameters;\n        return [\n            abiFunction,\n            args\n        ];\n    })();\n    const { overloads } = abiFunction;\n    const item = overloads ? fromAbi([\n        abiFunction,\n        ...overloads\n    ], abiFunction.name, {\n        args\n    }) : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0 ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.encode(item.inputs, args) : undefined;\n    return data ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(selector, data) : selector;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction encodeResult(...parameters) {\n    const [abiFunction, output, options = {}] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, output, options] = parameters;\n            return [\n                fromAbi(abi, name),\n                output,\n                options\n            ];\n        }\n        return parameters;\n    })();\n    const { as = \"Array\" } = options;\n    const values = (()=>{\n        if (abiFunction.outputs.length === 1) return [\n            output\n        ];\n        if (Array.isArray(output)) return output;\n        if (as === \"Object\") return Object.values(output);\n        return [\n            output\n        ];\n    })();\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.encode(abiFunction.outputs, values);\n}\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */ function format(abiFunction) {\n    return abitype__WEBPACK_IMPORTED_MODULE_3__.formatAbiItem(abiFunction);\n}\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */ function from(abiFunction, options = {}) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.from(abiFunction, options);\n}\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */ function fromAbi(abi, name, options) {\n    const item = _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.fromAbi(abi, name, options);\n    if (item.type !== \"function\") throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.NotFoundError({\n        name,\n        type: \"function\"\n    });\n    return item;\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */ function getSelector(abiItem) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.getSelector(abiItem);\n} //# sourceMappingURL=AbiFunction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUZ1bmN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNLO0FBQ1k7QUFDcEI7QUFDaEMsK0NBQStDO0FBQ3hDLFNBQVNJLFdBQVcsR0FBR0MsVUFBVTtJQUNwQyxNQUFNLENBQUNDLGFBQWFDLEtBQUssR0FBRyxDQUFDO1FBQ3pCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0osVUFBVSxDQUFDLEVBQUUsR0FBRztZQUM5QixNQUFNLENBQUNLLEtBQUtDLE1BQU1KLEtBQUssR0FBR0Y7WUFDMUIsT0FBTztnQkFBQ08sUUFBUUYsS0FBS0M7Z0JBQU9KO2FBQUs7UUFDckM7UUFDQSxPQUFPRjtJQUNYO0lBQ0EsTUFBTSxFQUFFUSxTQUFTLEVBQUUsR0FBR1A7SUFDdEIsSUFBSUgseUNBQVEsQ0FBQ0ksUUFBUSxHQUNqQixNQUFNLElBQUlOLGlFQUFnQyxDQUFDO1FBQUVNO0lBQUs7SUFDdEQsSUFBSUQsWUFBWVUsTUFBTSxFQUFFQyxXQUFXLEdBQy9CLE9BQU9DO0lBQ1gsTUFBTUMsT0FBT04sWUFDUEQsUUFBUTtRQUFDTjtXQUFnQk87S0FBVSxFQUFFTixRQUNyQ0Q7SUFDTixJQUFJSCx5Q0FBUSxDQUFDSSxTQUFTLEdBQ2xCLE9BQU9XO0lBQ1gsT0FBT2hCLHFEQUFvQixDQUFDaUIsS0FBS0gsTUFBTSxFQUFFYiwwQ0FBUyxDQUFDSSxNQUFNO0FBQzdEO0FBQ0EsK0NBQStDO0FBQ3hDLFNBQVNlLGFBQWEsR0FBR2pCLFVBQVU7SUFDdEMsTUFBTSxDQUFDQyxhQUFhQyxNQUFNZ0IsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDdkMsSUFBSWYsTUFBTUMsT0FBTyxDQUFDSixVQUFVLENBQUMsRUFBRSxHQUFHO1lBQzlCLE1BQU0sQ0FBQ0ssS0FBS0MsTUFBTUosTUFBTWdCLFFBQVEsR0FBR2xCO1lBQ25DLE9BQU87Z0JBQUNPLFFBQVFGLEtBQUtDO2dCQUFPSjtn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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdFQyxHQUNNLFNBQVNYLFFBQVFGLEdBQUcsRUFBRUMsSUFBSSxFQUFFWSxPQUFPO0lBQ3RDLE1BQU1KLE9BQU9sQixnREFBZSxDQUFDUyxLQUFLQyxNQUFNWTtJQUN4QyxJQUFJSixLQUFLcUIsSUFBSSxLQUFLLFlBQ2QsTUFBTSxJQUFJdkMsc0RBQXFCLENBQUM7UUFBRVU7UUFBTTZCLE1BQU07SUFBVztJQUM3RCxPQUFPckI7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZCQyxHQUNNLFNBQVNZLFlBQVlXLE9BQU87SUFDL0IsT0FBT3pDLG9EQUFtQixDQUFDeUM7QUFDL0IsRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmM0MzM3LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlGdW5jdGlvbi5qcz8yMjg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFiaXR5cGUgZnJvbSAnYWJpdHlwZSc7XG5pbXBvcnQgKiBhcyBBYmlJdGVtIGZyb20gJy4vQWJpSXRlbS5qcyc7XG5pbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4vQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVEYXRhKC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBbYWJpRnVuY3Rpb24sIGRhdGFdID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFthYmksIG5hbWUsIGRhdGFdID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHJldHVybiBbZnJvbUFiaShhYmksIG5hbWUpLCBkYXRhXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgICB9KSgpO1xuICAgIGNvbnN0IHsgb3ZlcmxvYWRzIH0gPSBhYmlGdW5jdGlvbjtcbiAgICBpZiAoSGV4LnNpemUoZGF0YSkgPCA0KVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5JbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IoeyBkYXRhIH0pO1xuICAgIGlmIChhYmlGdW5jdGlvbi5pbnB1dHM/Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBpdGVtID0gb3ZlcmxvYWRzXG4gICAgICAgID8gZnJvbUFiaShbYWJpRnVuY3Rpb24sIC4uLm92ZXJsb2Fkc10sIGRhdGEpXG4gICAgICAgIDogYWJpRnVuY3Rpb247XG4gICAgaWYgKEhleC5zaXplKGRhdGEpIDw9IDQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIEFiaVBhcmFtZXRlcnMuZGVjb2RlKGl0ZW0uaW5wdXRzLCBIZXguc2xpY2UoZGF0YSwgNCkpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSZXN1bHQoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlGdW5jdGlvbiwgZGF0YSwgb3B0aW9ucyA9IHt9XSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lLCBkYXRhLCBvcHRpb25zXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gW2Zyb21BYmkoYWJpLCBuYW1lKSwgZGF0YSwgb3B0aW9uc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfSkoKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShhYmlGdW5jdGlvbi5vdXRwdXRzLCBkYXRhLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWVzICYmIE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh2YWx1ZXMgJiYgT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbMF07XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHZhbHVlcylbMF07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZURhdGEoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlGdW5jdGlvbiwgYXJncyA9IFtdXSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lLCBhcmdzXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gW2Zyb21BYmkoYWJpLCBuYW1lLCB7IGFyZ3MgfSksIGFyZ3NdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFthYmlGdW5jdGlvbiwgYXJnc10gPSBwYXJhbWV0ZXJzO1xuICAgICAgICByZXR1cm4gW2FiaUZ1bmN0aW9uLCBhcmdzXTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHsgb3ZlcmxvYWRzIH0gPSBhYmlGdW5jdGlvbjtcbiAgICBjb25zdCBpdGVtID0gb3ZlcmxvYWRzXG4gICAgICAgID8gZnJvbUFiaShbYWJpRnVuY3Rpb24sIC4uLm92ZXJsb2Fkc10sIGFiaUZ1bmN0aW9uLm5hbWUsIHtcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgIH0pXG4gICAgICAgIDogYWJpRnVuY3Rpb247XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihpdGVtKTtcbiAgICBjb25zdCBkYXRhID0gYXJncy5sZW5ndGggPiAwID8gQWJpUGFyYW1ldGVycy5lbmNvZGUoaXRlbS5pbnB1dHMsIGFyZ3MpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBkYXRhID8gSGV4LmNvbmNhdChzZWxlY3RvciwgZGF0YSkgOiBzZWxlY3Rvcjtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUmVzdWx0KC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBbYWJpRnVuY3Rpb24sIG91dHB1dCwgb3B0aW9ucyA9IHt9XSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lLCBvdXRwdXQsIG9wdGlvbnNdID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHJldHVybiBbZnJvbUFiaShhYmksIG5hbWUpLCBvdXRwdXQsIG9wdGlvbnNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICAgIH0pKCk7XG4gICAgY29uc3QgeyBhcyA9ICdBcnJheScgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWVzID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGFiaUZ1bmN0aW9uLm91dHB1dHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXQpKVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgaWYgKGFzID09PSAnT2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG91dHB1dCk7XG4gICAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBBYmlQYXJhbWV0ZXJzLmVuY29kZShhYmlGdW5jdGlvbi5vdXRwdXRzLCB2YWx1ZXMpO1xufVxuLyoqXG4gKiBGb3JtYXRzIGFuIHtAbGluayBveCNBYmlGdW5jdGlvbi5BYmlGdW5jdGlvbn0gaW50byBhICoqSHVtYW4gUmVhZGFibGUgQUJJIEZ1bmN0aW9uKiouXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvcm1hdHRlZCA9IEFiaUZ1bmN0aW9uLmZvcm1hdCh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpRnVuY3Rpb24gLSBUaGUgQUJJIEZ1bmN0aW9uIHRvIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgQUJJIEZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGFiaUZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlGdW5jdGlvbik7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBhcmJpdHJhcnkgKipKU09OIEFCSSBGdW5jdGlvbioqIG9yICoqSHVtYW4gUmVhZGFibGUgQUJJIEZ1bmN0aW9uKiogaW50byBhIHR5cGVkIHtAbGluayBveCNBYmlGdW5jdGlvbi5BYmlGdW5jdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIEFCSXNcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbSh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogYXBwcm92ZVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBIdW1hbiBSZWFkYWJsZSBBQklzXG4gKlxuICogQSBIdW1hbiBSZWFkYWJsZSBBQkkgY2FuIGJlIHBhcnNlZCBpbnRvIGEgdHlwZWQgQUJJIG9iamVjdDpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbShcbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcyBzcGVuZGVyLCB1aW50MjU2IGFtb3VudCkgcmV0dXJucyAoYm9vbCknIC8vIFshY29kZSBobF1cbiAqIClcbiAqXG4gKiBhcHByb3ZlXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYHN0cnVjdGBzIGFsb25nIHdpdGggeW91ciBkZWZpbml0aW9uczpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbShbXG4gKiAgICdzdHJ1Y3QgRm9vIHsgYWRkcmVzcyBzcGVuZGVyOyB1aW50MjU2IGFtb3VudDsgfScsIC8vIFshY29kZSBobF1cbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoRm9vIGZvbykgcmV0dXJucyAoYm9vbCknLFxuICogXSlcbiAqXG4gKiBhcHByb3ZlXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqIEBwYXJhbSBhYmlGdW5jdGlvbiAtIFRoZSBBQkkgRnVuY3Rpb24gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUeXBlZCBBQkkgRnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFiaUZ1bmN0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gQWJpSXRlbS5mcm9tKGFiaUZ1bmN0aW9uLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYW4ge0BsaW5rIG94I0FiaUZ1bmN0aW9uLkFiaUZ1bmN0aW9ufSBmcm9tIGFuIHtAbGluayBveCNBYmkuQWJpfSBnaXZlbiBhIG5hbWUgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEV4dHJhY3RpbmcgYnkgTmFtZVxuICpcbiAqIEFCSSBGdW5jdGlvbnMgY2FuIGJlIGV4dHJhY3RlZCBieSB0aGVpciBuYW1lIHVzaW5nIHRoZSBgbmFtZWAgb3B0aW9uOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKCknLFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBvd25lciwgYWRkcmVzcyB0bywgdWludDI1NiB0b2tlbklkKScsXG4gKiAgICdmdW5jdGlvbiBiYXIoc3RyaW5nIGEpIHJldHVybnMgKHVpbnQyNTYgeCknLFxuICogXSlcbiAqXG4gKiBjb25zdCBpdGVtID0gQWJpRnVuY3Rpb24uZnJvbUFiaShhYmksICdmb28nKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFeHRyYWN0aW5nIGJ5IFNlbGVjdG9yXG4gKlxuICogQUJJIEZ1bmN0aW9ucyBjYW4gYmUgZXh0cmFjdCBieSB0aGVpciBzZWxlY3RvciB3aGVuIHtAbGluayBveCNIZXguSGV4fSBpcyBwcm92aWRlZCB0byBgbmFtZWAuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICogY29uc3QgaXRlbSA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoYWJpLCAnMHgwOTVlYTdiMycpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogRXh0cmFjdGluZyB2aWEgYSBoZXggc2VsZWN0b3IgaXMgdXNlZnVsIHdoZW4gZXh0cmFjdGluZyBhbiBBQkkgRnVuY3Rpb24gZnJvbSBhbiBgZXRoX2NhbGxgIFJQQyByZXNwb25zZSBvclxuICogZnJvbSBhIFRyYW5zYWN0aW9uIGBpbnB1dGAuXG4gKlxuICogOjo6XG4gKlxuICogQHBhcmFtIGFiaSAtIFRoZSBBQkkgdG8gZXh0cmFjdCBmcm9tLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSAob3Igc2VsZWN0b3IpIG9mIHRoZSBBQkkgaXRlbSB0byBleHRyYWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBFeHRyYWN0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQUJJIGl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWJpKGFiaSwgbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGl0ZW0gPSBBYmlJdGVtLmZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKTtcbiAgICBpZiAoaXRlbS50eXBlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5Ob3RGb3VuZEVycm9yKHsgbmFtZSwgdHlwZTogJ2Z1bmN0aW9uJyB9KTtcbiAgICByZXR1cm4gaXRlbTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFs0LWJ5dGUgc2VsZWN0b3JdKGh0dHBzOi8vc29saWRpdHktYnktZXhhbXBsZS5vcmcvZnVuY3Rpb24tc2VsZWN0b3IvKSBmb3IgYW4ge0BsaW5rIG94I0FiaUZ1bmN0aW9uLkFiaUZ1bmN0aW9ufS5cbiAqXG4gKiBVc2VmdWwgZm9yIGNvbXB1dGluZyBmdW5jdGlvbiBzZWxlY3RvcnMgZm9yIGNhbGxkYXRhLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzZWxlY3RvciA9IEFiaUZ1bmN0aW9uLmdldFNlbGVjdG9yKCdmdW5jdGlvbiBvd25lck9mKHVpbnQyNTYgdG9rZW5JZCknKVxuICogLy8gQGxvZzogJzB4NjM1MjIxMWUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2VsZWN0b3IgPSBBYmlGdW5jdGlvbi5nZXRTZWxlY3Rvcih7XG4gKiAgIGlucHV0czogW3sgdHlwZTogJ3VpbnQyNTYnIH1dLFxuICogICBuYW1lOiAnb3duZXJPZicsXG4gKiAgIG91dHB1dHM6IFtdLFxuICogICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAqICAgdHlwZTogJ2Z1bmN0aW9uJ1xuICogfSlcbiAqIC8vIEBsb2c6ICcweDYzNTIyMTFlJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIGl0ZW0gdG8gY29tcHV0ZSB0aGUgc2VsZWN0b3IgZm9yLlxuICogQHJldHVybnMgVGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIHtAbGluayBveCNIYXNoLihrZWNjYWsyNTY6ZnVuY3Rpb24pfSBoYXNoIG9mIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvcihhYmlJdGVtKSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZ2V0U2VsZWN0b3IoYWJpSXRlbSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlGdW5jdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiYWJpdHlwZSIsIkFiaUl0ZW0iLCJBYmlQYXJhbWV0ZXJzIiwiSGV4IiwiZGVjb2RlRGF0YSIsInBhcmFtZXRlcnMiLCJhYmlGdW5jdGlvbiIsImRhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJhYmkiLCJuYW1lIiwiZnJvbUFiaSIsIm92ZXJsb2FkcyIsInNpemUiLCJJbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IiLCJpbnB1dHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJpdGVtIiwiZGVjb2RlIiwic2xpY2UiLCJkZWNvZGVSZXN1bHQiLCJvcHRpb25zIiwidmFsdWVzIiwib3V0cHV0cyIsIk9iamVjdCIsImtleXMiLCJlbmNvZGVEYXRhIiwiYXJncyIsInNlbGVjdG9yIiwiZ2V0U2VsZWN0b3IiLCJlbmNvZGUiLCJjb25jYXQiLCJlbmNvZGVSZXN1bHQiLCJvdXRwdXQiLCJhcyIsImZvcm1hdCIsImZvcm1hdEFiaUl0ZW0iLCJmcm9tIiwidHlwZSIsIk5vdEZvdW5kRXJyb3IiLCJhYmlJdGVtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiFunction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiItem.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiItem.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AmbiguityError: () => (/* binding */ AmbiguityError),\n/* harmony export */   InvalidSelectorSizeError: () => (/* binding */ InvalidSelectorSizeError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector),\n/* harmony export */   getSignature: () => (/* binding */ getSignature),\n/* harmony export */   getSignatureHash: () => (/* binding */ getSignatureHash)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/parseAbiItem.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/abiItem.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/abiItem.js\");\n\n\n\n\n\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */ function format(abiItem) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n}\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */ function from(abiItem, options = {}) {\n    const { prepare = true } = options;\n    const item = (()=>{\n        if (Array.isArray(abiItem)) return abitype__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem(abiItem);\n        if (typeof abiItem === \"string\") return abitype__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...prepare ? {\n            hash: getSignatureHash(item)\n        } : {}\n    };\n}\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */ function fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = options ?? {};\n    const isSelector = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(name, {\n        strict: false\n    });\n    const abiItems = abi.filter((abiItem)=>{\n        if (isSelector) {\n            if (abiItem.type === \"function\" || abiItem.type === \"error\") return getSelector(abiItem) === _Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(name, 0, 4);\n            if (abiItem.type === \"event\") return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return \"name\" in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0) throw new NotFoundError({\n        name: name\n    });\n    if (abiItems.length === 1) return {\n        ...abiItems[0],\n        ...prepare ? {\n            hash: getSignatureHash(abiItems[0])\n        } : {}\n    };\n    let matchedAbiItem;\n    for (const abiItem of abiItems){\n        if (!(\"inputs\" in abiItem)) continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0) return {\n                ...abiItem,\n                ...prepare ? {\n                    hash: getSignatureHash(abiItem)\n                } : {}\n            };\n            continue;\n        }\n        if (!abiItem.inputs) continue;\n        if (abiItem.inputs.length === 0) continue;\n        if (abiItem.inputs.length !== args.length) continue;\n        const matched = args.every((arg, index)=>{\n            const abiParameter = \"inputs\" in abiItem && abiItem.inputs[index];\n            if (!abiParameter) return false;\n            return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem && \"inputs\" in matchedAbiItem && matchedAbiItem.inputs) {\n                const ambiguousTypes = _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes) throw new AmbiguityError({\n                    abiItem,\n                    type: ambiguousTypes[0]\n                }, {\n                    abiItem: matchedAbiItem,\n                    type: ambiguousTypes[1]\n                });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (()=>{\n        if (matchedAbiItem) return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return {\n            ...abiItem,\n            overloads\n        };\n    })();\n    if (!abiItem) throw new NotFoundError({\n        name: name\n    });\n    return {\n        ...abiItem,\n        ...prepare ? {\n            hash: getSignatureHash(abiItem)\n        } : {}\n    };\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getSelector(...parameters) {\n    const abiItem = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(getSignatureHash(abiItem), 0, 4);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getSignature(...parameters) {\n    const abiItem = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    const signature = (()=>{\n        if (typeof abiItem === \"string\") return abiItem;\n        return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n    })();\n    return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(signature);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getSignatureHash(...parameters) {\n    const abiItem = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    if (typeof abiItem !== \"string\" && \"hash\" in abiItem && abiItem.hash) return abiItem.hash;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_4__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(getSignature(abiItem)));\n}\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */ class AmbiguityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor(x, y){\n        super(\"Found ambiguous types in overloaded ABI Items.\", {\n            metaMessages: [\n                // TODO: abitype to add support for signature-formatted ABI items.\n                `\\`${x.type}\\` in \\`${_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(x.abiItem))}\\`, and`,\n                `\\`${y.type}\\` in \\`${_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(y.abiItem))}\\``,\n                \"\",\n                \"These types encode differently and cannot be distinguished at runtime.\",\n                \"Remove one of the ambiguous items in the ABI.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiItem.AmbiguityError\"\n        });\n    }\n}\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */ class NotFoundError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ name, data, type = \"item\" }){\n        const selector = (()=>{\n            if (name) return ` with name \"${name}\"`;\n            if (data) return ` with data \"${data}\"`;\n            return \"\";\n        })();\n        super(`ABI ${type}${selector} not found.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiItem.NotFoundError\"\n        });\n    }\n}\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */ class InvalidSelectorSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ data }){\n        super(`Selector size is invalid. Expected 4 bytes. Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(data)} bytes (\"${data}\").`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiItem.InvalidSelectorSizeError\"\n        });\n    }\n} //# sourceMappingURL=AbiItem.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUl0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0c7QUFDSjtBQUNGO0FBQ2tCO0FBQ2xEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdDQyxHQUNNLFNBQVNLLE9BQU9DLE9BQU87SUFDMUIsT0FBT04sa0RBQXFCLENBQUNNO0FBQ2pDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNHQyxHQUNNLFNBQVNFLEtBQUtGLE9BQU8sRUFBRUcsVUFBVSxDQUFDLENBQUM7SUFDdEMsTUFBTSxFQUFFQyxVQUFVLElBQUksRUFBRSxHQUFHRDtJQUMzQixNQUFNRSxPQUFPLENBQUM7UUFDVixJQUFJQyxNQUFNQyxPQUFPLENBQUNQLFVBQ2QsT0FBT04saURBQW9CLENBQUNNO1FBQ2hDLElBQUksT0FBT0EsWUFBWSxVQUNuQixPQUFPTixpREFBb0IsQ0FBQ007UUFDaEMsT0FBT0E7SUFDWDtJQUNBLE9BQU87UUFDSCxHQUFHSyxJQUFJO1FBQ1AsR0FBSUQsVUFBVTtZQUFFSyxNQUFNQyxpQkFBaUJMO1FBQU0sSUFBSSxDQUFDLENBQUM7SUFDdkQ7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrRUMsR0FDTSxTQUFTTSxRQUFRQyxHQUFHLEVBQUVDLElBQUksRUFBRVYsT0FBTztJQUN0QyxNQUFNLEVBQUVXLE9BQU8sRUFBRSxFQUFFVixVQUFVLElBQUksRUFBRSxHQUFJRCxXQUNuQyxDQUFDO0lBQ0wsTUFBTVksYUFBYWxCLDZDQUFZLENBQUNnQixNQUFNO1FBQUVJLFFBQVE7SUFBTTtJQUN0RCxNQUFNQyxXQUFXTixJ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RSxDQUFFO1FBQ2xCLEtBQUssQ0FBQyxDQUFDLHFEQUFxRCxFQUFFekQseUNBQVEsQ0FBQ3lELE1BQU0sU0FBUyxFQUFFQSxLQUFLLEdBQUcsQ0FBQztRQUNqR04sT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjNDMzNy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpSXRlbS5qcz9lZTUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFiaXR5cGUgZnJvbSAnYWJpdHlwZSc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvYWJpSXRlbS5qcyc7XG4vKipcbiAqIEZvcm1hdHMgYW4ge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0gaW50byBhICoqSHVtYW4gUmVhZGFibGUgQUJJIEl0ZW0qKi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb3JtYXR0ZWQgPSBBYmlJdGVtLmZvcm1hdCh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpSXRlbSAtIFRoZSBBQkkgSXRlbSB0byBmb3JtYXQuXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIEFCSSBJdGVtICAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoYWJpSXRlbSkge1xuICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpSXRlbSk7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBhcmJpdHJhcnkgKipKU09OIEFCSSBJdGVtKiogb3IgKipIdW1hbiBSZWFkYWJsZSBBQkkgSXRlbSoqIGludG8gYSB0eXBlZCB7QGxpbmsgb3gjQWJpSXRlbS5BYmlJdGVtfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEpTT04gQUJJc1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpSXRlbSA9IEFiaUl0ZW0uZnJvbSh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogYWJpSXRlbVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBIdW1hbiBSZWFkYWJsZSBBQklzXG4gKlxuICogQSBIdW1hbiBSZWFkYWJsZSBBQkkgY2FuIGJlIHBhcnNlZCBpbnRvIGEgdHlwZWQgQUJJIG9iamVjdDpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaUl0ZW0gPSBBYmlJdGVtLmZyb20oXG4gKiAgICdmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHJldHVybnMgKGJvb2wpJyAvLyBbIWNvZGUgaGxdXG4gKiApXG4gKlxuICogYWJpSXRlbVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBzcGVjaWZ5IGBzdHJ1Y3RgcyBhbG9uZyB3aXRoIHlvdXIgZGVmaW5pdGlvbnM6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmlJdGVtID0gQWJpSXRlbS5mcm9tKFtcbiAqICAgJ3N0cnVjdCBGb28geyBhZGRyZXNzIHNwZW5kZXI7IHVpbnQyNTYgYW1vdW50OyB9JywgLy8gWyFjb2RlIGhsXVxuICogICAnZnVuY3Rpb24gYXBwcm92ZShGb28gZm9vKSByZXR1cm5zIChib29sKScsXG4gKiBdKVxuICpcbiAqIGFiaUl0ZW1cbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIEl0ZW0gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgdHlwZWQgQUJJIEl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFiaUl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlcGFyZSA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFiaUl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlJdGVtKGFiaUl0ZW0pO1xuICAgICAgICBpZiAodHlwZW9mIGFiaUl0ZW0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlJdGVtKGFiaUl0ZW0pO1xuICAgICAgICByZXR1cm4gYWJpSXRlbTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLml0ZW0sXG4gICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGl0ZW0pIH0gOiB7fSksXG4gICAgfTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYW4ge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0gZnJvbSBhbiB7QGxpbmsgb3gjQWJpLkFiaX0gZ2l2ZW4gYSBuYW1lIGFuZCBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIEFCSSBJdGVtcyBjYW4gYmUgZXh0cmFjdGVkIGJ5IHRoZWlyIG5hbWUgdXNpbmcgdGhlIGBuYW1lYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3MgdG8sIHVpbnQyNTYgdG9rZW5JZCknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKlxuICogY29uc3QgaXRlbSA9IEFiaUl0ZW0uZnJvbUFiaShhYmksICdUcmFuc2ZlcicpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEV4dHJhY3RpbmcgYnkgU2VsZWN0b3JcbiAqXG4gKiBBQkkgSXRlbXMgY2FuIGJlIGV4dHJhY3QgYnkgdGhlaXIgc2VsZWN0b3Igd2hlbiB7QGxpbmsgb3gjSGV4LkhleH0gaXMgcHJvdmlkZWQgdG8gYG5hbWVgLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICogY29uc3QgaXRlbSA9IEFiaUl0ZW0uZnJvbUFiaShhYmksICcweDA5NWVhN2IzJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gICAgXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogRXh0cmFjdGluZyB2aWEgYSBoZXggc2VsZWN0b3IgaXMgdXNlZnVsIHdoZW4gZXh0cmFjdGluZyBhbiBBQkkgSXRlbSBmcm9tIGFuIGBldGhfY2FsbGAgUlBDIHJlc3BvbnNlLFxuICogYSBUcmFuc2FjdGlvbiBgaW5wdXRgLCBvciBmcm9tIEV2ZW50IExvZyBgdG9waWNzYC5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpIC0gVGhlIEFCSSB0byBleHRyYWN0IGZyb20uXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIChvciBzZWxlY3Rvcikgb2YgdGhlIEFCSSBpdGVtIHRvIGV4dHJhY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEV4dHJhY3Rpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBBQkkgaXRlbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcmdzID0gW10sIHByZXBhcmUgPSB0cnVlIH0gPSAob3B0aW9ucyA/P1xuICAgICAgICB7fSk7XG4gICAgY29uc3QgaXNTZWxlY3RvciA9IEhleC52YWxpZGF0ZShuYW1lLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgY29uc3QgYWJpSXRlbXMgPSBhYmkuZmlsdGVyKChhYmlJdGVtKSA9PiB7XG4gICAgICAgIGlmIChpc1NlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoYWJpSXRlbS50eXBlID09PSAnZnVuY3Rpb24nIHx8IGFiaUl0ZW0udHlwZSA9PT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2VsZWN0b3IoYWJpSXRlbSkgPT09IEhleC5zbGljZShuYW1lLCAwLCA0KTtcbiAgICAgICAgICAgIGlmIChhYmlJdGVtLnR5cGUgPT09ICdldmVudCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgPT09IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICduYW1lJyBpbiBhYmlJdGVtICYmIGFiaUl0ZW0ubmFtZSA9PT0gbmFtZTtcbiAgICB9KTtcbiAgICBpZiAoYWJpSXRlbXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcih7IG5hbWU6IG5hbWUgfSk7XG4gICAgaWYgKGFiaUl0ZW1zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmFiaUl0ZW1zWzBdLFxuICAgICAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbXNbMF0pIH0gOiB7fSksXG4gICAgICAgIH07XG4gICAgbGV0IG1hdGNoZWRBYmlJdGVtO1xuICAgIGZvciAoY29uc3QgYWJpSXRlbSBvZiBhYmlJdGVtcykge1xuICAgICAgICBpZiAoISgnaW5wdXRzJyBpbiBhYmlJdGVtKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWFyZ3MgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICghYWJpSXRlbS5pbnB1dHMgfHwgYWJpSXRlbS5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFiaUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWJpSXRlbS5pbnB1dHMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGFiaUl0ZW0uaW5wdXRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYWJpSXRlbS5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBtYXRjaGVkID0gYXJncy5ldmVyeSgoYXJnLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWJpUGFyYW1ldGVyID0gJ2lucHV0cycgaW4gYWJpSXRlbSAmJiBhYmlJdGVtLmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIWFiaVBhcmFtZXRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWwuaXNBcmdPZlR5cGUoYXJnLCBhYmlQYXJhbWV0ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhbWJpZ3VpdHkgYWdhaW5zdCBhbHJlYWR5IG1hdGNoZWQgcGFyYW1ldGVycyAoZS5nLiBgYWRkcmVzc2AgdnMgYGJ5dGVzMjBgKS5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkQWJpSXRlbSAmJlxuICAgICAgICAgICAgICAgICdpbnB1dHMnIGluIG1hdGNoZWRBYmlJdGVtICYmXG4gICAgICAgICAgICAgICAgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW1iaWd1b3VzVHlwZXMgPSBpbnRlcm5hbC5nZXRBbWJpZ3VvdXNUeXBlcyhhYmlJdGVtLmlucHV0cywgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoYW1iaWd1b3VzVHlwZXMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbWJpZ3VpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYW1iaWd1b3VzVHlwZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiaUl0ZW06IG1hdGNoZWRBYmlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYW1iaWd1b3VzVHlwZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hlZEFiaUl0ZW0gPSBhYmlJdGVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFiaUl0ZW0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAobWF0Y2hlZEFiaUl0ZW0pXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZEFiaUl0ZW07XG4gICAgICAgIGNvbnN0IFthYmlJdGVtLCAuLi5vdmVybG9hZHNdID0gYWJpSXRlbXM7XG4gICAgICAgIHJldHVybiB7IC4uLmFiaUl0ZW0sIG92ZXJsb2FkcyB9O1xuICAgIH0pKCk7XG4gICAgaWYgKCFhYmlJdGVtKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcih7IG5hbWU6IG5hbWUgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYWJpSXRlbSxcbiAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgfSA6IHt9KSxcbiAgICB9O1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvciguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgYWJpSXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUFiaShhYmksIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzWzBdO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIEhleC5zbGljZShnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pLCAwLCA0KTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnbmF0dXJlKC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBhYmlJdGVtID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFthYmksIG5hbWVdID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHJldHVybiBmcm9tQWJpKGFiaSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnNbMF07XG4gICAgfSkoKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGFiaUl0ZW0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGFiaUl0ZW07XG4gICAgICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpSXRlbSk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gaW50ZXJuYWwubm9ybWFsaXplU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25hdHVyZUhhc2goLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IGFiaUl0ZW0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgbmFtZV0gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIGZyb21BYmkoYWJpLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVyc1swXTtcbiAgICB9KSgpO1xuICAgIGlmICh0eXBlb2YgYWJpSXRlbSAhPT0gJ3N0cmluZycgJiYgJ2hhc2gnIGluIGFiaUl0ZW0gJiYgYWJpSXRlbS5oYXNoKVxuICAgICAgICByZXR1cm4gYWJpSXRlbS5oYXNoO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihIZXguZnJvbVN0cmluZyhnZXRTaWduYXR1cmUoYWJpSXRlbSkpKTtcbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gYW1iaWd1b3VzIHR5cGVzIGFyZSBmb3VuZCBvbiBvdmVybG9hZGVkIEFCSSBpdGVtcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsICdmdW5jdGlvbiBmb28oYnl0ZXMyMCknXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnZm9vJywge1xuICogICBhcmdzOiBbJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSddLFxuICogfSlcbiAqIC8vIEBlcnJvcjogQWJpSXRlbS5BbWJpZ3VpdHlFcnJvcjogRm91bmQgYW1iaWd1b3VzIHR5cGVzIGluIG92ZXJsb2FkZWQgQUJJIEl0ZW1zLlxuICogLy8gQGVycm9yOiBgYnl0ZXMyMGAgaW4gYGZvbyhieXRlczIwKWAsIGFuZFxuICogLy8gQGVycm9yOiBgYWRkcmVzc2AgaW4gYGZvbyhhZGRyZXNzKWBcbiAqIC8vIEBlcnJvcjogVGhlc2UgdHlwZXMgZW5jb2RlIGRpZmZlcmVudGx5IGFuZCBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCBhdCBydW50aW1lLlxuICogLy8gQGVycm9yOiBSZW1vdmUgb25lIG9mIHRoZSBhbWJpZ3VvdXMgaXRlbXMgaW4gdGhlIEFCSS5cbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFJlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyB0eXBlcyBmcm9tIHRoZSBBQkkuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oYWRkcmVzcyknLFxuICogICAnZnVuY3Rpb24gZm9vKGJ5dGVzMjApJyAvLyBbIWNvZGUgLS1dXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICdmb28nLCB7XG4gKiAgIGFyZ3M6IFsnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJ10sXG4gKiB9KVxuICogLy8gQGVycm9yOiBBYmlJdGVtLkFtYmlndWl0eUVycm9yOiBGb3VuZCBhbWJpZ3VvdXMgdHlwZXMgaW4gb3ZlcmxvYWRlZCBBQkkgSXRlbXMuXG4gKiAvLyBAZXJyb3I6IGBieXRlczIwYCBpbiBgZm9vKGJ5dGVzMjApYCwgYW5kXG4gKiAvLyBAZXJyb3I6IGBhZGRyZXNzYCBpbiBgZm9vKGFkZHJlc3MpYFxuICogLy8gQGVycm9yOiBUaGVzZSB0eXBlcyBlbmNvZGUgZGlmZmVyZW50bHkgYW5kIGNhbm5vdCBiZSBkaXN0aW5ndWlzaGVkIGF0IHJ1bnRpbWUuXG4gKiAvLyBAZXJyb3I6IFJlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyBpdGVtcyBpbiB0aGUgQUJJLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBbWJpZ3VpdHlFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgc3VwZXIoJ0ZvdW5kIGFtYmlndW91cyB0eXBlcyBpbiBvdmVybG9hZGVkIEFCSSBJdGVtcy4nLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhYml0eXBlIHRvIGFkZCBzdXBwb3J0IGZvciBzaWduYXR1cmUtZm9ybWF0dGVkIEFCSSBpdGVtcy5cbiAgICAgICAgICAgICAgICBgXFxgJHt4LnR5cGV9XFxgIGluIFxcYCR7aW50ZXJuYWwubm9ybWFsaXplU2lnbmF0dXJlKGFiaXR5cGUuZm9ybWF0QWJpSXRlbSh4LmFiaUl0ZW0pKX1cXGAsIGFuZGAsXG4gICAgICAgICAgICAgICAgYFxcYCR7eS50eXBlfVxcYCBpbiBcXGAke2ludGVybmFsLm5vcm1hbGl6ZVNpZ25hdHVyZShhYml0eXBlLmZvcm1hdEFiaUl0ZW0oeS5hYmlJdGVtKSl9XFxgYCxcbiAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAnVGhlc2UgdHlwZXMgZW5jb2RlIGRpZmZlcmVudGx5IGFuZCBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCBhdCBydW50aW1lLicsXG4gICAgICAgICAgICAgICAgJ1JlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyBpdGVtcyBpbiB0aGUgQUJJLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUl0ZW0uQW1iaWd1aXR5RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gYW4gQUJJIGl0ZW0gaXMgbm90IGZvdW5kIGluIHRoZSBBQkkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oYWRkcmVzcyknLFxuICogICAnZnVuY3Rpb24gYmFyKHVpbnQpJ1xuICogXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnYmF6JylcbiAqIC8vIEBlcnJvcjogQWJpSXRlbS5Ob3RGb3VuZEVycm9yOiBBQkkgZnVuY3Rpb24gd2l0aCBuYW1lIFwiYmF6XCIgbm90IGZvdW5kLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogRW5zdXJlIHRoZSBBQkkgaXRlbSBleGlzdHMgb24gdGhlIEFCSS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcih1aW50KScsXG4gKiAgICdmdW5jdGlvbiBiYXooYm9vbCknIC8vIFshY29kZSArK11cbiAqIF0pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJ2JheicpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG5hbWUsIGRhdGEsIHR5cGUgPSAnaXRlbScsIH0pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAgd2l0aCBuYW1lIFwiJHtuYW1lfVwiYDtcbiAgICAgICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybiBgIHdpdGggZGF0YSBcIiR7ZGF0YX1cImA7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHN1cGVyKGBBQkkgJHt0eXBlfSR7c2VsZWN0b3J9IG5vdCBmb3VuZC5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUl0ZW0uTm90Rm91bmRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB0aGUgc2VsZWN0b3Igc2l6ZSBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvbyA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsXG4gKiAgICdmdW5jdGlvbiBiYXIodWludCknXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICcweGFhYScpXG4gKiAvLyBAZXJyb3I6IEFiaUl0ZW0uSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yOiBTZWxlY3RvciBzaXplIGlzIGludmFsaWQuIEV4cGVjdGVkIDQgYnl0ZXMuIFJlY2VpdmVkIDIgYnl0ZXMgKFwiMHhhYWFcIikuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBFbnN1cmUgdGhlIHNlbGVjdG9yIHNpemUgaXMgNCBieXRlcy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcih1aW50KSdcbiAqIF0pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJzB4N2FmODJiMWEnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGRhdGEgfSkge1xuICAgICAgICBzdXBlcihgU2VsZWN0b3Igc2l6ZSBpcyBpbnZhbGlkLiBFeHBlY3RlZCA0IGJ5dGVzLiBSZWNlaXZlZCAke0hleC5zaXplKGRhdGEpfSBieXRlcyAoXCIke2RhdGF9XCIpLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpSXRlbS5JbnZhbGlkU2VsZWN0b3JTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFiaUl0ZW0uanMubWFwIl0sIm5hbWVzIjpbImFiaXR5cGUiLCJFcnJvcnMiLCJIYXNoIiwiSGV4IiwiaW50ZXJuYWwiLCJmb3JtYXQiLCJhYmlJdGVtIiwiZm9ybWF0QWJpSXRlbSIsImZyb20iLCJvcHRpb25zIiwicHJlcGFyZSIsIml0ZW0iLCJBcnJheSIsImlzQXJyYXkiLCJwYXJzZUFiaUl0ZW0iLCJoYXNoIiwiZ2V0U2lnbmF0dXJlSGFzaCIsImZyb21BYmkiLCJhYmkiLCJuYW1lIiwiYXJncyIsImlzU2VsZWN0b3IiLCJ2YWxpZGF0ZSIsInN0cmljdCIsImFiaUl0ZW1zIiwiZmlsdGVyIiwidHlwZSIsImdldFNlbGVjdG9yIiwic2xpY2UiLCJsZW5ndGgiLCJOb3RGb3VuZEVycm9yIiwibWF0Y2hlZEFiaUl0ZW0iLCJpbnB1dHMiLCJtYXRjaGVkIiwiZXZlcnkiLCJhcmciLCJpbmRleCIsImFiaVBhcmFtZXRlciIsImlzQXJnT2ZUeXBlIiwiYW1iaWd1b3VzVHlwZXMiLCJnZXRBbWJpZ3VvdXNUeXBlcyIsIkFtYmlndWl0eUVycm9yIiwib3ZlcmxvYWRzIiwicGFyYW1ldGVycyIsImdldFNpZ25hdHVyZSIsInNpZ25hdHVyZSIsIm5vcm1hbGl6ZVNpZ25hdHVyZSIsImtlY2NhazI1NiIsImZyb21TdHJpbmciLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsIngiLCJ5IiwibWV0YU1lc3NhZ2VzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsImRhdGEiLCJzZWxlY3RvciIsIkludmFsaWRTZWxlY3RvclNpemVFcnJvciIsInNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiParameters.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiParameters.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayLengthMismatchError: () => (/* binding */ ArrayLengthMismatchError),\n/* harmony export */   BytesSizeMismatchError: () => (/* binding */ BytesSizeMismatchError),\n/* harmony export */   DataSizeTooSmallError: () => (/* binding */ DataSizeTooSmallError),\n/* harmony export */   InvalidArrayError: () => (/* binding */ InvalidArrayError),\n/* harmony export */   InvalidTypeError: () => (/* binding */ InvalidTypeError),\n/* harmony export */   LengthMismatchError: () => (/* binding */ LengthMismatchError),\n/* harmony export */   ZeroDataError: () => (/* binding */ ZeroDataError),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodePacked: () => (/* binding */ encodePacked),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/abiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/abiParameters.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/cursor.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/cursor.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Solidity.js */ \"(ssr)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decode(parameters, data, options = {}) {\n    const { as = \"Array\", checksumAddress = false } = options;\n    const bytes = typeof data === \"string\" ? _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(data) : data;\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_1__.create(bytes);\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) === 0 && parameters.length > 0) throw new ZeroDataError();\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) && _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) < 32) throw new DataSizeTooSmallError({\n        data: typeof data === \"string\" ? data : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data),\n        parameters: parameters,\n        size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes)\n    });\n    let consumed = 0;\n    const values = as === \"Array\" ? [] : {};\n    for(let i = 0; i < parameters.length; ++i){\n        const param = parameters[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: 0\n        });\n        consumed += consumed_;\n        if (as === \"Array\") values.push(data);\n        else values[param.name ?? i] = data;\n    }\n    return values;\n}\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */ function encode(parameters, values, options) {\n    const { checksumAddress = false } = options ?? {};\n    if (parameters.length !== values.length) throw new LengthMismatchError({\n        expectedLength: parameters.length,\n        givenLength: values.length\n    });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParameters = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.prepareParameters({\n        checksumAddress,\n        parameters: parameters,\n        values: values\n    });\n    const data = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.encode(preparedParameters);\n    if (data.length === 0) return \"0x\";\n    return data;\n}\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */ function encodePacked(types, values) {\n    if (types.length !== values.length) throw new LengthMismatchError({\n        expectedLength: types.length,\n        givenLength: values.length\n    });\n    const data = [];\n    for(let i = 0; i < types.length; i++){\n        const type = types[i];\n        const value = values[i];\n        data.push(encodePacked.encode(type, value));\n    }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...data);\n}\n(function(encodePacked) {\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    function encode(type, value, isArray = false) {\n        if (type === \"address\") {\n            const address = value;\n            _Address_js__WEBPACK_IMPORTED_MODULE_4__.assert(address);\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n        }\n        if (type === \"string\") return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n        if (type === \"bytes\") return value;\n        if (type === \"bool\") return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value), isArray ? 32 : 1);\n        const intMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.integerRegex);\n        if (intMatch) {\n            const [_type, baseType, bits = \"256\"] = intMatch;\n            const size = Number.parseInt(bits, 10) / 8;\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n                size: isArray ? 32 : size,\n                signed: baseType === \"int\"\n            });\n        }\n        const bytesMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.bytesRegex);\n        if (bytesMatch) {\n            const [_type, size] = bytesMatch;\n            if (Number.parseInt(size, 10) !== (value.length - 2) / 2) throw new BytesSizeMismatchError({\n                expectedSize: Number.parseInt(size, 10),\n                value: value\n            });\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, isArray ? 32 : 0);\n        }\n        const arrayMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.arrayRegex);\n        if (arrayMatch && Array.isArray(value)) {\n            const [_type, childType] = arrayMatch;\n            const data = [];\n            for(let i = 0; i < value.length; i++){\n                data.push(encode(childType, value[i], true));\n            }\n            if (data.length === 0) return \"0x\";\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...data);\n        }\n        throw new InvalidTypeError(type);\n    }\n    encodePacked.encode = encode;\n})(encodePacked || (encodePacked = {}));\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */ function format(parameters) {\n    return abitype__WEBPACK_IMPORTED_MODULE_6__.formatAbiParameters(parameters);\n}\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */ function from(parameters) {\n    if (Array.isArray(parameters) && typeof parameters[0] === \"string\") return abitype__WEBPACK_IMPORTED_MODULE_7__.parseAbiParameters(parameters);\n    if (typeof parameters === \"string\") return abitype__WEBPACK_IMPORTED_MODULE_7__.parseAbiParameters(parameters);\n    return parameters;\n}\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                               2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */ class DataSizeTooSmallError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ data, parameters, size }){\n        super(`Data size of ${size} bytes is too small for given parameters.`, {\n            metaMessages: [\n                `Params: (${abitype__WEBPACK_IMPORTED_MODULE_6__.formatAbiParameters(parameters)})`,\n                `Data:   ${data} (${size} bytes)`\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.DataSizeTooSmallError\"\n        });\n    }\n}\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                             zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */ class ZeroDataError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(){\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.ZeroDataError\"\n        });\n    }\n}\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                                expected: 3    length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                           length: 3\n * ```\n */ class ArrayLengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedLength, givenLength, type }){\n        super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.ArrayLengthMismatchError\"\n        });\n    }\n}\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                             expected: 8 bytes    size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                         size: 8 bytes\n * ```\n */ class BytesSizeMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedSize, value }){\n        super(`Size of bytes \"${value}\" (bytes${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.BytesSizeMismatchError\"\n        });\n    }\n}\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */ class LengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedLength, givenLength }){\n        super([\n            \"ABI encoding parameters/values length mismatch.\",\n            `Expected length (parameters): ${expectedLength}`,\n            `Given length (values): ${givenLength}`\n        ].join(\"\\n\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.LengthMismatchError\"\n        });\n    }\n}\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */ class InvalidArrayError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(value){\n        super(`Value \\`${value}\\` is not a valid array.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.InvalidArrayError\"\n        });\n    }\n}\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                               invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */ class InvalidTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(type){\n        super(`Type \\`${type}\\` is not a valid ABI Type.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.InvalidTypeError\"\n        });\n    }\n} //# sourceMappingURL=AbiParameters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaVBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0s7QUFDSjtBQUNFO0FBQ047QUFDd0I7QUFDVDtBQUNMO0FBQzFDLCtDQUErQztBQUN4QyxTQUFTUSxPQUFPQyxVQUFVLEVBQUVDLElBQUksRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDakQsTUFBTSxFQUFFQyxLQUFLLE9BQU8sRUFBRUMsa0JBQWtCLEtBQUssRUFBRSxHQUFHRjtJQUNsRCxNQUFNRyxRQUFRLE9BQU9KLFNBQVMsV0FBV1IsOENBQWEsQ0FBQ1EsUUFBUUE7SUFDL0QsTUFBTU0sU0FBU1YsdURBQWEsQ0FBQ1E7SUFDN0IsSUFBSVosMkNBQVUsQ0FBQ1ksV0FBVyxLQUFLTCxXQUFXVSxNQUFNLEdBQUcsR0FDL0MsTUFBTSxJQUFJQztJQUNkLElBQUlsQiwyQ0FBVSxDQUFDWSxVQUFVWiwyQ0FBVSxDQUFDWSxTQUFTLElBQ3pDLE1BQU0sSUFBSU8sc0JBQXNCO1FBQzVCWCxNQUFNLE9BQU9BLFNBQVMsV0FBV0EsT0FBT04sOENBQWEsQ0FBQ007UUFDdERELFlBQVlBO1FBQ1pTLE1BQU1oQiwyQ0FBVSxDQUFDWTtJQUNyQjtJQUNKLElBQUlTLFdBQVc7SUFDZixNQUFNQyxTQUFTWixPQUFPLFVBQVUsRUFBRSxHQUFHLENBQUM7SUFDdEMsSUFBSyxJQUFJYSxJQUFJLEdBQUdBLElBQUloQixXQUFXVSxNQUFNLEVBQUUsRUFBRU0sRUFBRztRQUN4QyxNQUFNQyxRQUFRakIsVUFBVSxDQUFDZ0IsRUFBRTtRQUMzQlQsT0FBT1csV0FBVyxDQUFDSjtRQUNuQixNQUFNLENBQUNiLE1BQU1rQixVQUFVLEdBQUd2Qix1RUFBd0IsQ0FBQ1csUUFBUVUsT0FBTztZQUM5RGI7WUFDQWlCLGdCQUFnQjtRQUNwQjtRQUNBUCxZQUFZSztRQUNaLElBQUloQixPQUFPLFNBQ1BZLE9BQU9PLElBQUks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QWM7WUFDZEMsVUFBVTtZQUNWeEMsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYzQzMzctZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaVBhcmFtZXRlcnMuanM/ZjU1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhYml0eXBlIGZyb20gJ2FiaXR5cGUnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvYWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBDdXJzb3IgZnJvbSAnLi9pbnRlcm5hbC9jdXJzb3IuanMnO1xuaW1wb3J0ICogYXMgU29saWRpdHkgZnJvbSAnLi9Tb2xpZGl0eS5qcyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShwYXJhbWV0ZXJzLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0FycmF5JywgY2hlY2tzdW1BZGRyZXNzID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBCeXRlcy5mcm9tSGV4KGRhdGEpIDogZGF0YTtcbiAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKGJ5dGVzKTtcbiAgICBpZiAoQnl0ZXMuc2l6ZShieXRlcykgPT09IDAgJiYgcGFyYW1ldGVycy5sZW5ndGggPiAwKVxuICAgICAgICB0aHJvdyBuZXcgWmVyb0RhdGFFcnJvcigpO1xuICAgIGlmIChCeXRlcy5zaXplKGJ5dGVzKSAmJiBCeXRlcy5zaXplKGJ5dGVzKSA8IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRGF0YVNpemVUb29TbWFsbEVycm9yKHtcbiAgICAgICAgICAgIGRhdGE6IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBIZXguZnJvbUJ5dGVzKGRhdGEpLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogcGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNpemU6IEJ5dGVzLnNpemUoYnl0ZXMpLFxuICAgICAgICB9KTtcbiAgICBsZXQgY29uc3VtZWQgPSAwO1xuICAgIGNvbnN0IHZhbHVlcyA9IGFzID09PSAnQXJyYXknID8gW10gOiB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBwYXJhbWV0ZXJzW2ldO1xuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oY29uc3VtZWQpO1xuICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGludGVybmFsLmRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgaWYgKGFzID09PSAnQXJyYXknKVxuICAgICAgICAgICAgdmFsdWVzLnB1c2goZGF0YSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbHVlc1twYXJhbS5uYW1lID8/IGldID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbi8qKlxuICogRW5jb2RlcyBwcmltaXRpdmUgdmFsdWVzIGludG8gQUJJIGVuY29kZWQgZGF0YSBhcyBwZXIgdGhlIFtBcHBsaWNhdGlvbiBCaW5hcnkgSW50ZXJmYWNlIChBQkkpIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2xhdGVzdC9hYmktc3BlYykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEFiaVBhcmFtZXRlcnMuZW5jb2RlKFxuICogICBBYmlQYXJhbWV0ZXJzLmZyb20oWydzdHJpbmcnLCAndWludCcsICdib29sJ10pLFxuICogICBbJ3dhZ21pJywgNDIwbiwgdHJ1ZV0sXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEpTT04gUGFyYW1ldGVyc1xuICpcbiAqIFNwZWNpZnkgKipKU09OIEFCSSoqIFBhcmFtZXRlcnMgYXMgc2NoZW1hOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEFiaVBhcmFtZXRlcnMuZW5jb2RlKFxuICogICBbXG4gKiAgICAgeyB0eXBlOiAnc3RyaW5nJywgbmFtZTogJ25hbWUnIH0sXG4gKiAgICAgeyB0eXBlOiAndWludCcsIG5hbWU6ICdhZ2UnIH0sXG4gKiAgICAgeyB0eXBlOiAnYm9vbCcsIG5hbWU6ICdpc093bmVyJyB9LFxuICogICBdLFxuICogICBbJ3dhZ21pJywgNDIwbiwgdHJ1ZV0sXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAtIFRoZSBzZXQgb2YgQUJJIHBhcmFtZXRlcnMgdG8gZW5jb2RlLCBpbiB0aGUgc2hhcGUgb2YgdGhlIGBpbnB1dHNgIG9yIGBvdXRwdXRzYCBhdHRyaWJ1dGUgb2YgYW4gQUJJIEl0ZW0uIFRoZXNlIHBhcmFtZXRlcnMgbXVzdCBpbmNsdWRlIHZhbGlkIFtBQkkgdHlwZXNdKGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2xhdGVzdC90eXBlcy5odG1sKS5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgc2V0IG9mIHByaW1pdGl2ZSB2YWx1ZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBBQkkgdHlwZXMgZGVmaW5lZCBpbiBgcGFyYW1ldGVyc2AuXG4gKiBAcmV0dXJucyBBQkkgZW5jb2RlZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHBhcmFtZXRlcnMsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzID0gZmFsc2UgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgaWYgKHBhcmFtZXRlcnMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgTGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZExlbmd0aDogcGFyYW1ldGVycy5sZW5ndGgsXG4gICAgICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgLy8gUHJlcGFyZSB0aGUgcGFyYW1ldGVycyB0byBkZXRlcm1pbmUgZHluYW1pYyB0eXBlcyB0byBlbmNvZGUuXG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gaW50ZXJuYWwucHJlcGFyZVBhcmFtZXRlcnMoe1xuICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBpbnRlcm5hbC5lbmNvZGUocHJlcGFyZWRQYXJhbWV0ZXJzKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBFbmNvZGVzIGFuIGFycmF5IG9mIHByaW1pdGl2ZSB2YWx1ZXMgdG8gYSBbcGFja2VkIEFCSSBlbmNvZGluZ10oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L2FiaS1zcGVjLmh0bWwjbm9uLXN0YW5kYXJkLXBhY2tlZC1tb2RlKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbmNvZGVkID0gQWJpUGFyYW1ldGVycy5lbmNvZGVQYWNrZWQoXG4gKiAgIFsnYWRkcmVzcycsICdzdHJpbmcnXSxcbiAqICAgWycweGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDUnLCAnaGVsbG8gd29ybGQnXSxcbiAqIClcbiAqIC8vIEBsb2c6ICcweGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDU2ODY1NmM2YzZmMjA3NzZmNzI2YzY0J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHR5cGVzIC0gU2V0IG9mIEFCSSB0eXBlcyB0byBwYWNrIGVuY29kZS5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgc2V0IG9mIHByaW1pdGl2ZSB2YWx1ZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBBQkkgdHlwZXMgZGVmaW5lZCBpbiBgdHlwZXNgLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQgcGFja2VkIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVQYWNrZWQodHlwZXMsIHZhbHVlcykge1xuICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBMZW5ndGhNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoOiB0eXBlcy5sZW5ndGgsXG4gICAgICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgZGF0YS5wdXNoKGVuY29kZVBhY2tlZC5lbmNvZGUodHlwZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIEhleC5jb25jYXQoLi4uZGF0YSk7XG59XG4oZnVuY3Rpb24gKGVuY29kZVBhY2tlZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG4gICAgZnVuY3Rpb24gZW5jb2RlKHR5cGUsIHZhbHVlLCBpc0FycmF5ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHZhbHVlO1xuICAgICAgICAgICAgQWRkcmVzcy5hc3NlcnQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gSGV4LnBhZExlZnQoYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBpc0FycmF5ID8gMzIgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gSGV4LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJylcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdib29sJylcbiAgICAgICAgICAgIHJldHVybiBIZXgucGFkTGVmdChIZXguZnJvbUJvb2xlYW4odmFsdWUpLCBpc0FycmF5ID8gMzIgOiAxKTtcbiAgICAgICAgY29uc3QgaW50TWF0Y2ggPSB0eXBlLm1hdGNoKFNvbGlkaXR5LmludGVnZXJSZWdleCk7XG4gICAgICAgIGlmIChpbnRNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgW190eXBlLCBiYXNlVHlwZSwgYml0cyA9ICcyNTYnXSA9IGludE1hdGNoO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IE51bWJlci5wYXJzZUludChiaXRzLCAxMCkgLyA4O1xuICAgICAgICAgICAgcmV0dXJuIEhleC5mcm9tTnVtYmVyKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogaXNBcnJheSA/IDMyIDogc2l6ZSxcbiAgICAgICAgICAgICAgICBzaWduZWQ6IGJhc2VUeXBlID09PSAnaW50JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzTWF0Y2ggPSB0eXBlLm1hdGNoKFNvbGlkaXR5LmJ5dGVzUmVnZXgpO1xuICAgICAgICBpZiAoYnl0ZXNNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgW190eXBlLCBzaXplXSA9IGJ5dGVzTWF0Y2g7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KHNpemUsIDEwKSAhPT0gKHZhbHVlLmxlbmd0aCAtIDIpIC8gMilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHNpemUsIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIEhleC5wYWRSaWdodCh2YWx1ZSwgaXNBcnJheSA/IDMyIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJyYXlNYXRjaCA9IHR5cGUubWF0Y2goU29saWRpdHkuYXJyYXlSZWdleCk7XG4gICAgICAgIGlmIChhcnJheU1hdGNoICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBbX3R5cGUsIGNoaWxkVHlwZV0gPSBhcnJheU1hdGNoO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChlbmNvZGUoY2hpbGRUeXBlLCB2YWx1ZVtpXSwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAnMHgnO1xuICAgICAgICAgICAgcmV0dXJuIEhleC5jb25jYXQoLi4uZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUeXBlRXJyb3IodHlwZSk7XG4gICAgfVxuICAgIGVuY29kZVBhY2tlZC5lbmNvZGUgPSBlbmNvZGU7XG59KShlbmNvZGVQYWNrZWQgfHwgKGVuY29kZVBhY2tlZCA9IHt9KSk7XG4vKipcbiAqIEZvcm1hdHMge0BsaW5rIG94I0FiaVBhcmFtZXRlcnMuQWJpUGFyYW1ldGVyc30gaW50byAqKkh1bWFuIFJlYWRhYmxlIEFCSSBQYXJhbWV0ZXJzKiouXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9ybWF0dGVkID0gQWJpUGFyYW1ldGVycy5mb3JtYXQoW1xuICogICB7XG4gKiAgICAgbmFtZTogJ3NwZW5kZXInLFxuICogICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgfSxcbiAqICAge1xuICogICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgfSxcbiAqIF0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAtIFRoZSBBQkkgUGFyYW1ldGVycyB0byBmb3JtYXQuXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIEFCSSBQYXJhbWV0ZXJzICAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQocGFyYW1ldGVycykge1xuICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaVBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG59XG4vKipcbiAqIFBhcnNlcyBhcmJpdHJhcnkgKipKU09OIEFCSSBQYXJhbWV0ZXJzKiogb3IgKipIdW1hbiBSZWFkYWJsZSBBQkkgUGFyYW1ldGVycyoqIGludG8gdHlwZWQge0BsaW5rIG94I0FiaVBhcmFtZXRlcnMuQWJpUGFyYW1ldGVyc30uXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIFBhcmFtZXRlcnNcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHBhcmFtZXRlcnMgPSBBYmlQYXJhbWV0ZXJzLmZyb20oW1xuICogICB7XG4gKiAgICAgbmFtZTogJ3NwZW5kZXInLFxuICogICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgfSxcbiAqICAge1xuICogICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgfSxcbiAqIF0pXG4gKlxuICogcGFyYW1ldGVyc1xuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSHVtYW4gUmVhZGFibGUgUGFyYW1ldGVyc1xuICpcbiAqIEh1bWFuIFJlYWRhYmxlIEFCSSBQYXJhbWV0ZXJzIGNhbiBiZSBwYXJzZWQgaW50byBhIHR5cGVkIHtAbGluayBveCNBYmlQYXJhbWV0ZXJzLkFiaVBhcmFtZXRlcnN9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcGFyYW1ldGVycyA9IEFiaVBhcmFtZXRlcnMuZnJvbSgnYWRkcmVzcyBzcGVuZGVyLCB1aW50MjU2IGFtb3VudCcpXG4gKlxuICogcGFyYW1ldGVyc1xuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBzcGVjaWZ5IGBzdHJ1Y3RgcyBhbG9uZyB3aXRoIHlvdXIgZGVmaW5pdGlvbnM6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwYXJhbWV0ZXJzID0gQWJpUGFyYW1ldGVycy5mcm9tKFtcbiAqICAgJ3N0cnVjdCBGb28geyBhZGRyZXNzIHNwZW5kZXI7IHVpbnQyNTYgYW1vdW50OyB9JywgLy8gWyFjb2RlIGhsXVxuICogICAnRm9vIGZvbywgYWRkcmVzcyBiYXInLFxuICogXSlcbiAqXG4gKiBwYXJhbWV0ZXJzXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gVGhlIEFCSSBQYXJhbWV0ZXJzIHRvIHBhcnNlLlxuICogQHJldHVybnMgVGhlIHR5cGVkIEFCSSBQYXJhbWV0ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShwYXJhbWV0ZXJzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykgJiYgdHlwZW9mIHBhcmFtZXRlcnNbMF0gPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gYWJpdHlwZS5wYXJzZUFiaVBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbWV0ZXJzID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB0aGUgZGF0YSBzaXplIGlzIHRvbyBzbWFsbCBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ3VpbnQyNTYnIH1dLCAnMHgwMTBmJylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKdjCAyIGJ5dGVzXG4gKiAvLyBAZXJyb3I6IEFiaVBhcmFtZXRlcnMuRGF0YVNpemVUb29TbWFsbEVycm9yOiBEYXRhIHNpemUgb2YgMiBieXRlcyBpcyB0b28gc21hbGwgZm9yIGdpdmVuIHBhcmFtZXRlcnMuXG4gKiAvLyBAZXJyb3I6IFBhcmFtczogKHVpbnQyNTYpXG4gKiAvLyBAZXJyb3I6IERhdGE6ICAgMHgwMTBmICgyIGJ5dGVzKVxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhIHZhbGlkIGRhdGEgc2l6ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIEFiaVBhcmFtZXRlcnMuZGVjb2RlKFt7IHR5cGU6ICd1aW50MjU2JyB9XSwgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmJylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKchSAzMiBieXRlc1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhU2l6ZVRvb1NtYWxsRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGRhdGEsIHBhcmFtZXRlcnMsIHNpemUsIH0pIHtcbiAgICAgICAgc3VwZXIoYERhdGEgc2l6ZSBvZiAke3NpemV9IGJ5dGVzIGlzIHRvbyBzbWFsbCBmb3IgZ2l2ZW4gcGFyYW1ldGVycy5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICBgUGFyYW1zOiAoJHthYml0eXBlLmZvcm1hdEFiaVBhcmFtZXRlcnMocGFyYW1ldGVycyl9KWAsXG4gICAgICAgICAgICAgICAgYERhdGE6ICAgJHtkYXRhfSAoJHtzaXplfSBieXRlcylgLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkRhdGFTaXplVG9vU21hbGxFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB6ZXJvIGRhdGEgaXMgcHJvdmlkZWQsIGJ1dCBkYXRhIGlzIGV4cGVjdGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIEFiaVBhcmFtZXRlcnMuZGVjb2RlKFt7IHR5cGU6ICd1aW50MjU2JyB9XSwgJzB4JylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinYwgemVybyBkYXRhXG4gKiAvLyBAZXJyb3I6IEFiaVBhcmFtZXRlcnMuRGF0YVNpemVUb29TbWFsbEVycm9yOiBEYXRhIHNpemUgb2YgMiBieXRlcyBpcyB0b28gc21hbGwgZm9yIGdpdmVuIHBhcmFtZXRlcnMuXG4gKiAvLyBAZXJyb3I6IFBhcmFtczogKHVpbnQyNTYpXG4gKiAvLyBAZXJyb3I6IERhdGE6ICAgMHgwMTBmICgyIGJ5dGVzKVxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyB2YWxpZCBkYXRhLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ3VpbnQyNTYnIH1dLCAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMGYnKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4pyFIDMyIGJ5dGVzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFplcm9EYXRhRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0Nhbm5vdCBkZWNvZGUgemVybyBkYXRhIChcIjB4XCIpIHdpdGggQUJJIHBhcmFtZXRlcnMuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLlplcm9EYXRhRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIGxlbmd0aCBzcGVjaWZpZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgQUJJIHBhcmFtZXRlci5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKCd1aW50MjU2WzNdJyksIFtbNjluLCA0MjBuXV0pXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIGV4cGVjdGVkOiAzICDihpEg4p2MIGxlbmd0aDogMlxuICogLy8gQGVycm9yOiBBYmlQYXJhbWV0ZXJzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcjogQUJJIGVuY29kaW5nIGFycmF5IGxlbmd0aCBtaXNtYXRjaFxuICogLy8gQGVycm9yOiBmb3IgdHlwZSBgdWludDI1NlszXWAuIEV4cGVjdGVkOiBgM2AuIEdpdmVuOiBgMmAuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIGFuIGFycmF5IG9mIHRoZSBjb3JyZWN0IGxlbmd0aC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oWyd1aW50MjU2WzNdJ10pLCBbWzY5biwgNDIwbiwgNjluXV0pXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinIUgbGVuZ3RoOiAzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZXhwZWN0ZWRMZW5ndGgsIGdpdmVuTGVuZ3RoLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBBcnJheSBsZW5ndGggbWlzbWF0Y2ggZm9yIHR5cGUgXFxgJHt0eXBlfVxcYC4gRXhwZWN0ZWQ6IFxcYCR7ZXhwZWN0ZWRMZW5ndGh9XFxgLiBHaXZlbjogXFxgJHtnaXZlbkxlbmd0aH1cXGAuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgc2l6ZSBvZiB0aGUgYnl0ZXMgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIHNpemUgc3BlY2lmaWVkIGluIHRoZSBjb3JyZXNwb25kaW5nIEFCSSBwYXJhbWV0ZXIuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbSgnYnl0ZXM4JyksIFtbJzB4ZGVhZGJlZWZkZWFkYmVlZmRlYWRiZWVmJ11dKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSBleHBlY3RlZDogOCBieXRlcyAg4oaRIOKdjCBzaXplOiAxMiBieXRlc1xuICogLy8gQGVycm9yOiBCeXRlc1NpemVNaXNtYXRjaEVycm9yOiBTaXplIG9mIGJ5dGVzIFwiMHhkZWFkYmVlZmRlYWRiZWVmZGVhZGJlZWZcIlxuICogLy8gQGVycm9yOiAoYnl0ZXMxMikgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgc2l6ZSAoYnl0ZXM4KS5cbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgYSBieXRlcyB2YWx1ZSBvZiB0aGUgY29ycmVjdCBzaXplLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbShbJ2J5dGVzOCddKSwgWycweGRlYWRiZWVmZGVhZGJlZWYnXSlcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinIUgc2l6ZTogOCBieXRlc1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBCeXRlc1NpemVNaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZFNpemUsIHZhbHVlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIG9mIGJ5dGVzIFwiJHt2YWx1ZX1cIiAoYnl0ZXMke0hleC5zaXplKHZhbHVlKX0pIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHNpemUgKGJ5dGVzJHtleHBlY3RlZFNpemV9KS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgbGVuZ3RoIG9mIHRoZSB2YWx1ZXMgdG8gZW5jb2RlIGRvZXMgbm90IG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIEFCSSBwYXJhbWV0ZXJzLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oWydzdHJpbmcnLCAndWludDI1NiddKSwgWydoZWxsbyddKVxuICogLy8gQGVycm9yOiBMZW5ndGhNaXNtYXRjaEVycm9yOiBBQkkgZW5jb2RpbmcgcGFyYW1zL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2guXG4gKiAvLyBAZXJyb3I6IEV4cGVjdGVkIGxlbmd0aCAocGFyYW1zKTogMlxuICogLy8gQGVycm9yOiBHaXZlbiBsZW5ndGggKHZhbHVlcyk6IDFcbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIHZhbHVlcyB0byBlbmNvZGUuXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhIFt2YWxpZCBBQkkgdHlwZV0oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vZGV2ZWxvcC9hYmktc3BlYy5odG1sI3R5cGVzKS5cbiAqL1xuZXhwb3J0IGNsYXNzIExlbmd0aE1pc21hdGNoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkTGVuZ3RoLCBnaXZlbkxlbmd0aCwgfSkge1xuICAgICAgICBzdXBlcihbXG4gICAgICAgICAgICAnQUJJIGVuY29kaW5nIHBhcmFtZXRlcnMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaC4nLFxuICAgICAgICAgICAgYEV4cGVjdGVkIGxlbmd0aCAocGFyYW1ldGVycyk6ICR7ZXhwZWN0ZWRMZW5ndGh9YCxcbiAgICAgICAgICAgIGBHaXZlbiBsZW5ndGggKHZhbHVlcyk6ICR7Z2l2ZW5MZW5ndGh9YCxcbiAgICAgICAgXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkxlbmd0aE1pc21hdGNoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHZhbHVlIHByb3ZpZGVkIGlzIG5vdCBhIHZhbGlkIGFycmF5IGFzIHNwZWNpZmllZCBpbiB0aGUgY29ycmVzcG9uZGluZyBBQkkgcGFyYW1ldGVyLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oWyd1aW50MjU2WzNdJ10pLCBbNjldKVxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhbiBhcnJheSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRBcnJheUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIG5vdCBhIHZhbGlkIGFycmF5LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5JbnZhbGlkQXJyYXlFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB0aGUgQUJJIHBhcmFtZXRlciB0eXBlIGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ2xvbCcgfV0sICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZicpXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKdjCBpbnZhbGlkIHR5cGVcbiAqIC8vIEBlcnJvcjogQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yOiBUeXBlIGBsb2xgIGlzIG5vdCBhIHZhbGlkIEFCSSBUeXBlLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVHlwZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBzdXBlcihgVHlwZSBcXGAke3R5cGV9XFxgIGlzIG5vdCBhIHZhbGlkIEFCSSBUeXBlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlQYXJhbWV0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJhYml0eXBlIiwiQWRkcmVzcyIsIkJ5dGVzIiwiRXJyb3JzIiwiSGV4IiwiaW50ZXJuYWwiLCJDdXJzb3IiLCJTb2xpZGl0eSIsImRlY29kZSIsInBhcmFtZXRlcnMiLCJkYXRhIiwib3B0aW9ucyIsImFzIiwiY2hlY2tzdW1BZGRyZXNzIiwiYnl0ZXMiLCJmcm9tSGV4IiwiY3Vyc29yIiwiY3JlYXRlIiwic2l6ZSIsImxlbmd0aCIsIlplcm9EYXRhRXJyb3IiLCJEYXRhU2l6ZVRvb1NtYWxsRXJyb3IiLCJmcm9tQnl0ZXMiLCJjb25zdW1lZCIsInZhbHVlcyIsImkiLCJwYXJhbSIsInNldFBvc2l0aW9uIiwiY29uc3VtZWRfIiwiZGVjb2RlUGFyYW1ldGVyIiwic3RhdGljUG9zaXRpb24iLCJwdXNoIiwibmFtZSIsImVuY29kZSIsIkxlbmd0aE1pc21hdGNoRXJyb3IiLCJleHBlY3RlZExlbmd0aCIsImdpdmVuTGVuZ3RoIiwicHJlcGFyZWRQYXJhbWV0ZXJzIiwicHJlcGFyZVBhcmFtZXRlcnMiLCJlbmNvZGVQYWNrZWQiLCJ0eXBlcyIsInR5cGUiLCJ2YWx1ZSIsImNvbmNhdCIsImlzQXJyYXkiLCJhZGRyZXNzIiwiYXNzZXJ0IiwicGFkTGVmdCIsInRvTG93ZXJDYXNlIiwiZnJvbVN0cmluZyIsImZyb21Cb29sZWFuIiwiaW50TWF0Y2giLCJtYXRjaCIsImludGVnZXJSZWdleCIsIl90eXBlIiwiYmFzZVR5cGUiLCJiaXRzIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJmcm9tTnVtYmVyIiwic2lnbmVkIiwiYnl0ZXNNYXRjaCIsImJ5dGVzUmVnZXgiLCJCeXRlc1NpemVNaXNtYXRjaEVycm9yIiwiZXhwZWN0ZWRTaXplIiwicGFkUmlnaHQiLCJhcnJheU1hdGNoIiwiYXJyYXlSZWdleCIsIkFycmF5IiwiY2hpbGRUeXBlIiwiSW52YWxpZFR5cGVFcnJvciIsImZvcm1hdCIsImZvcm1hdEFiaVBhcmFtZXRlcnMiLCJmcm9tIiwicGFyc2VBYmlQYXJhbWV0ZXJzIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJtZXRhTWVzc2FnZXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvciIsImpvaW4iLCJJbnZhbGlkQXJyYXlFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Address.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/Address.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidAddressError: () => (/* binding */ InvalidAddressError),\n/* harmony export */   InvalidChecksumError: () => (/* binding */ InvalidChecksumError),\n/* harmony export */   InvalidInputError: () => (/* binding */ InvalidInputError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromPublicKey: () => (/* binding */ fromPublicKey),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Caches_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Caches.js */ \"(ssr)/./node_modules/ox/_esm/core/Caches.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/./node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */ function assert(value, options = {}) {\n    const { strict = true } = options;\n    if (!addressRegex.test(value)) throw new InvalidAddressError({\n        address: value,\n        cause: new InvalidInputError()\n    });\n    if (strict) {\n        if (value.toLowerCase() === value) return;\n        if (checksum(value) !== value) throw new InvalidAddressError({\n            address: value,\n            cause: new InvalidChecksumError()\n        });\n    }\n}\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */ function checksum(address) {\n    if (_Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.has(address)) return _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.get(address);\n    assert(address, {\n        strict: false\n    });\n    const hexAddress = address.substring(2).toLowerCase();\n    const hash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromString(hexAddress), {\n        as: \"Bytes\"\n    });\n    const characters = hexAddress.split(\"\");\n    for(let i = 0; i < 40; i += 2){\n        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n            characters[i] = characters[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n            characters[i + 1] = characters[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${characters.join(\"\")}`;\n    _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.set(address, result);\n    return result;\n}\n/**\n * Converts a stringified address to a typed (optionally checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: true\n * })\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */ function from(address, options = {}) {\n    const { checksum: checksumVal = false } = options;\n    assert(address);\n    if (checksumVal) return checksum(address);\n    return address;\n}\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */ function fromPublicKey(publicKey, options = {}) {\n    const address = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(`0x${_PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.toHex(publicKey).slice(4)}`).substring(26);\n    return from(`0x${address}`, options);\n}\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */ function isEqual(addressA, addressB) {\n    assert(addressA, {\n        strict: false\n    });\n    assert(addressB, {\n        strict: false\n    });\n    return addressA.toLowerCase() === addressB.toLowerCase();\n}\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */ function validate(address, options = {}) {\n    const { strict = true } = options ?? {};\n    try {\n        assert(address, {\n            strict\n        });\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */ class InvalidAddressError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ address, cause }){\n        super(`Address \"${address}\" is invalid.`, {\n            cause\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Address.InvalidAddressError\"\n        });\n    }\n}\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */ class InvalidInputError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(){\n        super(\"Address is not a 20 byte (40 hexadecimal character) value.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Address.InvalidInputError\"\n        });\n    }\n}\n/** Thrown when an address does not match its checksum counterpart. */ class InvalidChecksumError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(){\n        super(\"Address does not match its checksum counterpart.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Address.InvalidChecksumError\"\n        });\n    }\n} //# sourceMappingURL=Address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNBO0FBQ0o7QUFDVTtBQUM1QyxNQUFNSyxlQUFlO0FBQ3JCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUNNLFNBQVNDLE9BQU9DLEtBQUssRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDdEMsTUFBTSxFQUFFQyxTQUFTLElBQUksRUFBRSxHQUFHRDtJQUMxQixJQUFJLENBQUNILGFBQWFLLElBQUksQ0FBQ0gsUUFDbkIsTUFBTSxJQUFJSSxvQkFBb0I7UUFDMUJDLFNBQVNMO1FBQ1RNLE9BQU8sSUFBSUM7SUFDZjtJQUNKLElBQUlMLFFBQVE7UUFDUixJQUFJRixNQUFNUSxXQUFXLE9BQU9SLE9BQ3hCO1FBQ0osSUFBSVMsU0FBU1QsV0FBV0EsT0FDcEIsTUFBTSxJQUFJSSxvQkFBb0I7WUFDMUJDLFNBQVNMO1lBQ1RNLE9BQU8sSUFBSUk7UUFDZjtJQUNSO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sU0FBU0QsU0FBU0osT0FBTztJQUM1QixJQUFJWCxnREFBZSxDQUFDaUIsR0FBRyxDQUFDTixVQUNwQixPQUFPWCxnREFBZSxDQUFDa0IsR0FBRyxDQUFDUDtJQUMvQk4sT0FBT00sU0FBUztRQUFFSCxRQUFRO0lBQU07SUFDaEMsTUFBTVcsYUFBYVIsUUFBUVMsU0FBUyxDQUFDLEdBQUdOLFdBQVc7SUFDbkQsTUFBTU8sT0FBT25CLCtDQUFjLENBQUNILGlEQUFnQixDQUFDb0IsYUFBYTtRQUFFSyxJQUFJO0lBQVE7SUFDeEUsTUFBTUMsYUFBYU4sV0FBV08sS0FBSyxDQUFDO0lBQ3BDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLEtBQUssRUFBRztRQUM1QixJQUFJTixJQUFJLENBQUNNLEtBQUssRUFBRSxJQUFJLEtBQUssS0FBS0YsVUFBVSxDQUFDRSxFQUFFLEVBQUU7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Li9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FkZHJlc3MuanM/NDQ2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIENhY2hlcyBmcm9tICcuL0NhY2hlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgUHVibGljS2V5IGZyb20gJy4vUHVibGljS2V5LmpzJztcbmNvbnN0IGFkZHJlc3NSZWdleCA9IC9eMHhbYS1mQS1GMC05XXs0MH0kLztcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuYXNzZXJ0KCcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5hc3NlcnQoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkQWRkcmVzc0Vycm9yOiBBZGRyZXNzIFwiMHhkZWFkYmVlZlwiIGlzIGludmFsaWQuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBhc3NlcnQgaWYgaXQgaXMgYSB2YWxpZCBhZGRyZXNzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBc3NlcnRpb24gb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGlmICghYWRkcmVzc1JlZ2V4LnRlc3QodmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7XG4gICAgICAgICAgICBhZGRyZXNzOiB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZElucHV0RXJyb3IoKSxcbiAgICAgICAgfSk7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjaGVja3N1bSh2YWx1ZSkgIT09IHZhbHVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZENoZWNrc3VtRXJyb3IoKSxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNoZWNrc3VtIGFkZHJlc3MgZm9yIHRoZSBnaXZlbiB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmNoZWNrc3VtKCcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnKVxuICogLy8gQGxvZzogJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gY29tcHV0ZSB0aGUgY2hlY2tzdW0gZm9yLlxuICogQHJldHVybnMgVGhlIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja3N1bShhZGRyZXNzKSB7XG4gICAgaWYgKENhY2hlcy5jaGVja3N1bS5oYXMoYWRkcmVzcykpXG4gICAgICAgIHJldHVybiBDYWNoZXMuY2hlY2tzdW0uZ2V0KGFkZHJlc3MpO1xuICAgIGFzc2VydChhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgY29uc3QgaGV4QWRkcmVzcyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGFzaCA9IEhhc2gua2VjY2FrMjU2KEJ5dGVzLmZyb21TdHJpbmcoaGV4QWRkcmVzcyksIHsgYXM6ICdCeXRlcycgfSk7XG4gICAgY29uc3QgY2hhcmFjdGVycyA9IGhleEFkZHJlc3Muc3BsaXQoJycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoaGFzaFtpID4+IDFdID4+IDQgPj0gOCAmJiBjaGFyYWN0ZXJzW2ldKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXJzW2ldID0gY2hhcmFjdGVyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGFzaFtpID4+IDFdICYgMHgwZikgPj0gOCAmJiBjaGFyYWN0ZXJzW2kgKyAxXSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyc1tpICsgMV0gPSBjaGFyYWN0ZXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGAweCR7Y2hhcmFjdGVycy5qb2luKCcnKX1gO1xuICAgIENhY2hlcy5jaGVja3N1bS5zZXQoYWRkcmVzcywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZ2lmaWVkIGFkZHJlc3MgdG8gYSB0eXBlZCAob3B0aW9uYWxseSBjaGVja3N1bW1lZCkge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5mcm9tKCcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnKVxuICogLy8gQGxvZzogJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuZnJvbSgnMHhhMGNmNzk4ODE2ZDRiOWI5ODY2YjUzMzBlZWE0NmExODM4MmYyNTFlJywge1xuICogICBjaGVja3N1bTogdHJ1ZVxuICogfSlcbiAqIC8vIEBsb2c6ICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmZyb20oJ2hlbGxvJylcbiAqIC8vIEBlcnJvcjogSW52YWxpZEFkZHJlc3NFcnJvcjogQWRkcmVzcyBcIjB4YVwiIGlzIGludmFsaWQuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyAtIEFuIGFkZHJlc3Mgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSB0eXBlZCBBZGRyZXNzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBDb252ZXJzaW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgdHlwZWQgQWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGVja3N1bTogY2hlY2tzdW1WYWwgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBhc3NlcnQoYWRkcmVzcyk7XG4gICAgaWYgKGNoZWNrc3VtVmFsKVxuICAgICAgICByZXR1cm4gY2hlY2tzdW0oYWRkcmVzcyk7XG4gICAgcmV0dXJuIGFkZHJlc3M7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIEVDRFNBIHB1YmxpYyBrZXkgdG8gYW4ge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzLCBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbShcbiAqICAgJzB4MDQ4MzE4NTM1YjU0MTA1ZDRhN2FhZTYwYzA4ZmM0NWY5Njg3MTgxYjRmZGZjNjI1YmQxYTc1M2ZhNzM5N2ZlZDc1MzU0N2YxMWNhODY5NjY0NmYyZjNhY2IwOGUzMTAxNmFmYWMyM2U2MzBjNWQxMWY1OWY2MWZlZjU3YjBkMmFhNScsXG4gKiApXG4gKiBjb25zdCBhZGRyZXNzID0gQWRkcmVzcy5mcm9tUHVibGljS2V5KHB1YmxpY0tleSlcbiAqIC8vIEBsb2c6ICcweGYzOWZkNmU1MWFhZDg4ZjZmNGNlNmFiODgyNzI3OWNmZmZiOTIyNjYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIEVDRFNBIHB1YmxpYyBrZXkgdG8gY29udmVydCB0byBhbiB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQ29udmVyc2lvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUHVibGljS2V5KHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IEhhc2gua2VjY2FrMjU2KGAweCR7UHVibGljS2V5LnRvSGV4KHB1YmxpY0tleSkuc2xpY2UoNCl9YCkuc3Vic3RyaW5nKDI2KTtcbiAgICByZXR1cm4gZnJvbShgMHgke2FkZHJlc3N9YCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0d28ge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30gYXJlIGVxdWFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuaXNFcXVhbChcbiAqICAgJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZScsXG4gKiAgICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnXG4gKiApXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmlzRXF1YWwoXG4gKiAgICcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnLFxuICogICAnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFmJ1xuICogKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzQSAtIFRoZSBmaXJzdCBhZGRyZXNzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYWRkcmVzc0IgLSBUaGUgc2Vjb25kIGFkZHJlc3MgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGFkZHJlc3NlcyBhcmUgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsKGFkZHJlc3NBLCBhZGRyZXNzQikge1xuICAgIGFzc2VydChhZGRyZXNzQSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGFzc2VydChhZGRyZXNzQiwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIHJldHVybiBhZGRyZXNzQS50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzQi50b0xvd2VyQ2FzZSgpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFkZHJlc3MgaXMgYSB2YWxpZCB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLnZhbGlkYXRlKCcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy52YWxpZGF0ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFkZHJlc3MgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIENoZWNrIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gdHJ1ZSB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoYWRkcmVzcywgeyBzdHJpY3QgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGFuIGFkZHJlc3MgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmZyb20oJzB4MTIzJylcbiAqIC8vIEBlcnJvcjogQWRkcmVzcy5JbnZhbGlkQWRkcmVzc0Vycm9yOiBBZGRyZXNzIGAweDEyM2AgaXMgaW52YWxpZC5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEFkZHJlc3NFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgYWRkcmVzcywgY2F1c2UgfSkge1xuICAgICAgICBzdXBlcihgQWRkcmVzcyBcIiR7YWRkcmVzc31cIiBpcyBpbnZhbGlkLmAsIHtcbiAgICAgICAgICAgIGNhdXNlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FkZHJlc3MuSW52YWxpZEFkZHJlc3NFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIGFuIGFkZHJlc3MgaXMgbm90IGEgMjAgYnl0ZSAoNDAgaGV4YWRlY2ltYWwgY2hhcmFjdGVyKSB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSW5wdXRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQWRkcmVzcyBpcyBub3QgYSAyMCBieXRlICg0MCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIpIHZhbHVlLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWRkcmVzcy5JbnZhbGlkSW5wdXRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIGFuIGFkZHJlc3MgZG9lcyBub3QgbWF0Y2ggaXRzIGNoZWNrc3VtIGNvdW50ZXJwYXJ0LiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRDaGVja3N1bUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBZGRyZXNzIGRvZXMgbm90IG1hdGNoIGl0cyBjaGVja3N1bSBjb3VudGVycGFydC4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FkZHJlc3MuSW52YWxpZENoZWNrc3VtRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbIkJ5dGVzIiwiQ2FjaGVzIiwiRXJyb3JzIiwiSGFzaCIsIlB1YmxpY0tleSIsImFkZHJlc3NSZWdleCIsImFzc2VydCIsInZhbHVlIiwib3B0aW9ucyIsInN0cmljdCIsInRlc3QiLCJJbnZhbGlkQWRkcmVzc0Vycm9yIiwiYWRkcmVzcyIsImNhdXNlIiwiSW52YWxpZElucHV0RXJyb3IiLCJ0b0xvd2VyQ2FzZSIsImNoZWNrc3VtIiwiSW52YWxpZENoZWNrc3VtRXJyb3IiLCJoYXMiLCJnZXQiLCJoZXhBZGRyZXNzIiwic3Vic3RyaW5nIiwiaGFzaCIsImtlY2NhazI1NiIsImZyb21TdHJpbmciLCJhcyIsImNoYXJhY3RlcnMiLCJzcGxpdCIsImkiLCJ0b1VwcGVyQ2FzZSIsInJlc3VsdCIsImpvaW4iLCJzZXQiLCJmcm9tIiwiY2hlY2tzdW1WYWwiLCJmcm9tUHVibGljS2V5IiwicHVibGljS2V5IiwidG9IZXgiLCJzbGljZSIsImlzRXF1YWwiLCJhZGRyZXNzQSIsImFkZHJlc3NCIiwidmFsaWRhdGUiLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Authorization.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/Authorization.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcList: () => (/* binding */ fromRpcList),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcList: () => (/* binding */ toRpcList),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"(ssr)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */ function from(authorization, options = {}) {\n    if (typeof authorization.chainId === \"string\") return fromRpc(authorization);\n    return {\n        ...authorization,\n        ...options.signature\n    };\n}\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */ function fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature\n    };\n}\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */ function fromRpcList(authorizationList) {\n    return authorizationList.map(fromRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */ function fromTuple(tuple) {\n    const [chainId, address, nonce, yParity, r, s] = tuple;\n    let args = {\n        address,\n        chainId: chainId === \"0x\" ? 0 : Number(chainId),\n        nonce: nonce === \"0x\" ? 0n : BigInt(nonce)\n    };\n    if (yParity && r && s) args = {\n        ...args,\n        ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromTuple([\n            yParity,\n            r,\n            s\n        ])\n    };\n    return from(args);\n}\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */ function fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */ function getSignPayload(authorization) {\n    return hash(authorization, {\n        presign: true\n    });\n}\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */ function hash(authorization, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(\"0x05\", _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toTuple(presign ? {\n        address: authorization.address,\n        chainId: authorization.chainId,\n        nonce: authorization.nonce\n    } : authorization))));\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */ function toRpc(authorization) {\n    const { address, chainId, nonce, ...signature } = authorization;\n    return {\n        address,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId),\n        nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce),\n        ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature)\n    };\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */ function toRpcList(authorizationList) {\n    return authorizationList.map(toRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */ function toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return [\n        chainId ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId) : \"0x\",\n        address,\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce) : \"0x\",\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.toTuple(signature) : []\n    ];\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */ function toTupleList(list) {\n    if (!list || list.length === 0) return [];\n    const tupleList = [];\n    for (const authorization of list)tupleList.push(toTuple(authorization));\n    return tupleList;\n} //# sourceMappingURL=Authorization.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0F1dGhvcml6YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ0Y7QUFDQTtBQUNZO0FBQzVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EwQ0MsR0FDTSxTQUFTSSxLQUFLQyxhQUFhLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQzVDLElBQUksT0FBT0QsY0FBY0UsT0FBTyxLQUFLLFVBQ2pDLE9BQU9DLFFBQVFIO0lBQ25CLE9BQU87UUFBRSxHQUFHQSxhQUFhO1FBQUUsR0FBR0MsUUFBUUcsU0FBUztJQUFDO0FBQ3BEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTRCxRQUFRSCxhQUFhO0lBQ2pDLE1BQU0sRUFBRUssT0FBTyxFQUFFSCxPQUFPLEVBQUVJLEtBQUssRUFBRSxHQUFHTjtJQUNwQyxNQUFNSSxZQUFZTixrREFBaUIsQ0FBQ0U7SUFDcEMsT0FBTztRQUNISztRQUNBSCxTQUFTTSxPQUFPTjtRQUNoQkksT0FBT0csT0FBT0g7UUFDZCxHQUFHRixTQUFTO0lBQ2hCO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVNNLFlBQVlDLGlCQUFpQjtJQUN6QyxPQUFPQSxrQkFBa0JDLEdBQUcsQ0FBQ1Q7QUFDakM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkNDLEdBQ00sU0FBU1UsVUFBVUMsS0FBSztJQUMzQixNQUFNLENBQUNaLFNBQVNHLFNBQVNDLE9BQU9TLFNBQVNDLEdBQUdDLEVBQUUsR0FBR0g7SUFDakQsSUFBSUksT0FBTztRQUNQYjtRQUNBSCxTQUFTQSxZQUFZLE9BQU8sSUFBSU0sT0FBT047UUFDdkNJLE9BQU9BLFVBQVUsT0FBTyxFQUFFLEdBQUdHLE9BQU9IO0lBQ3hDO0lBQ0EsSUFBSVMsV0FBV0MsS0FBS0MsR0FDaEJDLE9BQU87UUFBRSxHQUFHQSxJQUFJO1FBQUUsR0FBR3BCLG9EQUFtQixDQUFDO1lBQUNpQjtZQUFTQztZQUFHQztTQUFFLENBQUM7SUFBQztJQUM5RCxPQUFPbEIsS0FBS21CO0FBQ2hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlEQyxHQUNNLFNBQVNDLGNBQWNDLFNBQVM7SUFDbkMsTUFBTUMsT0FBTyxFQUFFO0lBQ2YsS0FBSyxNQUFNUCxTQUFTTSxVQUNoQkMsS0FBS0MsSUFBSSxDQUFDVCxVQUFVQztJQUN4QixPQUFPTztBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMEJDLEdBQ00sU0FBU0UsZUFBZXZCLGFBQWE7SUFDeEMsT0FBT3dCLEtBQUt4QixlQUFlO1FBQUV5QixTQUFTO0lBQUs7QUFDL0M7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ00sU0FBU0QsS0FBS3hCLGFBQWEsRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDNUMsTUFBTSxFQUFFd0IsT0FBTyxFQUFFLEdBQUd4QjtJQUNwQixPQUFPTiwrQ0FBYyxDQUFDQywyQ0FBVSxDQUFDLFFBQVFDLDRDQUFXLENBQUNnQyxRQUFRSixVQUN2RDtRQUNFcEIsU0FBU0wsY0FBY0ssT0FBTztRQUM5QkgsU0FBU0YsY0FBY0UsT0FBTztRQUM5QkksT0FBT04sY0FBY00sS0FBSztJQUM5QixJQUNFTjtBQUNWO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTOEIsTUFBTTlCLGFBQWE7SUFDL0IsTUFBTSxFQUFFSyxPQUFPLEVBQUVILE9BQU8sRUFBRUksS0FBSyxFQUFFLEdBQUdGLFdBQVcsR0FBR0o7SUFDbEQsT0FBTztRQUNISztRQUNBSCxTQUFTTiwrQ0FBYyxDQUFDTTtRQUN4QkksT0FBT1YsK0NBQWMsQ0FBQ1U7UUFDdEIsR0FBR1IsZ0RBQWUsQ0FBQ00sVUFBVTtJQUNqQztBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTNEIsVUFBVXJCLGlCQUFpQjtJQUN2QyxPQUFPQSxrQkFBa0JDLEdBQUcsQ0FBQ2tCO0FBQ2pDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdUJDLEdBQ00sU0FBU0QsUUFBUTdCLGFBQWE7SUFDakMsTUFBTSxFQUFFSyxPQUFPLEVBQUVILE9BQU8sRUFBRUksS0FBSyxFQUFFLEdBQUdOO0lBQ3BDLE1BQU1JLFlBQVlOLGtEQUFpQixDQUFDRTtJQUNwQyxPQUFPO1FBQ0hFLFVBQVVOLCtDQUFjLENBQUNNLFdBQVc7UUFDcENHO1FBQ0FDLFFBQVFWLCtDQUFjLENBQUNVLFNBQVM7V0FDNUJGLFlBQVlOLGtEQUFpQixDQUFDTSxhQUFhLEVBQUU7S0FDcEQ7QUFDTDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1DQyxHQUNNLFNBQVM2QixZQUFZWixJQUFJO0lBQzVCLElBQUksQ0FBQ0EsUUFBUUEsS0FBS2EsTUFBTSxLQUFLLEdBQ3pCLE9BQU8sRUFBRTtJQUNiLE1BQU1kLFlBQVksRUFBRTtJQUNwQixLQUFLLE1BQU1wQixpQkFBaUJxQixLQUN4QkQsVUFBVUUsSUFBSSxDQUFDTyxRQUFRN0I7SUFDM0IsT0FBT29CO0FBQ1gsRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmM0MzM3LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BdXRob3JpemF0aW9uLmpzPzJmYjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiBvYmplY3QgaW50byBhIHR5cGVkIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICpcbiAqIEBleGFtcGxlXG4gKiBBbiBBdXRob3JpemF0aW9uIGNhbiBiZSBpbnN0YW50aWF0ZWQgZnJvbSBhbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZSBpbiBvYmplY3QgZm9ybWF0LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBBIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBjYW4gYmUgYXR0YWNoZWQgd2l0aCB0aGUgYHNpZ25hdHVyZWAgb3B0aW9uLiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgc2lnbmluZ1xuICogYW4gQXV0aG9yaXphdGlvbiB3aXRoIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiwgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IEF1dGhvcml6YXRpb24uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbiksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fc2lnbmVkID0gQXV0aG9yaXphdGlvbi5mcm9tKGF1dGhvcml6YXRpb24sIHsgc2lnbmF0dXJlIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gQW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgaW4gb2JqZWN0IGZvcm1hdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQXV0aG9yaXphdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhdXRob3JpemF0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGF1dGhvcml6YXRpb24uY2hhaW5JZCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBmcm9tUnBjKGF1dGhvcml6YXRpb24pO1xuICAgIHJldHVybiB7IC4uLmF1dGhvcml6YXRpb24sIC4uLm9wdGlvbnMuc2lnbmF0dXJlIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlJwY30gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbVJwYyh7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBjaGFpbklkOiAnMHgxJyxcbiAqICAgbm9uY2U6ICcweDEnLFxuICogICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgIHlQYXJpdHk6ICcweDAnLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbi5cbiAqIEByZXR1cm5zIEEgc2lnbmVkIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdChhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBCaWdJbnQobm9uY2UpLFxuICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdFJwY30gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLmZyb21ScGNMaXN0KFt7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBjaGFpbklkOiAnMHgxJyxcbiAqICAgbm9uY2U6ICcweDEnLFxuICogICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgIHlQYXJpdHk6ICcweDAnLFxuICogfV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbkxpc3QgLSBUaGUgUlBDLWZvcm1hdHRlZCBBdXRob3JpemF0aW9uIGxpc3QuXG4gKiBAcmV0dXJucyBBIHNpZ25lZCB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGNMaXN0KGF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb25MaXN0Lm1hcChmcm9tUnBjKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uVHVwbGV9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZShbXG4gKiAgICcweDEnLFxuICogICAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgJzB4MydcbiAqIF0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBub25jZTogM25cbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFwcGVuZCBhIFNpZ25hdHVyZSB0dXBsZSB0byB0aGUgZW5kIG9mIGFuIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tVHVwbGUoW1xuICogICAnMHgxJyxcbiAqICAgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgICcweDMnLFxuICogICAnMHgxJyxcbiAqICAgJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcsXG4gKiAgICcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnLFxuICogXSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiAzblxuICogLy8gQGxvZzogICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICBzOiBCaWdJbnQoJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcpLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHR1cGxlIC0gVGhlIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlKHR1cGxlKSB7XG4gICAgY29uc3QgW2NoYWluSWQsIGFkZHJlc3MsIG5vbmNlLCB5UGFyaXR5LCByLCBzXSA9IHR1cGxlO1xuICAgIGxldCBhcmdzID0ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBjaGFpbklkID09PSAnMHgnID8gMCA6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IG5vbmNlID09PSAnMHgnID8gMG4gOiBCaWdJbnQobm9uY2UpLFxuICAgIH07XG4gICAgaWYgKHlQYXJpdHkgJiYgciAmJiBzKVxuICAgICAgICBhcmdzID0geyAuLi5hcmdzLCAuLi5TaWduYXR1cmUuZnJvbVR1cGxlKFt5UGFyaXR5LCByLCBzXSkgfTtcbiAgICByZXR1cm4gZnJvbShhcmdzKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uVHVwbGVMaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlTGlzdChbXG4gKiAgIFsnMHgxJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDMnXSxcbiAqICAgWycweDMnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MTQnXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAzbixcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDMsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDIwbixcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFwcGVuZCBhIFNpZ25hdHVyZSB0dXBsZSB0byB0aGUgZW5kIG9mIGFuIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlTGlzdChbXG4gKiAgIFsnMHgxJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDMnLCAnMHgxJywgJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcsICcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnXSxcbiAqICAgWycweDMnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MTQnLCAnMHgxJywgJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcsICcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAzbixcbiAqIC8vIEBsb2c6ICAgICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDMsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDIwbixcbiAqIC8vIEBsb2c6ICAgICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0dXBsZUxpc3QgLSBUaGUgW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgbGlzdC5cbiAqIEByZXR1cm5zIEFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlTGlzdCh0dXBsZUxpc3QpIHtcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChjb25zdCB0dXBsZSBvZiB0dXBsZUxpc3QpXG4gICAgICAgIGxpc3QucHVzaChmcm9tVHVwbGUodHVwbGUpKTtcbiAgICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNpZ24gcGF5bG9hZCBmb3IgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0gaW4gW0VJUC03NzAyIGZvcm1hdF0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKTogYGtlY2NhazI1NignMHgwNScgfHwgcmxwKFtjaGFpbl9pZCwgYWRkcmVzcywgbm9uY2VdKSlgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgY29tcHV0aW5nIHRoZSBzaWduIHBheWxvYWQgZm9yIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LiBUaGlzIHBheWxvYWRcbiAqIGNhbiB0aGVuIGJlIHBhc3NlZCB0byBzaWduaW5nIGZ1bmN0aW9ucyBsaWtlIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiwgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgVGhlIHNpZ24gcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pIHtcbiAgICByZXR1cm4gaGFzaChhdXRob3JpemF0aW9uLCB7IHByZXNpZ246IHRydWUgfSk7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBoYXNoIGZvciBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufSBpbiBbRUlQLTc3MDIgZm9ybWF0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpOiBga2VjY2FrMjU2KCcweDA1JyB8fCBybHAoW2NoYWluX2lkLCBhZGRyZXNzLCBub25jZV0pKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gQXV0aG9yaXphdGlvbi5oYXNoKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgVGhlIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGF1dGhvcml6YXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoSGV4LmNvbmNhdCgnMHgwNScsIFJscC5mcm9tSGV4KHRvVHVwbGUocHJlc2lnblxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGF1dGhvcml6YXRpb24uYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IGF1dGhvcml6YXRpb24uY2hhaW5JZCxcbiAgICAgICAgICAgIG5vbmNlOiBhdXRob3JpemF0aW9uLm5vbmNlLFxuICAgICAgICB9XG4gICAgICAgIDogYXV0aG9yaXphdGlvbikpKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24udG9ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDFuLFxuICogICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgeVBhcml0eTogMCxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIEFuIEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSwgLi4uc2lnbmF0dXJlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IEhleC5mcm9tTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZTogSGV4LmZyb21OdW1iZXIobm9uY2UpLFxuICAgICAgICAuLi5TaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0UnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi50b1JwY0xpc3QoW3tcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAxbixcbiAqICAgcjogNDQ5NDQ2Mjc4MTMwMDc3NzI4OTczOTE1MzEyMzAwODE2OTUxMDI3MDMyODkxMjMzMzIxODc2OTYxMTUxODExMDQ3MzkyMzkxOTc1MTduLFxuICogICBzOiAzNjUyODUwMzUwNTE5MjQzODMwNzM1NTE2NDQ0MTEwNDAwMTMxMDU2NjUwNTM1MTk4MDM2OTA4NTIwODE3ODcxMjY3ODc5OTE4MTEyMG4sXG4gKiAgIHlQYXJpdHk6IDAsXG4gKiB9XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uTGlzdCAtIEFuIEF1dGhvcml6YXRpb24gTGlzdC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbiBMaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGNMaXN0KGF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb25MaXN0Lm1hcCh0b1JwYyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvbi50b1R1cGxlKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIEFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZShhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdChhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjaGFpbklkID8gSGV4LmZyb21OdW1iZXIoY2hhaW5JZCkgOiAnMHgnLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBub25jZSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlKSA6ICcweCcsXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9UdXBsZShzaWduYXR1cmUpIDogW10pLFxuICAgIF07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl8xID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICogY29uc3QgYXV0aG9yaXphdGlvbl8yID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDMsXG4gKiAgIG5vbmNlOiAyMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvbi50b1R1cGxlTGlzdChbYXV0aG9yaXphdGlvbl8xLCBhdXRob3JpemF0aW9uXzJdKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGlzdCAtIEFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICogQHJldHVybnMgQW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgbGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGVMaXN0KGxpc3QpIHtcbiAgICBpZiAoIWxpc3QgfHwgbGlzdC5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB0dXBsZUxpc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF1dGhvcml6YXRpb24gb2YgbGlzdClcbiAgICAgICAgdHVwbGVMaXN0LnB1c2godG9UdXBsZShhdXRob3JpemF0aW9uKSk7XG4gICAgcmV0dXJuIHR1cGxlTGlzdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhvcml6YXRpb24uanMubWFwIl0sIm5hbWVzIjpbIkhhc2giLCJIZXgiLCJSbHAiLCJTaWduYXR1cmUiLCJmcm9tIiwiYXV0aG9yaXphdGlvbiIsIm9wdGlvbnMiLCJjaGFpbklkIiwiZnJvbVJwYyIsInNpZ25hdHVyZSIsImFkZHJlc3MiLCJub25jZSIsImV4dHJhY3QiLCJOdW1iZXIiLCJCaWdJbnQiLCJmcm9tUnBjTGlzdCIsImF1dGhvcml6YXRpb25MaXN0IiwibWFwIiwiZnJvbVR1cGxlIiwidHVwbGUiLCJ5UGFyaXR5IiwiciIsInMiLCJhcmdzIiwiZnJvbVR1cGxlTGlzdCIsInR1cGxlTGlzdCIsImxpc3QiLCJwdXNoIiwiZ2V0U2lnblBheWxvYWQiLCJoYXNoIiwicHJlc2lnbiIsImtlY2NhazI1NiIsImNvbmNhdCIsImZyb21IZXgiLCJ0b1R1cGxlIiwidG9ScGMiLCJmcm9tTnVtYmVyIiwidG9ScGNMaXN0IiwidG9UdXBsZUxpc3QiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Authorization.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/BlockOverrides.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/BlockOverrides.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Withdrawal.js */ \"(ssr)/./node_modules/ox/_esm/core/Withdrawal.js\");\n\n\n/**\n * Converts an {@link ox#BlockOverrides.Rpc} to an {@link ox#BlockOverrides.BlockOverrides}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.fromRpc({\n *   baseFeePerGas: '0x1',\n *   blobBaseFee: '0x2',\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: '0x4',\n *   number: '0x5',\n *   prevRandao: '0x6',\n *   time: '0x1234567890',\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: '0x1',\n *       index: '0x0',\n *       validatorIndex: '0x1',\n *     },\n *   ],\n * })\n * ```\n *\n * @param rpcBlockOverrides - The RPC block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.BlockOverrides}.\n */ function fromRpc(rpcBlockOverrides) {\n    return {\n        ...rpcBlockOverrides.baseFeePerGas && {\n            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas)\n        },\n        ...rpcBlockOverrides.blobBaseFee && {\n            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee)\n        },\n        ...rpcBlockOverrides.feeRecipient && {\n            feeRecipient: rpcBlockOverrides.feeRecipient\n        },\n        ...rpcBlockOverrides.gasLimit && {\n            gasLimit: BigInt(rpcBlockOverrides.gasLimit)\n        },\n        ...rpcBlockOverrides.number && {\n            number: BigInt(rpcBlockOverrides.number)\n        },\n        ...rpcBlockOverrides.prevRandao && {\n            prevRandao: BigInt(rpcBlockOverrides.prevRandao)\n        },\n        ...rpcBlockOverrides.time && {\n            time: BigInt(rpcBlockOverrides.time)\n        },\n        ...rpcBlockOverrides.withdrawals && {\n            withdrawals: rpcBlockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc)\n        }\n    };\n}\n/**\n * Converts an {@link ox#BlockOverrides.BlockOverrides} to an {@link ox#BlockOverrides.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.toRpc({\n *   baseFeePerGas: 1n,\n *   blobBaseFee: 2n,\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: 4n,\n *   number: 5n,\n *   prevRandao: 6n,\n *   time: 78187493520n,\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: 1n,\n *       index: 0,\n *       validatorIndex: 1,\n *     },\n *   ],\n * })\n * ```\n *\n * @param blockOverrides - The block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.Rpc}.\n */ function toRpc(blockOverrides) {\n    return {\n        ...typeof blockOverrides.baseFeePerGas === \"bigint\" && {\n            baseFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.baseFeePerGas)\n        },\n        ...typeof blockOverrides.blobBaseFee === \"bigint\" && {\n            blobBaseFee: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.blobBaseFee)\n        },\n        ...typeof blockOverrides.feeRecipient === \"string\" && {\n            feeRecipient: blockOverrides.feeRecipient\n        },\n        ...typeof blockOverrides.gasLimit === \"bigint\" && {\n            gasLimit: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.gasLimit)\n        },\n        ...typeof blockOverrides.number === \"bigint\" && {\n            number: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.number)\n        },\n        ...typeof blockOverrides.prevRandao === \"bigint\" && {\n            prevRandao: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.prevRandao)\n        },\n        ...typeof blockOverrides.time === \"bigint\" && {\n            time: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.time)\n        },\n        ...blockOverrides.withdrawals && {\n            withdrawals: blockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.toRpc)\n        }\n    };\n} //# sourceMappingURL=BlockOverrides.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Jsb2NrT3ZlcnJpZGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0M7QUFDYztBQUM5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTRCQyxHQUNNLFNBQVNFLFFBQVFDLGlCQUFpQjtJQUNyQyxPQUFPO1FBQ0gsR0FBSUEsa0JBQWtCQyxhQUFhLElBQUk7WUFDbkNBLGVBQWVDLE9BQU9GLGtCQUFrQkMsYUFBYTtRQUN6RCxDQUFDO1FBQ0QsR0FBSUQsa0JBQWtCRyxXQUFXLElBQUk7WUFDakNBLGFBQWFELE9BQU9GLGtCQUFrQkcsV0FBVztRQUNyRCxDQUFDO1FBQ0QsR0FBSUgsa0JBQWtCSSxZQUFZLElBQUk7WUFDbENBLGNBQWNKLGtCQUFrQkksWUFBWTtRQUNoRCxDQUFDO1FBQ0QsR0FBSUosa0JBQWtCSyxRQUFRLElBQUk7WUFDOUJBLFVBQVVILE9BQU9GLGtCQUFrQkssUUFBUTtRQUMvQyxDQUFDO1FBQ0QsR0FBSUwsa0JBQWtCTSxNQUFNLElBQUk7WUFDNUJBLFFBQVFKLE9BQU9GLGtCQUFrQk0sTUFBTTtRQUMzQyxDQUFDO1FBQ0QsR0FBSU4sa0JBQWtCTyxVQUFVLElBQUk7WUFDaENBLFlBQVlMLE9BQU9GLGtCQUFrQk8sVUFBVTtRQUNuRCxDQUFDO1FBQ0QsR0FBSVAsa0JBQWtCUSxJQUFJLElBQUk7WUFDMUJBLE1BQU1OLE9BQU9GLGtCQUFrQlEsSUFBSTtRQUN2QyxDQUFDO1FBQ0QsR0FBSVIsa0JBQWtCUyxXQUFXLElBQUk7WUFDakNBLGFBQWFULGtCQUFrQlMsV0FBVyxDQUFDQyxHQUFHLENBQUNaLG1EQUFrQjtRQUNyRSxDQUFDO0lBQ0w7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNEJDLEdBQ00sU0FBU2EsTUFBTUMsY0FBYztJQUNoQyxPQUFPO1FBQ0gsR0FBSSxPQUFPQSxlQUFlWCxhQUFhLEtBQUssWUFBWTtZQUNwREEsZUFBZUosK0NBQWMsQ0FBQ2UsZUFBZVgsYUFBYTtRQUM5RCxDQUFDO1FBQ0QsR0FBSSxPQUFPVyxlQUFlVCxXQUFXLEtBQUssWUFBWTtZQUNsREEsYUFBYU4sK0NBQWMsQ0FBQ2UsZUFBZVQsV0FBVztRQUMxRCxDQUFDO1FBQ0QsR0FBSSxPQUFPUyxlQUFlUixZQUFZLEtBQUssWUFBWTtZQUNuREEsY0FBY1EsZUFBZVIsWUFBWTtRQUM3QyxDQUFDO1FBQ0QsR0FBSSxPQUFPUSxlQUFlUCxRQUFRLEtBQUssWUFBWTtZQUMvQ0EsVUFBVVIsK0NBQWMsQ0FBQ2UsZUFBZVAsUUFBUTtRQUNwRCxDQUFDO1FBQ0QsR0FBSSxPQUFPTyxlQUFlTixNQUFNLEtBQUssWUFBWTtZQUM3Q0EsUUFBUVQsK0NBQWMsQ0FBQ2UsZUFBZU4sTUFBTTtRQUNoRCxDQUFDO1FBQ0QsR0FBSSxPQUFPTSxlQUFlTCxVQUFVLEtBQUssWUFBWTtZQUNqREEsWUFBWVYsK0NBQWMsQ0FBQ2UsZUFBZUwsVUFBVTtRQUN4RCxDQUFDO1FBQ0QsR0FBSSxPQUFPSyxlQUFlSixJQUFJLEtBQUssWUFBWTtZQUMzQ0EsTUFBTVgsK0NBQWMsQ0FBQ2UsZUFBZUosSUFBSTtRQUM1QyxDQUFDO1FBQ0QsR0FBSUksZUFBZUgsV0FBVyxJQUFJO1lBQzlCQSxhQUFhRyxlQUFlSCxXQUFXLENBQUNDLEdBQUcsQ0FBQ1osaURBQWdCO1FBQ2hFLENBQUM7SUFDTDtBQUNKLEVBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjNDMzNy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQmxvY2tPdmVycmlkZXMuanM/ZjYxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgV2l0aGRyYXdhbCBmcm9tICcuL1dpdGhkcmF3YWwuanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuUnBjfSB0byBhbiB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuQmxvY2tPdmVycmlkZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxvY2tPdmVycmlkZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBibG9ja092ZXJyaWRlcyA9IEJsb2NrT3ZlcnJpZGVzLmZyb21ScGMoe1xuICogICBiYXNlRmVlUGVyR2FzOiAnMHgxJyxcbiAqICAgYmxvYkJhc2VGZWU6ICcweDInLFxuICogICBmZWVSZWNpcGllbnQ6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBnYXNMaW1pdDogJzB4NCcsXG4gKiAgIG51bWJlcjogJzB4NScsXG4gKiAgIHByZXZSYW5kYW86ICcweDYnLFxuICogICB0aW1lOiAnMHgxMjM0NTY3ODkwJyxcbiAqICAgd2l0aGRyYXdhbHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgICAgIGFtb3VudDogJzB4MScsXG4gKiAgICAgICBpbmRleDogJzB4MCcsXG4gKiAgICAgICB2YWxpZGF0b3JJbmRleDogJzB4MScsXG4gKiAgICAgfSxcbiAqICAgXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcnBjQmxvY2tPdmVycmlkZXMgLSBUaGUgUlBDIGJsb2NrIG92ZXJyaWRlcyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gaW5zdGFudGlhdGVkIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5CbG9ja092ZXJyaWRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKHJwY0Jsb2NrT3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMgJiYge1xuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlICYmIHtcbiAgICAgICAgICAgIGJsb2JCYXNlRmVlOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCAmJiB7XG4gICAgICAgICAgICBmZWVSZWNpcGllbnQ6IHJwY0Jsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5nYXNMaW1pdCAmJiB7XG4gICAgICAgICAgICBnYXNMaW1pdDogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLmdhc0xpbWl0KSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5udW1iZXIgJiYge1xuICAgICAgICAgICAgbnVtYmVyOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMubnVtYmVyKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvICYmIHtcbiAgICAgICAgICAgIHByZXZSYW5kYW86IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy50aW1lICYmIHtcbiAgICAgICAgICAgIHRpbWU6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy50aW1lKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy53aXRoZHJhd2FscyAmJiB7XG4gICAgICAgICAgICB3aXRoZHJhd2FsczogcnBjQmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMubWFwKFdpdGhkcmF3YWwuZnJvbVJwYyksXG4gICAgICAgIH0pLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5CbG9ja092ZXJyaWRlc30gdG8gYW4ge0BsaW5rIG94I0Jsb2NrT3ZlcnJpZGVzLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCbG9ja092ZXJyaWRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2NrT3ZlcnJpZGVzID0gQmxvY2tPdmVycmlkZXMudG9ScGMoe1xuICogICBiYXNlRmVlUGVyR2FzOiAxbixcbiAqICAgYmxvYkJhc2VGZWU6IDJuLFxuICogICBmZWVSZWNpcGllbnQ6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBnYXNMaW1pdDogNG4sXG4gKiAgIG51bWJlcjogNW4sXG4gKiAgIHByZXZSYW5kYW86IDZuLFxuICogICB0aW1lOiA3ODE4NzQ5MzUyMG4sXG4gKiAgIHdpdGhkcmF3YWxzOiBbXG4gKiAgICAge1xuICogICAgICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgICAgICBhbW91bnQ6IDFuLFxuICogICAgICAgaW5kZXg6IDAsXG4gKiAgICAgICB2YWxpZGF0b3JJbmRleDogMSxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBibG9ja092ZXJyaWRlcyAtIFRoZSBibG9jayBvdmVycmlkZXMgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuUnBjfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKGJsb2NrT3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5iYXNlRmVlUGVyR2FzID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5iYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGJsb2JCYXNlRmVlOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCA9PT0gJ3N0cmluZycgJiYge1xuICAgICAgICAgICAgZmVlUmVjaXBpZW50OiBibG9ja092ZXJyaWRlcy5mZWVSZWNpcGllbnQsXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmdhc0xpbWl0ID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBnYXNMaW1pdDogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMuZ2FzTGltaXQpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5udW1iZXIgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIG51bWJlcjogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMubnVtYmVyKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgcHJldlJhbmRhbzogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLnRpbWUgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIHRpbWU6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLnRpbWUpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKGJsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzICYmIHtcbiAgICAgICAgICAgIHdpdGhkcmF3YWxzOiBibG9ja092ZXJyaWRlcy53aXRoZHJhd2Fscy5tYXAoV2l0aGRyYXdhbC50b1JwYyksXG4gICAgICAgIH0pLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbG9ja092ZXJyaWRlcy5qcy5tYXAiXSwibmFtZXMiOlsiSGV4IiwiV2l0aGRyYXdhbCIsImZyb21ScGMiLCJycGNCbG9ja092ZXJyaWRlcyIsImJhc2VGZWVQZXJHYXMiLCJCaWdJbnQiLCJibG9iQmFzZUZlZSIsImZlZVJlY2lwaWVudCIsImdhc0xpbWl0IiwibnVtYmVyIiwicHJldlJhbmRhbyIsInRpbWUiLCJ3aXRoZHJhd2FscyIsIm1hcCIsInRvUnBjIiwiYmxvY2tPdmVycmlkZXMiLCJmcm9tTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/BlockOverrides.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Bytes.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_esm/core/Bytes.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidBytesBooleanError: () => (/* binding */ InvalidBytesBooleanError),\n/* harmony export */   InvalidBytesTypeError: () => (/* binding */ InvalidBytesTypeError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromArray: () => (/* binding */ fromArray),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n\n\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */ function assert(value) {\n    if (value instanceof Uint8Array) return;\n    if (!value) throw new InvalidBytesTypeError(value);\n    if (typeof value !== \"object\") throw new InvalidBytesTypeError(value);\n    if (!(\"BYTES_PER_ELEMENT\" in value)) throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== \"Uint8Array\") throw new InvalidBytesTypeError(value);\n}\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */ function concat(...values) {\n    let length = 0;\n    for (const arr of values){\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for(let i = 0, index = 0; i < values.length; i++){\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */ function from(value) {\n    if (value instanceof Uint8Array) return value;\n    if (typeof value === \"string\") return fromHex(value);\n    return fromArray(value);\n}\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */ function fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */ function fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === \"number\") {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */ function fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__.assertSize(value, size);\n        hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2) hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for(let index = 0, j = 0; index < length; index++){\n        const nibbleLeft = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft << 4 | nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */ function fromNumber(value, options) {\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, options);\n    return fromHex(hex);\n}\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */ function fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === \"number\") {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */ function isEqual(bytesA, bytesB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.equalBytes)(bytesA, bytesB);\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */ function padLeft(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, {\n        dir: \"left\",\n        size\n    });\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */ function padRight(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, {\n        dir: \"right\",\n        size\n    });\n}\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */ function random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */ function size(value) {\n    return value.length;\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */ function slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict) _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */ function toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== \"undefined\") _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */ function toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== \"undefined\") {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1) throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */ function toHex(value, options = {}) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(value, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */ function toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== \"undefined\") _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toNumber(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */ function toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== \"undefined\") {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */ function trimLeft(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, {\n        dir: \"left\"\n    });\n}\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */ function trimRight(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, {\n        dir: \"right\"\n    });\n}\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */ function validate(value) {\n    try {\n        assert(value);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */ class InvalidBytesBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(bytes){\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                \"The bytes array must contain a single byte of either a `0` or `1` value.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.InvalidBytesBooleanError\"\n        });\n    }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */ class InvalidBytesTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(value){\n        super(`Value \\`${typeof value === \"object\" ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: [\n                \"Bytes values must be of type `Bytes`.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.InvalidBytesTypeError\"\n        });\n    }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */ class SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ givenSize, maxSize }){\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.SizeOverflowError\"\n        });\n    }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */ class SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ offset, position, size }){\n        super(`Slice ${position === \"start\" ? \"starting\" : \"ending\"} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.SliceOffsetOutOfBoundsError\"\n        });\n    }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */ class SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ size, targetSize, type }){\n        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.SizeExceedsPaddingSizeError\"\n        });\n    }\n} //# sourceMappingURL=Bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNwQjtBQUNOO0FBQ2dCO0FBQ0U7QUFDaEI7QUFDbEMsTUFBTU0sVUFBVSxXQUFXLEdBQUcsSUFBSUM7QUFDbEMsTUFBTUMsVUFBVSxXQUFXLEdBQUcsSUFBSUM7QUFDbEM7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxTQUFTQyxPQUFPQyxLQUFLO0lBQ3hCLElBQUlBLGlCQUFpQkMsWUFDakI7SUFDSixJQUFJLENBQUNELE9BQ0QsTUFBTSxJQUFJRSxzQkFBc0JGO0lBQ3BDLElBQUksT0FBT0EsVUFBVSxVQUNqQixNQUFNLElBQUlFLHNCQUFzQkY7SUFDcEMsSUFBSSxDQUFFLHdCQUF1QkEsS0FBSSxHQUM3QixNQUFNLElBQUlFLHNCQUFzQkY7SUFDcEMsSUFBSUEsTUFBTUcsaUJBQWlCLEtBQUssS0FBS0gsTUFBTUksV0FBVyxDQUFDQyxJQUFJLEtBQUssY0FDNUQsTUFBTSxJQUFJSCxzQkFBc0JGO0FBQ3hDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBU00sT0FBTyxHQUFHQyxNQUFNO0lBQzVCLElBQUlDLFNBQVM7SUFDYixLQUFLLE1BQU1DLE9BQU9GLE9BQVE7UUFDdEJDLFVBQVVDLElBQUlELE1BQU07SUFDeEI7SUFDQSxNQUFNRSxTQUFTLElBQUlULFdBQVdPO0lBQzlCLElBQUssSUFBSUcsSUFBSSxHQUFHQyxRQUFRLEdBQUdELElBQUlKLE9BQU9DLE1BQU0sRUFBRUcsSUFBSztRQUMvQyxNQUFNRixNQUFNRixNQUFNLENBQUNJLEVBQUU7UUFDckJELE9BQU9HLEdBQUcsQ0FBQ0osS0FBS0c7UUFDaEJBLFNBQVNILElBQUlELE1BQU07SUFDdkI7SUFDQSxPQUFPRTtBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkJDLEdBQ00sU0FB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QUFDLENBQUMscUJBQXFCLEVBQUVBLFFBQVEsd0JBQXdCLEVBQUVELFVBQVUsU0FBUyxDQUFDO1FBQ3BGUCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1Z2RSxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLE1BQU00RSxvQ0FBb0N0RixpREFBZ0I7SUFDN0RjLFlBQVksRUFBRXlFLE1BQU0sRUFBRUMsUUFBUSxFQUFFM0QsSUFBSSxFQUFHLENBQUU7UUFDckMsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFMkQsYUFBYSxVQUFVLGFBQWEsU0FBUyxhQUFhLEVBQUVELE9BQU8sNkJBQTZCLEVBQUUxRCxLQUFLLElBQUksQ0FBQztRQUMzSGdELE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVnZFLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7OztDQVVDLEdBQ00sTUFBTStFLG9DQUFvQ3pGLGlEQUFnQjtJQUM3RGMsWUFBWSxFQUFFZSxJQUFJLEVBQUU2RCxVQUFVLEVBQUVDLElBQUksRUFBRyxDQUFFO1FBQ3JDLEtBQUssQ0FBQyxDQUFDLEVBQUVBLEtBQUtDLE1BQU0sQ0FBQyxHQUFHQyxXQUFXLEdBQUcsRUFBRUYsS0FDbkN0RCxLQUFLLENBQUMsR0FDTnlELFdBQVcsR0FBRyxTQUFTLEVBQUVqRSxLQUFLLDRCQUE0QixFQUFFNkQsV0FBVyxJQUFJLENBQUM7UUFDakZiLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVnZFLE9BQU87UUFDWDtJQUNKO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmM0MzM3LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CeXRlcy5qcz9mNjc0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVxdWFsQnl0ZXMgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9ieXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbF9oZXggZnJvbSAnLi9pbnRlcm5hbC9oZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuY29uc3QgZGVjb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG5jb25zdCBlbmNvZGVyID0gLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbi8qKlxuICogQXNzZXJ0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuYXNzZXJ0KCdhYmMnKVxuICogLy8gQGVycm9yOiBCeXRlcy5JbnZhbGlkQnl0ZXNUeXBlRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGBcImFiY1wiYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuXG4gKiAvLyBAZXJyb3I6IEJ5dGVzIHZhbHVlcyBtdXN0IGJlIG9mIHR5cGUgYFVpbnQ4QXJyYXlgLlxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAoISgnQllURVNfUEVSX0VMRU1FTlQnIGluIHZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHZhbHVlLkJZVEVTX1BFUl9FTEVNRU5UICE9PSAxIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdVaW50OEFycmF5JylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbmNhdGVuYXRlcyB0d28gb3IgbW9yZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBieXRlcyA9IEJ5dGVzLmNvbmNhdChcbiAqICAgQnl0ZXMuZnJvbShbMV0pLFxuICogICBCeXRlcy5mcm9tKFs2OV0pLFxuICogICBCeXRlcy5mcm9tKFs0MjAsIDY5XSksXG4gKiApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsgMSwgNjksIDQyMCwgNjkgXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIENvbmNhdGVuYXRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgYXJyIG9mIHZhbHVlcykge1xuICAgICAgICBsZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaW5kZXggPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHZhbHVlc1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBmcm9tIGEgYFVpbnQ4QXJyYXlgLCBhIGhleCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHVuc2lnbmVkIDgtYml0IGludGVnZXJzLlxuICpcbiAqIDo6OnRpcFxuICpcbiAqIFRvIGluc3RhbnRpYXRlIGZyb20gYSAqKkJvb2xlYW4qKiwgKipTdHJpbmcqKiwgb3IgKipOdW1iZXIqKiwgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gYEJ5dGVzLmZyb21Cb29sZWFuYFxuICpcbiAqIC0gYEJ5dGVzLmZyb21TdHJpbmdgXG4gKlxuICogLSBgQnl0ZXMuZnJvbU51bWJlcmBcbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbShbMjU1LCAxMjQsIDUsIDRdKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMjU1LCAxMjQsIDUsIDRdKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzIyMiwgMTczLCAxOTAsIDIzOV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21IZXgodmFsdWUpO1xuICAgIHJldHVybiBmcm9tQXJyYXkodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VycyBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tQXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gdmFsdWUgOiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBib29sZWFuIHZhbHVlIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21Cb29sZWFuKHRydWUpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUJvb2xlYW4odHJ1ZSwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBCb29sZWFuIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICBieXRlc1swXSA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgaGV4ID0gdmFsdWU7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgaW50ZXJuYWxfaGV4LmFzc2VydFNpemUodmFsdWUsIHNpemUpO1xuICAgICAgICBoZXggPSBIZXgucGFkUmlnaHQodmFsdWUsIHNpemUpO1xuICAgIH1cbiAgICBsZXQgaGV4U3RyaW5nID0gaGV4LnNsaWNlKDIpO1xuICAgIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMilcbiAgICAgICAgaGV4U3RyaW5nID0gYDAke2hleFN0cmluZ31gO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhleFN0cmluZy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGogPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBuaWJibGVMZWZ0ID0gaW50ZXJuYWwuY2hhckNvZGVUb0Jhc2UxNihoZXhTdHJpbmcuY2hhckNvZGVBdChqKyspKTtcbiAgICAgICAgY29uc3QgbmliYmxlUmlnaHQgPSBpbnRlcm5hbC5jaGFyQ29kZVRvQmFzZTE2KGhleFN0cmluZy5jaGFyQ29kZUF0KGorKykpO1xuICAgICAgICBpZiAobmliYmxlTGVmdCA9PT0gdW5kZWZpbmVkIHx8IG5pYmJsZVJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKGBJbnZhbGlkIGJ5dGUgc2VxdWVuY2UgKFwiJHtoZXhTdHJpbmdbaiAtIDJdfSR7aGV4U3RyaW5nW2ogLSAxXX1cIiBpbiBcIiR7aGV4U3RyaW5nfVwiKS5gKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlc1tpbmRleF0gPSAobmliYmxlTGVmdCA8PCA0KSB8IG5pYmJsZVJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSBudW1iZXIgdmFsdWUgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbU51bWJlcig0MjApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxLCAxNjRdKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tTnVtYmVyKDQyMCwgeyBzaXplOiA0IH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFswLCAwLCAxLCAxNjRdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gTnVtYmVyIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbU51bWJlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZyb21IZXgoaGV4KTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyB3b3JsZCEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21TdHJpbmcoJ0hlbGxvIHdvcmxkIScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzMywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBTdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRW5jb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRSaWdodChieXRlcywgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlcyBhcmUgZXF1YWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmlzRXF1YWwoQnl0ZXMuZnJvbShbMV0pLCBCeXRlcy5mcm9tKFsxXSkpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKlxuICogQnl0ZXMuaXNFcXVhbChCeXRlcy5mcm9tKFsxXSksIEJ5dGVzLmZyb20oWzJdKSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXNBIC0gRmlyc3Qge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEBwYXJhbSBieXRlc0IgLSBTZWNvbmQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHdvIHZhbHVlcyBhcmUgZXF1YWwsIG90aGVyd2lzZSBgZmFsc2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbChieXRlc0EsIGJ5dGVzQikge1xuICAgIHJldHVybiBlcXVhbEJ5dGVzKGJ5dGVzQSwgYnl0ZXNCKTtcbn1cbi8qKlxuICogUGFkcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gdGhlIGxlZnQgd2l0aCB6ZXJvIGJ5dGVzIHVudGlsIGl0IHJlYWNoZXMgdGhlIGdpdmVuIGBzaXplYCAoZGVmYXVsdDogMzIgYnl0ZXMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5wYWRMZWZ0KEJ5dGVzLmZyb20oWzFdKSwgNClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDFdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFNpemUgdG8gcGFkIHRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvLlxuICogQHJldHVybnMgUGFkZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRMZWZ0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdsZWZ0Jywgc2l6ZSB9KTtcbn1cbi8qKlxuICogUGFkcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gdGhlIHJpZ2h0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMucGFkUmlnaHQoQnl0ZXMuZnJvbShbMV0pLCA0KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMCwgMCwgMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIHBhZC5cbiAqIEBwYXJhbSBzaXplIC0gU2l6ZSB0byBwYWQgdGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8uXG4gKiBAcmV0dXJucyBQYWRkZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZFJpZ2h0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdyaWdodCcsIHNpemUgfSk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyByYW5kb20ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYnl0ZXMgPSBCeXRlcy5yYW5kb20oMzIpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsuLi4geDMyXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsZW5ndGggLSBMZW5ndGggb2YgdGhlIHJhbmRvbSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMgUmFuZG9tIHtAbGluayBveCNCeXRlcy5CeXRlc30gb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20obGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSk7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgc2l6ZSBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnNpemUoQnl0ZXMuZnJvbShbMSwgMiwgMywgNF0pKVxuICogLy8gQGxvZzogNFxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIFNpemUgb2YgdGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNlY3Rpb24gb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGdpdmVuIGEgc3RhcnQvZW5kIGJ5dGVzIG9mZnNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuc2xpY2UoXG4gKiAgIEJ5dGVzLmZyb20oWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldKSxcbiAqICAgMSxcbiAqICAgNCxcbiAqIClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzIsIDMsIDRdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcGFyYW0gc3RhcnQgLSBTdGFydCBvZmZzZXQuXG4gKiBAcGFyYW0gZW5kIC0gRW5kIG9mZnNldC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gU2xpY2Ugb3B0aW9ucy5cbiAqIEByZXR1cm5zIFNsaWNlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0IH0gPSBvcHRpb25zO1xuICAgIGludGVybmFsLmFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCk7XG4gICAgY29uc3QgdmFsdWVfID0gdmFsdWUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgaWYgKHN0cmljdClcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlXywgc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHZhbHVlXztcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW50byBhIGJpZ2ludC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9CaWdJbnQoQnl0ZXMuZnJvbShbMSwgMTY0XSkpXG4gKiAvLyBAbG9nOiA0MjBuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIERlY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIGJpZ2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21CeXRlcyhieXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEhleC50b0JpZ0ludChoZXgsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnRvIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9Cb29sZWFuKEJ5dGVzLmZyb20oWzFdKSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRGVjb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQgYm9vbGVhbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQm9vbGVhbihieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGxldCBieXRlc18gPSBieXRlcztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXNfLCBzaXplKTtcbiAgICAgICAgYnl0ZXNfID0gdHJpbUxlZnQoYnl0ZXNfKTtcbiAgICB9XG4gICAgaWYgKGJ5dGVzXy5sZW5ndGggPiAxIHx8IGJ5dGVzX1swXSA+IDEpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3IoYnl0ZXNfKTtcbiAgICByZXR1cm4gQm9vbGVhbihieXRlc19bMF0pO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50b0hleChCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKHZhbHVlLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW50byBhIG51bWJlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9OdW1iZXIoQnl0ZXMuZnJvbShbMSwgMTY0XSkpXG4gKiAvLyBAbG9nOiA0MjBcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9OdW1iZXIoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbUJ5dGVzKGJ5dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gSGV4LnRvTnVtYmVyKGhleCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy50b1N0cmluZyhCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vIEBsb2c6ICdIZWxsbyB3b3JsZCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXNfID0gYnl0ZXM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzXywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzXyA9IHRyaW1SaWdodChieXRlc18pO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnl0ZXNfKTtcbn1cbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudHJpbUxlZnQoQnl0ZXMuZnJvbShbMCwgMCwgMCwgMCwgMSwgMiwgM10pKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHJldHVybnMgVHJpbW1lZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbUxlZnQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdsZWZ0JyB9KTtcbn1cbi8qKlxuICogVHJpbXMgdHJhaWxpbmcgemVyb3MgZnJvbSBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRyaW1SaWdodChCeXRlcy5mcm9tKFsxLCAyLCAzLCAwLCAwLCAwLCAwXSkpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxLCAyLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBUcmltbWVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltUmlnaHQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdyaWdodCcgfSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudmFsaWRhdGUoJzB4JylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKlxuICogQnl0ZXMudmFsaWRhdGUoQnl0ZXMuZnJvbShbMSwgMiwgM10pKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIHtAbGluayBveCNCeXRlcy5CeXRlc30sIG90aGVyd2lzZSBgZmFsc2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgYnl0ZXMgdmFsdWUgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9Cb29sZWFuKEJ5dGVzLmZyb20oWzVdKSlcbiAqIC8vIEBlcnJvcjogQnl0ZXMuSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yOiBCeXRlcyB2YWx1ZSBgWzVdYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLlxuICogLy8gQGVycm9yOiBUaGUgYnl0ZXMgYXJyYXkgbXVzdCBjb250YWluIGEgc2luZ2xlIGJ5dGUgb2YgZWl0aGVyIGEgYDBgIG9yIGAxYCB2YWx1ZS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoYEJ5dGVzIHZhbHVlIFxcYCR7Ynl0ZXN9XFxgIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1RoZSBieXRlcyBhcnJheSBtdXN0IGNvbnRhaW4gYSBzaW5nbGUgYnl0ZSBvZiBlaXRoZXIgYSBgMGAgb3IgYDFgIHZhbHVlLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHZhbHVlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuZnJvbSgnZm9vJylcbiAqIC8vIEBlcnJvcjogQnl0ZXMuSW52YWxpZEJ5dGVzVHlwZUVycm9yOiBWYWx1ZSBgZm9vYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRCeXRlc1R5cGVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3R5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyBKc29uLnN0cmluZ2lmeSh2YWx1ZSkgOiB2YWx1ZX1cXGAgb2YgdHlwZSBcXGAke3R5cGVvZiB2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBCeXRlcyB2YWx1ZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFsnQnl0ZXMgdmFsdWVzIG11c3QgYmUgb2YgdHlwZSBgQnl0ZXNgLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLkludmFsaWRCeXRlc1R5cGVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHNpemUgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScsIHsgc2l6ZTogOCB9KVxuICogLy8gQGVycm9yOiBCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcjogU2l6ZSBjYW5ub3QgZXhjZWVkIGA4YCBieXRlcy4gR2l2ZW4gc2l6ZTogYDEyYCBieXRlcy5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdpdmVuU2l6ZSwgbWF4U2l6ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIGNhbm5vdCBleGNlZWQgXFxgJHttYXhTaXplfVxcYCBieXRlcy4gR2l2ZW4gc2l6ZTogXFxgJHtnaXZlblNpemV9XFxgIGJ5dGVzLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2l6ZU92ZXJmbG93RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBzbGljZSBvZmZzZXQgaXMgb3V0LW9mLWJvdW5kcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuc2xpY2UoQnl0ZXMuZnJvbShbMSwgMiwgM10pLCA0KVxuICogLy8gQGVycm9yOiBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3I6IFNsaWNlIHN0YXJ0aW5nIGF0IG9mZnNldCBgNGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogYDNgKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQsIHBvc2l0aW9uLCBzaXplLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTbGljZSAke3Bvc2l0aW9uID09PSAnc3RhcnQnID8gJ3N0YXJ0aW5nJyA6ICdlbmRpbmcnfSBhdCBvZmZzZXQgXFxgJHtvZmZzZXR9XFxgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IFxcYCR7c2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgdGhlIHBhZGRpbmcgc2l6ZSBleGNlZWRzIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMucGFkTGVmdChCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnKSwgOClcbiAqIC8vIEBlcnJvcjogW0J5dGVzLlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcjogQnl0ZXMgc2l6ZSAoYDEyYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKGA4YCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2l6ZSwgdGFyZ2V0U2l6ZSwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgJHt0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7dHlwZVxuICAgICAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKX0gc2l6ZSAoXFxgJHtzaXplfVxcYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKFxcYCR7dGFyZ2V0U2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CeXRlcy5qcy5tYXAiXSwibmFtZXMiOlsiZXF1YWxCeXRlcyIsIkVycm9ycyIsIkhleCIsImludGVybmFsIiwiaW50ZXJuYWxfaGV4IiwiSnNvbiIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImFzc2VydCIsInZhbHVlIiwiVWludDhBcnJheSIsIkludmFsaWRCeXRlc1R5cGVFcnJvciIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY29uY2F0IiwidmFsdWVzIiwibGVuZ3RoIiwiYXJyIiwicmVzdWx0IiwiaSIsImluZGV4Iiwic2V0IiwiZnJvbSIsImZyb21IZXgiLCJmcm9tQXJyYXkiLCJmcm9tQm9vbGVhbiIsIm9wdGlvbnMiLCJzaXplIiwiYnl0ZXMiLCJOdW1iZXIiLCJhc3NlcnRTaXplIiwicGFkTGVmdCIsImhleCIsInBhZFJpZ2h0IiwiaGV4U3RyaW5nIiwic2xpY2UiLCJqIiwibmliYmxlTGVmdCIsImNoYXJDb2RlVG9CYXNlMTYiLCJjaGFyQ29kZUF0IiwibmliYmxlUmlnaHQiLCJ1bmRlZmluZWQiLCJCYXNlRXJyb3IiLCJmcm9tTnVtYmVyIiwiZnJvbVN0cmluZyIsImVuY29kZSIsImlzRXF1YWwiLCJieXRlc0EiLCJieXRlc0IiLCJwYWQiLCJkaXIiLCJyYW5kb20iLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJzdGFydCIsImVuZCIsInN0cmljdCIsImFzc2VydFN0YXJ0T2Zmc2V0IiwidmFsdWVfIiwiYXNzZXJ0RW5kT2Zmc2V0IiwidG9CaWdJbnQiLCJmcm9tQnl0ZXMiLCJ0b0Jvb2xlYW4iLCJieXRlc18iLCJ0cmltTGVmdCIsIkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvciIsIkJvb2xlYW4iLCJ0b0hleCIsInRvTnVtYmVyIiwidG9TdHJpbmciLCJ0cmltUmlnaHQiLCJkZWNvZGUiLCJ0cmltIiwidmFsaWRhdGUiLCJtZXRhTWVzc2FnZXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInN0cmluZ2lmeSIsIlNpemVPdmVyZmxvd0Vycm9yIiwiZ2l2ZW5TaXplIiwibWF4U2l6ZSIsIlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciIsIm9mZnNldCIsInBvc2l0aW9uIiwiU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIiwidGFyZ2V0U2l6ZSIsInR5cGUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Caches.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Caches.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   clear: () => (/* binding */ clear)\n/* harmony export */ });\n/* harmony import */ var _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/lru.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/lru.js\");\n\nconst caches = {\n    checksum: /*#__PURE__*/ new _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__.LruMap(8192)\n};\nconst checksum = caches.checksum;\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */ function clear() {\n    for (const cache of Object.values(caches))cache.clear();\n} //# sourceMappingURL=Caches.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0NhY2hlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkM7QUFDM0MsTUFBTUMsU0FBUztJQUNYQyxVQUFVLFdBQVcsR0FBRyxJQUFJRixvREFBTUEsQ0FBQztBQUN2QztBQUNPLE1BQU1FLFdBQVdELE9BQU9DLFFBQVEsQ0FBQztBQUN4Qzs7Ozs7Ozs7Q0FRQyxHQUNNLFNBQVNDO0lBQ1osS0FBSyxNQUFNQyxTQUFTQyxPQUFPQyxNQUFNLENBQUNMLFFBQzlCRyxNQUFNRCxLQUFLO0FBQ25CLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjNDMzNy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQ2FjaGVzLmpzPzcwZDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTHJ1TWFwIH0gZnJvbSAnLi9pbnRlcm5hbC9scnUuanMnO1xuY29uc3QgY2FjaGVzID0ge1xuICAgIGNoZWNrc3VtOiAvKiNfX1BVUkVfXyovIG5ldyBMcnVNYXAoODE5MiksXG59O1xuZXhwb3J0IGNvbnN0IGNoZWNrc3VtID0gY2FjaGVzLmNoZWNrc3VtO1xuLyoqXG4gKiBDbGVhcnMgYWxsIGdsb2JhbCBjYWNoZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDYWNoZXMgfSBmcm9tICdveCdcbiAqIENhY2hlcy5jbGVhcigpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgY2FjaGUgb2YgT2JqZWN0LnZhbHVlcyhjYWNoZXMpKVxuICAgICAgICBjYWNoZS5jbGVhcigpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJMcnVNYXAiLCJjYWNoZXMiLCJjaGVja3N1bSIsImNsZWFyIiwiY2FjaGUiLCJPYmplY3QiLCJ2YWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Caches.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Errors.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError)\n/* harmony export */ });\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/errors.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/errors.js\");\n\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */ class BaseError extends Error {\n    static setStaticOptions(options) {\n        BaseError.prototype.docsOrigin = options.docsOrigin;\n        BaseError.prototype.showVersion = options.showVersion;\n        BaseError.prototype.version = options.version;\n    }\n    constructor(shortMessage, options = {}){\n        const details = (()=>{\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details) return options.cause.details;\n                if (options.cause.shortMessage) return options.cause.shortMessage;\n            }\n            if (options.cause && \"details\" in options.cause && typeof options.cause.details === \"string\") return options.cause.details;\n            if (options.cause?.message) return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (()=>{\n            if (options.cause instanceof BaseError) return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = options.docsOrigin ?? BaseError.prototype.docsOrigin;\n        const docs = `${docsBaseUrl}${docsPath ?? \"\"}`;\n        const showVersion = Boolean(options.version ?? BaseError.prototype.showVersion);\n        const version = options.version ?? BaseError.prototype.version;\n        const message = [\n            shortMessage || \"An error occurred.\",\n            ...options.metaMessages ? [\n                \"\",\n                ...options.metaMessages\n            ] : [],\n            ...details || docsPath || showVersion ? [\n                \"\",\n                details ? `Details: ${details}` : undefined,\n                docsPath ? `See: ${docs}` : undefined,\n                showVersion ? `Version: ${version}` : undefined\n            ] : []\n        ].filter((x)=>typeof x === \"string\").join(\"\\n\");\n        super(message, options.cause ? {\n            cause: options.cause\n        } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsOrigin\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"showVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"BaseError\"\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsOrigin = docsBaseUrl;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n        this.showVersion = showVersion;\n        this.version = version;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nObject.defineProperty(BaseError, \"defaultStaticOptions\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        docsOrigin: \"https://oxlib.sh\",\n        showVersion: false,\n        version: `ox@${(0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_0__.getVersion)()}`\n    }\n});\n(()=>{\n    BaseError.setStaticOptions(BaseError.defaultStaticOptions);\n})();\n/** @internal */ function walk(err, fn) {\n    if (fn?.(err)) return err;\n    if (err && typeof err === \"object\" && \"cause\" in err && err.cause) return walk(err.cause, fn);\n    return fn ? null : err;\n} //# sourceMappingURL=Errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrRDtBQUNsRDs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU1DLGtCQUFrQkM7SUFDM0IsT0FBT0MsaUJBQWlCQyxPQUFPLEVBQUU7UUFDN0JILFVBQVVJLFNBQVMsQ0FBQ0MsVUFBVSxHQUFHRixRQUFRRSxVQUFVO1FBQ25ETCxVQUFVSSxTQUFTLENBQUNFLFdBQVcsR0FBR0gsUUFBUUcsV0FBVztRQUNyRE4sVUFBVUksU0FBUyxDQUFDRyxPQUFPLEdBQUdKLFFBQVFJLE9BQU87SUFDakQ7SUFDQUMsWUFBWUMsWUFBWSxFQUFFTixVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQ3BDLE1BQU1PLFVBQVUsQ0FBQztZQUNiLElBQUlQLFFBQVFRLEtBQUssWUFBWVgsV0FBVztnQkFDcEMsSUFBSUcsUUFBUVEsS0FBSyxDQUFDRCxPQUFPLEVBQ3JCLE9BQU9QLFFBQVFRLEtBQUssQ0FBQ0QsT0FBTztnQkFDaEMsSUFBSVAsUUFBUVEsS0FBSyxDQUFDRixZQUFZLEVBQzFCLE9BQU9OLFFBQVFRLEtBQUssQ0FBQ0YsWUFBWTtZQUN6QztZQUNBLElBQUlOLFFBQVFRLEtBQUssSUFDYixhQUFhUixRQUFRUSxLQUFLLElBQzFCLE9BQU9SLFFBQVFRLEtBQUssQ0FBQ0QsT0FBTyxLQUFLLFVBQ2pDLE9BQU9QLFFBQVFRLEtBQUssQ0FBQ0QsT0FBTztZQUNoQyxJQUFJUCxRQUFRUSxLQUFLLEVBQUVDLFNBQ2YsT0FBT1QsUUFBUVEsS0FBSyxDQUFDQyxPQUFPO1lBQ2hDLE9BQU9ULFFBQVFPLE9BQU87UUFDMUI7UUFDQSxNQUFNRyxXQUFXLENBQUM7WUFDZCxJQUFJVixRQUFRUSxLQUFLLFlBQVlYLFdBQ3pCLE9BQU9HLFFBQVFRLEtBQUssQ0FBQ0UsUUFBUSxJQUFJVixRQUFRVSxRQUFRO1lBQ3JELE9BQU9WLFFBQVFVLFFBQVE7UUFDM0I7UUFDQSxNQUFNQyxjQUFjWCxRQUFR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QyxjQUFjO0lBQ2RDLFVBQVU7SUFDVkMsT0FBTztRQUNIdEIsWUFBWTtRQUNaQyxhQUFhO1FBQ2JDLFNBQVMsQ0FBQyxHQUFHLEVBQUVSLCtEQUFVQSxHQUFHLENBQUM7SUFDakM7QUFDSjtBQUNDO0lBQ0dDLFVBQVVFLGdCQUFnQixDQUFDRixVQUFVOEIsb0JBQW9CO0FBQzdEO0FBQ0EsY0FBYyxHQUNkLFNBQVNGLEtBQUtHLEdBQUcsRUFBRUYsRUFBRTtJQUNqQixJQUFJQSxLQUFLRSxNQUNMLE9BQU9BO0lBQ1gsSUFBSUEsT0FBTyxPQUFPQSxRQUFRLFlBQVksV0FBV0EsT0FBT0EsSUFBSXBCLEtBQUssRUFDN0QsT0FBT2lCLEtBQUtHLElBQUlwQixLQUFLLEVBQUVrQjtJQUMzQixPQUFPQSxLQUFLLE9BQU9FO0FBQ3ZCLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjNDMzNy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvRXJyb3JzLmpzPzlkNTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VmVyc2lvbiB9IGZyb20gJy4vaW50ZXJuYWwvZXJyb3JzLmpzJztcbi8qKlxuICogQmFzZSBlcnJvciBjbGFzcyBpbmhlcml0ZWQgYnkgYWxsIGVycm9ycyB0aHJvd24gYnkgb3guXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBFcnJvcnMgfSBmcm9tICdveCdcbiAqIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBzdGF0aWMgc2V0U3RhdGljT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIEJhc2VFcnJvci5wcm90b3R5cGUuZG9jc09yaWdpbiA9IG9wdGlvbnMuZG9jc09yaWdpbjtcbiAgICAgICAgQmFzZUVycm9yLnByb3RvdHlwZS5zaG93VmVyc2lvbiA9IG9wdGlvbnMuc2hvd1ZlcnNpb247XG4gICAgICAgIEJhc2VFcnJvci5wcm90b3R5cGUudmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2hvcnRNZXNzYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlLmRldGFpbHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLmRldGFpbHM7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2Uuc2hvcnRNZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5zaG9ydE1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSAmJlxuICAgICAgICAgICAgICAgICdkZXRhaWxzJyBpbiBvcHRpb25zLmNhdXNlICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMuY2F1c2UuZGV0YWlscyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZGV0YWlscztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlPy5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLm1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kZXRhaWxzO1xuICAgICAgICB9KSgpO1xuICAgICAgICBjb25zdCBkb2NzUGF0aCA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5kb2NzUGF0aCB8fCBvcHRpb25zLmRvY3NQYXRoO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZG9jc1BhdGg7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IGRvY3NCYXNlVXJsID0gb3B0aW9ucy5kb2NzT3JpZ2luID8/IEJhc2VFcnJvci5wcm90b3R5cGUuZG9jc09yaWdpbjtcbiAgICAgICAgY29uc3QgZG9jcyA9IGAke2RvY3NCYXNlVXJsfSR7ZG9jc1BhdGggPz8gJyd9YDtcbiAgICAgICAgY29uc3Qgc2hvd1ZlcnNpb24gPSBCb29sZWFuKG9wdGlvbnMudmVyc2lvbiA/PyBCYXNlRXJyb3IucHJvdG90eXBlLnNob3dWZXJzaW9uKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiA/PyBCYXNlRXJyb3IucHJvdG90eXBlLnZlcnNpb247XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2UgfHwgJ0FuIGVycm9yIG9jY3VycmVkLicsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5tZXRhTWVzc2FnZXMgPyBbJycsIC4uLm9wdGlvbnMubWV0YU1lc3NhZ2VzXSA6IFtdKSxcbiAgICAgICAgICAgIC4uLihkZXRhaWxzIHx8IGRvY3NQYXRoIHx8IHNob3dWZXJzaW9uXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID8gYERldGFpbHM6ICR7ZGV0YWlsc31gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBkb2NzUGF0aCA/IGBTZWU6ICR7ZG9jc31gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBzaG93VmVyc2lvbiA/IGBWZXJzaW9uOiAke3ZlcnNpb259YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgIF1cbiAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+IHR5cGVvZiB4ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucy5jYXVzZSA/IHsgY2F1c2U6IG9wdGlvbnMuY2F1c2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRldGFpbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzT3JpZ2luXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NQYXRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3J0TWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG93VmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhdXNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCYXNlRXJyb3InXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhdXNlID0gb3B0aW9ucy5jYXVzZTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICAgICAgdGhpcy5kb2NzID0gZG9jcztcbiAgICAgICAgdGhpcy5kb2NzT3JpZ2luID0gZG9jc0Jhc2VVcmw7XG4gICAgICAgIHRoaXMuZG9jc1BhdGggPSBkb2NzUGF0aDtcbiAgICAgICAgdGhpcy5zaG9ydE1lc3NhZ2UgPSBzaG9ydE1lc3NhZ2U7XG4gICAgICAgIHRoaXMuc2hvd1ZlcnNpb24gPSBzaG93VmVyc2lvbjtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG4gICAgd2Fsayhmbikge1xuICAgICAgICByZXR1cm4gd2Fsayh0aGlzLCBmbik7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvciwgXCJkZWZhdWx0U3RhdGljT3B0aW9uc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHtcbiAgICAgICAgZG9jc09yaWdpbjogJ2h0dHBzOi8vb3hsaWIuc2gnLFxuICAgICAgICBzaG93VmVyc2lvbjogZmFsc2UsXG4gICAgICAgIHZlcnNpb246IGBveEAke2dldFZlcnNpb24oKX1gLFxuICAgIH1cbn0pO1xuKCgpID0+IHtcbiAgICBCYXNlRXJyb3Iuc2V0U3RhdGljT3B0aW9ucyhCYXNlRXJyb3IuZGVmYXVsdFN0YXRpY09wdGlvbnMpO1xufSkoKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHdhbGsoZXJyLCBmbikge1xuICAgIGlmIChmbj8uKGVycikpXG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgaWYgKGVyciAmJiB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJiAnY2F1c2UnIGluIGVyciAmJiBlcnIuY2F1c2UpXG4gICAgICAgIHJldHVybiB3YWxrKGVyci5jYXVzZSwgZm4pO1xuICAgIHJldHVybiBmbiA/IG51bGwgOiBlcnI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbImdldFZlcnNpb24iLCJCYXNlRXJyb3IiLCJFcnJvciIsInNldFN0YXRpY09wdGlvbnMiLCJvcHRpb25zIiwicHJvdG90eXBlIiwiZG9jc09yaWdpbiIsInNob3dWZXJzaW9uIiwidmVyc2lvbiIsImNvbnN0cnVjdG9yIiwic2hvcnRNZXNzYWdlIiwiZGV0YWlscyIsImNhdXNlIiwibWVzc2FnZSIsImRvY3NQYXRoIiwiZG9jc0Jhc2VVcmwiLCJkb2NzIiwiQm9vbGVhbiIsIm1ldGFNZXNzYWdlcyIsInVuZGVmaW5lZCIsImZpbHRlciIsIngiLCJqb2luIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsIndhbGsiLCJmbiIsImRlZmF1bHRTdGF0aWNPcHRpb25zIiwiZXJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Hash.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hash.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */ function keccak256(value, options = {}) {\n    const { as = typeof value === \"string\" ? \"Hex\" : \"Bytes\" } = options;\n    const bytes = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === \"Bytes\") return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */ function ripemd160(value, options = {}) {\n    const { as = typeof value === \"string\" ? \"Hex\" : \"Bytes\" } = options;\n    const bytes = (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__.ripemd160)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === \"Bytes\") return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */ function sha256(value, options = {}) {\n    const { as = typeof value === \"string\" ? \"Hex\" : \"Bytes\" } = options;\n    const bytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === \"Bytes\") return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */ function validate(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(value) && _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value) === 32;\n} //# sourceMappingURL=Hash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hhc2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ0o7QUFDTDtBQUMxQjtBQUNKO0FBQ2hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQ0MsR0FDTSxTQUFTUSxVQUFVQyxLQUFLLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sRUFBRUMsS0FBSyxPQUFPRixVQUFVLFdBQVcsUUFBUSxPQUFPLEVBQUUsR0FBR0M7SUFDN0QsTUFBTUUsUUFBUVQsOERBQWVBLENBQUNHLDJDQUFVLENBQUNHO0lBQ3pDLElBQUlFLE9BQU8sU0FDUCxPQUFPQztJQUNYLE9BQU9MLDhDQUFhLENBQUNLO0FBQ3pCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxTQUFTWixVQUFVUyxLQUFLLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sRUFBRUMsS0FBSyxPQUFPRixVQUFVLFdBQVcsUUFBUSxPQUFPLEVBQUUsR0FBR0M7SUFDN0QsTUFBTUUsUUFBUVgsa0VBQWVBLENBQUNLLDJDQUFVLENBQUNHO0lBQ3pDLElBQUlFLE9BQU8sU0FDUCxPQUFPQztJQUNYLE9BQU9MLDhDQUFhLENBQUNLO0FBQ3pCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxTQUFTUixPQUFPSyxLQUFLLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RDLE1BQU0sRUFBRUMsS0FBSyxPQUFPRixVQUFVLFdBQVcsUUFBUSxPQUFPLEVBQUUsR0FBR0M7SUFDN0QsTUFBTUUsUUFBUVAsNERBQVlBLENBQUNDLDJDQUFVLENBQUNHO0lBQ3RDLElBQUlFLE9BQU8sU0FDUCxPQUFPQztJQUNYLE9BQU9MLDhDQUFhLENBQUNLO0FBQ3pCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxTQUFTRyxTQUFTTixLQUFLO0lBQzFCLE9BQU9GLDZDQUFZLENBQUNFLFVBQVVGLHlDQUFRLENBQUNFLFdBQVc7QUFDdEQsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmM0MzM3LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9IYXNoLmpzPzQ5NDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmlwZW1kMTYwIGFzIG5vYmxlX3JpcGVtZDE2MCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvcmlwZW1kMTYwJztcbmltcG9ydCB7IGtlY2Nha18yNTYgYXMgbm9ibGVfa2VjY2FrMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEzJztcbmltcG9ydCB7IHNoYTI1NiBhcyBub2JsZV9zaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFtLZWNjYWsyNTZdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NIQS0zKSBoYXNoIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHJlLWV4cG9ydCBvZiBga2VjY2FrXzI1NmAgZnJvbSBbYEBub2JsZS9oYXNoZXNgXShodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLWhhc2hlcyksIGFuIGF1ZGl0ZWQgJiBtaW5pbWFsIEpTIGhhc2hpbmcgbGlicmFyeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhhc2ggfSBmcm9tICdveCdcbiAqXG4gKiBIYXNoLmtlY2NhazI1NignMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiAnMHhkNGZkNGUxODkxMzIyNzMwMzY0NDlmYzllMTExOThjNzM5MTYxYjRjMDExNmE5YTJkY2NkZmExYzQ5MjAwNmYxJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDYWxjdWxhdGUgSGFzaCBvZiBhIFN0cmluZ1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIYXNoLmtlY2NhazI1NihIZXguZnJvbVN0cmluZygnaGVsbG8gd29ybGQnKSlcbiAqIC8vIEBsb2c6ICcweDNlYTJmMWQwYWJmM2ZjNjZjZjI5ZWViYjcwY2JkNGU3ZmU3NjJlZjhhMDliY2MwNmM4ZWRmNjQxMjMwYWZlYzAnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbmZpZ3VyZSBSZXR1cm4gVHlwZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoJzB4ZGVhZGJlZWYnLCB7IGFzOiAnQnl0ZXMnIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsuLi5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIEtlY2NhazI1NiBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5vYmxlX2tlY2NhazI1NihCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBbUmlwZW1kMTYwXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SSVBFTUQpIGhhc2ggb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgcmUtZXhwb3J0IG9mIGByaXBlbWQxNjBgIGZyb20gW2BAbm9ibGUvaGFzaGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1oYXNoZXMpLCBhbiBhdWRpdGVkICYgbWluaW1hbCBKUyBoYXNoaW5nIGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5yaXBlbWQxNjAoJzB4ZGVhZGJlZWYnKVxuICogLy8gJzB4MjI2ODIxYzJmNTQyM2UxMWZlOWFmNjhiZDI4NWMyNDlkYjJlNGI1YSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgUmlwZW1kMTYwIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByaXBlbWQxNjAodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gbm9ibGVfcmlwZW1kMTYwKEJ5dGVzLmZyb20odmFsdWUpKTtcbiAgICBpZiAoYXMgPT09ICdCeXRlcycpXG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFtTaGEyNTZdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NIQS0yNTYpIGhhc2ggb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgcmUtZXhwb3J0IG9mIGBzaGEyNTZgIGZyb20gW2BAbm9ibGUvaGFzaGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1oYXNoZXMpLCBhbiBhdWRpdGVkICYgbWluaW1hbCBKUyBoYXNoaW5nIGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5zaGEyNTYoJzB4ZGVhZGJlZWYnKVxuICogLy8gJzB4NWY3OGMzMzI3NGU0M2ZhOWRlNTY1OTI2NWMxZDkxN2UyNWMwMzcyMmRjYjBiOGQyN2RiOGQ1ZmVhYTgxMzk1MydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgU2hhMjU2IGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGEyNTYodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gbm9ibGVfc2hhMjU2KEJ5dGVzLmZyb20odmFsdWUpKTtcbiAgICBpZiAoYXMgPT09ICdCeXRlcycpXG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhhc2ggdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC52YWxpZGF0ZSgnMHgnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqXG4gKiBIYXNoLnZhbGlkYXRlKCcweDNlYTJmMWQwYWJmM2ZjNjZjZjI5ZWViYjcwY2JkNGU3ZmU3NjJlZjhhMDliY2MwNmM4ZWRmNjQxMjMwYWZlYzAnKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBIZXgudmFsaWRhdGUodmFsdWUpICYmIEhleC5zaXplKHZhbHVlKSA9PT0gMzI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IYXNoLmpzLm1hcCJdLCJuYW1lcyI6WyJyaXBlbWQxNjAiLCJub2JsZV9yaXBlbWQxNjAiLCJrZWNjYWtfMjU2Iiwibm9ibGVfa2VjY2FrMjU2Iiwic2hhMjU2Iiwibm9ibGVfc2hhMjU2IiwiQnl0ZXMiLCJIZXgiLCJrZWNjYWsyNTYiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJhcyIsImJ5dGVzIiwiZnJvbSIsImZyb21CeXRlcyIsInZhbGlkYXRlIiwic2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Hex.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hex.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegerOutOfRangeError: () => (/* binding */ IntegerOutOfRangeError),\n/* harmony export */   InvalidHexBooleanError: () => (/* binding */ InvalidHexBooleanError),\n/* harmony export */   InvalidHexTypeError: () => (/* binding */ InvalidHexTypeError),\n/* harmony export */   InvalidHexValueError: () => (/* binding */ InvalidHexValueError),\n/* harmony export */   InvalidLengthError: () => (/* binding */ InvalidLengthError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst hexes = /*#__PURE__*/ Array.from({\n    length: 256\n}, (_v, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */ function assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value) throw new InvalidHexTypeError(value);\n    if (typeof value !== \"string\") throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith(\"0x\")) throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */ function concat(...values) {\n    return `0x${values.reduce((acc, x)=>acc + x.replace(\"0x\", \"\"), \"\")}`;\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */ function from(value) {\n    if (value instanceof Uint8Array) return fromBytes(value);\n    if (Array.isArray(value)) return fromBytes(new Uint8Array(value));\n    return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */ function fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === \"number\") {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */ function fromBytes(value, options = {}) {\n    let string = \"\";\n    for(let i = 0; i < value.length; i++)string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === \"number\") {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */ function fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;\n        else maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    } else if (typeof value === \"number\") {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === \"bigint\" && signed ? -maxValue - 1n : 0;\n    if (maxValue && value_ > maxValue || value_ < minValue) {\n        const suffix = typeof value === \"bigint\" ? \"n\" : \"\";\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? BigInt.asUintN(size * 8, BigInt(value_)) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size) return padLeft(hex, size);\n    return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */ function fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */ function isEqual(hexA, hexB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexA), _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */ function padLeft(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, {\n        dir: \"left\",\n        size\n    });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */ function padRight(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, {\n        dir: \"right\",\n        size\n    });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */ function random(length) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */ function slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = `0x${value.replace(\"0x\", \"\").slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict) _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */ function size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */ function trimLeft(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, {\n        dir: \"left\"\n    });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */ function trimRight(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, {\n        dir: \"right\"\n    });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */ function toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size) _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed) return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << BigInt(size) * 8n) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed) return value;\n    return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */ function toBoolean(hex, options = {}) {\n    if (options.size) _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === \"0x\") return false;\n    if (hex_ === \"0x1\") return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */ function toBytes(hex, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */ function toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size) return Number(hex);\n    return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */ function toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex);\n    if (size) {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__.assertSize(bytes, size);\n        bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */ function validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, {\n            strict\n        });\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */ class IntegerOutOfRangeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ max, min, signed, size, value }){\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : \"\"}${signed ? \" signed\" : \" unsigned\"} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.IntegerOutOfRangeError\"\n        });\n    }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */ class InvalidHexBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(hex){\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).'\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.InvalidHexBooleanError\"\n        });\n    }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */ class InvalidHexTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value){\n        super(`Value \\`${typeof value === \"object\" ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: [\n                'Hex types must be represented as `\"0x${string}\"`.'\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.InvalidHexTypeError\"\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */ class InvalidHexValueError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value){\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).'\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.InvalidHexValueError\"\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */ class InvalidLengthError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value){\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: [\n                \"It must be an even length.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.InvalidLengthError\"\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */ class SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ givenSize, maxSize }){\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.SizeOverflowError\"\n        });\n    }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */ class SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ offset, position, size }){\n        super(`Slice ${position === \"start\" ? \"starting\" : \"ending\"} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.SliceOffsetOutOfBoundsError\"\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */ class SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ size, targetSize, type }){\n        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.SizeExceedsPaddingSizeError\"\n        });\n    }\n} //# sourceMappingURL=Hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUN0QjtBQUNFO0FBQ2dCO0FBQ1I7QUFDWjtBQUNsQyxNQUFNTSxVQUFVLFdBQVcsR0FBRyxJQUFJQztBQUNsQyxNQUFNQyxRQUFRLFdBQVcsR0FBR0MsTUFBTUMsSUFBSSxDQUFDO0lBQUVDLFFBQVE7QUFBSSxHQUFHLENBQUNDLElBQUlDLElBQU1BLEVBQUVDLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRztBQUM5Rjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxTQUFTQyxPQUFPQyxLQUFLLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RDLE1BQU0sRUFBRUMsU0FBUyxLQUFLLEVBQUUsR0FBR0Q7SUFDM0IsSUFBSSxDQUFDRCxPQUNELE1BQU0sSUFBSUcsb0JBQW9CSDtJQUNsQyxJQUFJLE9BQU9BLFVBQVUsVUFDakIsTUFBTSxJQUFJRyxvQkFBb0JIO0lBQ2xDLElBQUlFLFFBQVE7UUFDUixJQUFJLENBQUMsbUJBQW1CRSxJQUFJLENBQUNKLFFBQ3pCLE1BQU0sSUFBSUsscUJBQXFCTDtJQUN2QztJQUNBLElBQUksQ0FBQ0EsTUFBTU0sVUFBVSxDQUFDLE9BQ2xCLE1BQU0sSUFBSUQscUJBQXFCTDtBQUN2QztBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTTyxPQUFPLEdBQUdDLE1BQU07SUFDNUIsT0FBTyxDQUFDLEVBQUUsRUFBRUEsT0FBT0MsTUFBTSxDQUFDLENBQUNDLEtBQUtDLElBQU1ELE1BQU1DLEVBQUVDLE9BQU8sQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDO0FBQzFFO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FDTSxTQUFTbkIsS0FBS08sS0FBSztJQUN0QixJQUFJQSxpQkFBaUJhLFlBQ2pCLE9BQU9DLFVBQVVkO0lBQ3JC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LGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVjNFLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7OztDQVVDLEdBQ00sTUFBTXFGLG9DQUFvQ3BHLGlEQUFnQjtJQUM3RHFGLFlBQVksRUFBRW5ELElBQUksRUFBRW1FLFVBQVUsRUFBRUMsSUFBSSxFQUFHLENBQUU7UUFDckMsS0FBSyxDQUFDLENBQUMsRUFBRUEsS0FBS0MsTUFBTSxDQUFDLEdBQUdDLFdBQVcsR0FBRyxFQUFFRixLQUNuQ3hDLEtBQUssQ0FBQyxHQUNOMkMsV0FBVyxHQUFHLFNBQVMsRUFBRXZFLEtBQUssNEJBQTRCLEVBQUVtRSxXQUFXLElBQUksQ0FBQztRQUNqRmYsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWM0UsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYzQzMzctZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hleC5qcz8wNDcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVxdWFsQnl0ZXMgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsX2J5dGVzIGZyb20gJy4vaW50ZXJuYWwvYnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9oZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuY29uc3QgZW5jb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBoZXhlcyA9IC8qI19fUFVSRV9fKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfdiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEFzc2VydHMgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5hc3NlcnQoJ2FiYycpXG4gKiAvLyBAZXJyb3I6IEludmFsaWRIZXhWYWx1ZVR5cGVFcnJvcjpcbiAqIC8vIEBlcnJvcjogVmFsdWUgYFwiYWJjXCJgIG9mIHR5cGUgYHN0cmluZ2AgaXMgYW4gaW52YWxpZCBoZXggdHlwZS5cbiAqIC8vIEBlcnJvcjogSGV4IHR5cGVzIG11c3QgYmUgcmVwcmVzZW50ZWQgYXMgYFwiMHhcXCR7c3RyaW5nfVwiYC5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhc3NlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFR5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAoIS9eMHhbMC05YS1mQS1GXSokLy50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VmFsdWVFcnJvcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghdmFsdWUuc3RhcnRzV2l0aCgnMHgnKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhWYWx1ZUVycm9yKHZhbHVlKTtcbn1cbi8qKlxuICogQ29uY2F0ZW5hdGVzIHR3byBvciBtb3JlIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5jb25jYXQoJzB4MTIzJywgJzB4NDU2JylcbiAqIC8vIEBsb2c6ICcweDEyMzQ1NidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIHJldHVybiBgMHgke3ZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgeC5yZXBsYWNlKCcweCcsICcnKSwgJycpfWA7XG59XG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBmcm9tIGEgaGV4IHN0cmluZyBvciB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIDo6OnRpcFxuICpcbiAqIFRvIGluc3RhbnRpYXRlIGZyb20gYSAqKkJvb2xlYW4qKiwgKipTdHJpbmcqKiwgb3IgKipOdW1iZXIqKiwgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gYEhleC5mcm9tQm9vbGVhbmBcbiAqXG4gKiAtIGBIZXguZnJvbVN0cmluZ2BcbiAqXG4gKiAtIGBIZXguZnJvbU51bWJlcmBcbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbSgnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICpcbiAqIEhleC5mcm9tKEJ5dGVzLmZyb20oWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBmcm9tQnl0ZXModmFsdWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZyb21CeXRlcyhuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIGJvb2xlYW4gaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tQm9vbGVhbih0cnVlKVxuICogLy8gQGxvZzogJzB4MSdcbiAqXG4gKiBIZXguZnJvbUJvb2xlYW4oZmFsc2UpXG4gKiAvLyBAbG9nOiAnMHgwJ1xuICpcbiAqIEhleC5mcm9tQm9vbGVhbih0cnVlLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJvb2xlYW4gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJvb2xlYW4odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGhleCA9IGAweCR7TnVtYmVyKHZhbHVlKX1gO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tQnl0ZXMoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyBAbG9nOiAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXModmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBzdHJpbmcgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdHJpbmcgKz0gaGV4ZXNbdmFsdWVbaV1dO1xuICAgIGNvbnN0IGhleCA9IGAweCR7c3RyaW5nfWA7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgICAgICByZXR1cm4gcGFkUmlnaHQoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgbnVtYmVyIG9yIGJpZ2ludCBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21OdW1iZXIoNDIwKVxuICogLy8gQGxvZzogJzB4MWE0J1xuICpcbiAqIEhleC5mcm9tTnVtYmVyKDQyMCwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFhNCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgb3IgYmlnaW50IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmVkLCBzaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlXyA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgbGV0IG1heFZhbHVlO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGlmIChzaWduZWQpXG4gICAgICAgICAgICBtYXhWYWx1ZSA9ICgxbiA8PCAoQmlnSW50KHNpemUpICogOG4gLSAxbikpIC0gMW47XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1heFZhbHVlID0gMm4gKiogKEJpZ0ludChzaXplKSAqIDhuKSAtIDFuO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1heFZhbHVlID0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICB9XG4gICAgY29uc3QgbWluVmFsdWUgPSB0eXBlb2YgbWF4VmFsdWUgPT09ICdiaWdpbnQnICYmIHNpZ25lZCA/IC1tYXhWYWx1ZSAtIDFuIDogMDtcbiAgICBpZiAoKG1heFZhbHVlICYmIHZhbHVlXyA+IG1heFZhbHVlKSB8fCB2YWx1ZV8gPCBtaW5WYWx1ZSkge1xuICAgICAgICBjb25zdCBzdWZmaXggPSB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnID8gJ24nIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yKHtcbiAgICAgICAgICAgIG1heDogbWF4VmFsdWUgPyBgJHttYXhWYWx1ZX0ke3N1ZmZpeH1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWluOiBgJHttaW5WYWx1ZX0ke3N1ZmZpeH1gLFxuICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIHZhbHVlOiBgJHt2YWx1ZX0ke3N1ZmZpeH1gLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSAoc2lnbmVkICYmIHZhbHVlXyA8IDAgPyBCaWdJbnQuYXNVaW50TihzaXplICogOCwgQmlnSW50KHZhbHVlXykpIDogdmFsdWVfKS50b1N0cmluZygxNik7XG4gICAgY29uc3QgaGV4ID0gYDB4JHtzdHJpbmdWYWx1ZX1gO1xuICAgIGlmIChzaXplKVxuICAgICAgICByZXR1cm4gcGFkTGVmdChoZXgsIHNpemUpO1xuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICogSGV4LmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScpXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKlxuICogSGV4LmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBmcm9tQnl0ZXMoZW5jb2Rlci5lbmNvZGUodmFsdWUpLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWVzIGFyZSBlcXVhbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5pc0VxdWFsKCcweGRlYWRiZWVmJywgJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEhleC5pc0VxdWFsKCcweGRhJywgJzB4YmEnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXhBIC0gVGhlIGZpcnN0IHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBoZXhCIC0gVGhlIHNlY29uZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3byB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWVzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsKGhleEEsIGhleEIpIHtcbiAgICByZXR1cm4gZXF1YWxCeXRlcyhCeXRlcy5mcm9tSGV4KGhleEEpLCBCeXRlcy5mcm9tSGV4KGhleEIpKTtcbn1cbi8qKlxuICogUGFkcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byB0aGUgbGVmdCB3aXRoIHplcm8gYnl0ZXMgdW50aWwgaXQgcmVhY2hlcyB0aGUgZ2l2ZW4gYHNpemVgIChkZWZhdWx0OiAzMiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgucGFkTGVmdCgnMHgxMjM0JywgNClcbiAqIC8vIEBsb2c6ICcweDAwMDAxMjM0J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplIChpbiBieXRlcykgb2YgdGhlIG91dHB1dCBoZXggdmFsdWUuXG4gKiBAcmV0dXJucyBUaGUgcGFkZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZExlZnQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ2xlZnQnLCBzaXplIH0pO1xufVxuLyoqXG4gKiBQYWRzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRoZSByaWdodCB3aXRoIHplcm8gYnl0ZXMgdW50aWwgaXQgcmVhY2hlcyB0aGUgZ2l2ZW4gYHNpemVgIChkZWZhdWx0OiAzMiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgucGFkUmlnaHQoJzB4MTIzNCcsIDQpXG4gKiAvLyBAbG9nOiAnMHgxMjM0MDAwMCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gcGFkLlxuICogQHBhcmFtIHNpemUgLSBUaGUgc2l6ZSAoaW4gYnl0ZXMpIG9mIHRoZSBvdXRwdXQgaGV4IHZhbHVlLlxuICogQHJldHVybnMgVGhlIHBhZGRlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRSaWdodCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAncmlnaHQnLCBzaXplIH0pO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgaGV4ID0gSGV4LnJhbmRvbSgzMilcbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIFJhbmRvbSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20obGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhCeXRlcy5yYW5kb20obGVuZ3RoKSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBzZWN0aW9uIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBnaXZlbiBhIHN0YXJ0L2VuZCBieXRlcyBvZmZzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguc2xpY2UoJzB4MDEyMzQ1Njc4OScsIDEsIDQpXG4gKiAvLyBAbG9nOiAnMHgyMzQ1NjcnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHNsaWNlLlxuICogQHBhcmFtIHN0YXJ0IC0gVGhlIHN0YXJ0IG9mZnNldCAoaW4gYnl0ZXMpLlxuICogQHBhcmFtIGVuZCAtIFRoZSBlbmQgb2Zmc2V0IChpbiBieXRlcykuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2xpY2VkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlKHZhbHVlLCBzdGFydCwgZW5kLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCB9ID0gb3B0aW9ucztcbiAgICBpbnRlcm5hbC5hc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpO1xuICAgIGNvbnN0IHZhbHVlXyA9IGAweCR7dmFsdWVcbiAgICAgICAgLnJlcGxhY2UoJzB4JywgJycpXG4gICAgICAgIC5zbGljZSgoc3RhcnQgPz8gMCkgKiAyLCAoZW5kID8/IHZhbHVlLmxlbmd0aCkgKiAyKX1gO1xuICAgIGlmIChzdHJpY3QpXG4gICAgICAgIGludGVybmFsLmFzc2VydEVuZE9mZnNldCh2YWx1ZV8sIHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiB2YWx1ZV87XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgc2l6ZSBvZiBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSAoaW4gYnl0ZXMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnNpemUoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogNFxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBnZXQgdGhlIHNpemUgb2YuXG4gKiBAcmV0dXJucyBUaGUgc2l6ZSBvZiB0aGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIChpbiBieXRlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcbn1cbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRyaW1MZWZ0KCcweDAwMDAwMDAwZGVhZGJlZWYnKVxuICogLy8gQGxvZzogJzB4ZGVhZGJlZWYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRyaW0uXG4gKiBAcmV0dXJucyBUaGUgdHJpbW1lZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltTGVmdCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ2xlZnQnIH0pO1xufVxuLyoqXG4gKiBUcmltcyB0cmFpbGluZyB6ZXJvcyBmcm9tIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRyaW1SaWdodCgnMHhkZWFkYmVlZjAwMDAwMDAwJylcbiAqIC8vIEBsb2c6ICcweGRlYWRiZWVmJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byB0cmltLlxuICogQHJldHVybnMgVGhlIHRyaW1tZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVJpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAncmlnaHQnIH0pO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBCaWdJbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9CaWdJbnQoJzB4MWE0JylcbiAqIC8vIEBsb2c6IDQyMG5cbiAqXG4gKiBIZXgudG9CaWdJbnQoJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFhNCcsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IDQyMG5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIEJpZ0ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduZWQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuc2l6ZSlcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgY29uc3QgdmFsdWUgPSBCaWdJbnQoaGV4KTtcbiAgICBpZiAoIXNpZ25lZClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHNpemUgPSAoaGV4Lmxlbmd0aCAtIDIpIC8gMjtcbiAgICBjb25zdCBtYXhfdW5zaWduZWQgPSAoMW4gPDwgKEJpZ0ludChzaXplKSAqIDhuKSkgLSAxbjtcbiAgICBjb25zdCBtYXhfc2lnbmVkID0gbWF4X3Vuc2lnbmVkID4+IDFuO1xuICAgIGlmICh2YWx1ZSA8PSBtYXhfc2lnbmVkKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlIC0gbWF4X3Vuc2lnbmVkIC0gMW47XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9Cb29sZWFuKCcweDAxJylcbiAqIC8vIEBsb2c6IHRydWVcbiAqXG4gKiBIZXgudG9Cb29sZWFuKCcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBib29sZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Cb29sZWFuKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMuc2l6ZSlcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgY29uc3QgaGV4XyA9IHRyaW1MZWZ0KGhleCk7XG4gICAgaWYgKGhleF8gPT09ICcweCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaGV4XyA9PT0gJzB4MScpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHRocm93IG5ldyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yKGhleCk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gSGV4LnRvQnl0ZXMoJzB4NDg2NTZjNmM2ZjIwNzc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KGhleCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIG51bWJlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b051bWJlcignMHgxYTQnKVxuICogLy8gQGxvZzogNDIwXG4gKlxuICogSGV4LnRvTnVtYmVyKCcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxYTQnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiA0MjBcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIG51bWJlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduZWQsIHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFzaWduZWQgJiYgIXNpemUpXG4gICAgICAgIHJldHVybiBOdW1iZXIoaGV4KTtcbiAgICByZXR1cm4gTnVtYmVyKHRvQmlnSW50KGhleCwgb3B0aW9ucykpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9TdHJpbmcoJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6ICdIZWxsbyB3b3JsZCEnXG4gKlxuICogSGV4LnRvU3RyaW5nKCcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCB7XG4gKiAgc2l6ZTogMzIsXG4gKiB9KVxuICogLy8gQGxvZzogJ0hlbGxvIHdvcmxkJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzID0gQnl0ZXMuZnJvbUhleChoZXgpO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGludGVybmFsX2J5dGVzLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICBieXRlcyA9IEJ5dGVzLnRyaW1SaWdodChieXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudmFsaWRhdGUoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEhleC52YWxpZGF0ZShCeXRlcy5mcm9tKFsxLCAyLCAzXSkpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHtAbGluayBveCNIZXguSGV4fSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQodmFsdWUsIHsgc3RyaWN0IH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgaW50ZWdlciBpcyBvdXQgb2YgcmFuZ2UsIGFuZCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBoZXggdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbU51bWJlcig0MjAxODI3Mzg5MTI3MzEyODM3MTI5MzcxMjkpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yOiBOdW1iZXIgXFxgNC4yMDE4MjczODkxMjczMTI2ZSsyNlxcYCBpcyBub3QgaW4gc2FmZSB1bnNpZ25lZCBpbnRlZ2VyIHJhbmdlIChgMGAgdG8gYDkwMDcxOTkyNTQ3NDA5OTFgKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtYXgsIG1pbiwgc2lnbmVkLCBzaXplLCB2YWx1ZSwgfSkge1xuICAgICAgICBzdXBlcihgTnVtYmVyIFxcYCR7dmFsdWV9XFxgIGlzIG5vdCBpbiBzYWZlJHtzaXplID8gYCAke3NpemUgKiA4fS1iaXRgIDogJyd9JHtzaWduZWQgPyAnIHNpZ25lZCcgOiAnIHVuc2lnbmVkJ30gaW50ZWdlciByYW5nZSAke21heCA/IGAoXFxgJHttaW59XFxgIHRvIFxcYCR7bWF4fVxcYClgIDogYChhYm92ZSBcXGAke21pbn1cXGApYH1gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBoZXggdmFsdWUgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4YScpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnZhbGlkSGV4Qm9vbGVhbkVycm9yOiBIZXggdmFsdWUgYFwiMHhhXCJgIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uXG4gKiAvLyBAZXJyb3I6IFRoZSBoZXggdmFsdWUgbXVzdCBiZSBgXCIweDBcImAgKGZhbHNlKSBvciBgXCIweDFcImAgKHRydWUpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaGV4KSB7XG4gICAgICAgIHN1cGVyKGBIZXggdmFsdWUgXFxgXCIke2hleH1cIlxcYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdUaGUgaGV4IHZhbHVlIG11c3QgYmUgYFwiMHgwXCJgIChmYWxzZSkgb3IgYFwiMHgxXCJgICh0cnVlKS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZEhleEJvb2xlYW5FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHR5cGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguYXNzZXJ0KDEpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnZhbGlkSGV4VHlwZUVycm9yOiBWYWx1ZSBgMWAgb2YgdHlwZSBgbnVtYmVyYCBpcyBhbiBpbnZhbGlkIGhleCB0eXBlLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSGV4VHlwZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IEpzb24uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlfVxcYCBvZiB0eXBlIFxcYCR7dHlwZW9mIHZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIGhleCB0eXBlLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydIZXggdHlwZXMgbXVzdCBiZSByZXByZXNlbnRlZCBhcyBgXCIweCR7c3RyaW5nfVwiYC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZEhleFR5cGVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgaGV4IHZhbHVlIGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguYXNzZXJ0KCcweDAxMjM0NTY3ODlhYmNkZWZnJylcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRIZXhWYWx1ZUVycm9yOiBWYWx1ZSBgMHgwMTIzNDU2Nzg5YWJjZGVmZ2AgaXMgYW4gaW52YWxpZCBoZXggdmFsdWUuXG4gKiAvLyBAZXJyb3I6IEhleCB2YWx1ZXMgbXVzdCBzdGFydCB3aXRoIGBcIjB4XCJgIGFuZCBjb250YWluIG9ubHkgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoMC05LCBhLWYsIEEtRikuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRIZXhWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgaGV4IHZhbHVlLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdIZXggdmFsdWVzIG11c3Qgc3RhcnQgd2l0aCBgXCIweFwiYCBhbmQgY29udGFpbiBvbmx5IGhleGFkZWNpbWFsIGNoYXJhY3RlcnMgKDAtOSwgYS1mLCBBLUYpLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4VmFsdWVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgaGV4IHZhbHVlIGlzIGFuIG9kZCBsZW5ndGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmZyb21IZXgoJzB4YWJjZGUnKVxuICogLy8gQGVycm9yOiBIZXguSW52YWxpZExlbmd0aEVycm9yOiBIZXggdmFsdWUgYFwiMHhhYmNkZVwiYCBpcyBhbiBvZGQgbGVuZ3RoICg1IG5pYmJsZXMpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkTGVuZ3RoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgSGV4IHZhbHVlIFxcYFwiJHt2YWx1ZX1cIlxcYCBpcyBhbiBvZGQgbGVuZ3RoICgke3ZhbHVlLmxlbmd0aCAtIDJ9IG5pYmJsZXMpLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydJdCBtdXN0IGJlIGFuIGV2ZW4gbGVuZ3RoLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkTGVuZ3RoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHNpemUgb2YgdGhlIHZhbHVlIGV4Y2VlZHMgdGhlIGV4cGVjdGVkIG1heCBzaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScsIHsgc2l6ZTogOCB9KVxuICogLy8gQGVycm9yOiBIZXguU2l6ZU92ZXJmbG93RXJyb3I6IFNpemUgY2Fubm90IGV4Y2VlZCBgOGAgYnl0ZXMuIEdpdmVuIHNpemU6IGAxMmAgYnl0ZXMuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVPdmVyZmxvd0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBnaXZlblNpemUsIG1heFNpemUgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBjYW5ub3QgZXhjZWVkIFxcYCR7bWF4U2l6ZX1cXGAgYnl0ZXMuIEdpdmVuIHNpemU6IFxcYCR7Z2l2ZW5TaXplfVxcYCBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5TaXplT3ZlcmZsb3dFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgc2xpY2Ugb2Zmc2V0IGV4Y2VlZHMgdGhlIGJvdW5kcyBvZiB0aGUgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguc2xpY2UoJzB4MDEyMzQ1Njc4OScsIDYpXG4gKiAvLyBAZXJyb3I6IEhleC5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3I6IFNsaWNlIHN0YXJ0aW5nIGF0IG9mZnNldCBgNmAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogYDVgKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQsIHBvc2l0aW9uLCBzaXplLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTbGljZSAke3Bvc2l0aW9uID09PSAnc3RhcnQnID8gJ3N0YXJ0aW5nJyA6ICdlbmRpbmcnfSBhdCBvZmZzZXQgXFxgJHtvZmZzZXR9XFxgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IFxcYCR7c2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgc2l6ZSBvZiB0aGUgdmFsdWUgZXhjZWVkcyB0aGUgcGFkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgucGFkTGVmdCgnMHgxYTRlMTJhNDVhMjEzMjMxMjNhYWE4N2E4OTdhODk3YTg5OGE2NTY3YTU3OGE4NjdhOTg3NzhhNjY3YTg1YTg3NWE4N2E2YTc4N2E2NWE2NzVhNmE5JywgMzIpXG4gKiAvLyBAZXJyb3I6IEhleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3I6IEhleCBzaXplIChgNDNgKSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoYDMyYCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2l6ZSwgdGFyZ2V0U2l6ZSwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgJHt0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7dHlwZVxuICAgICAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKX0gc2l6ZSAoXFxgJHtzaXplfVxcYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKFxcYCR7dGFyZ2V0U2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJlcXVhbEJ5dGVzIiwiQnl0ZXMiLCJFcnJvcnMiLCJpbnRlcm5hbF9ieXRlcyIsImludGVybmFsIiwiSnNvbiIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImhleGVzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiX3YiLCJpIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImFzc2VydCIsInZhbHVlIiwib3B0aW9ucyIsInN0cmljdCIsIkludmFsaWRIZXhUeXBlRXJyb3IiLCJ0ZXN0IiwiSW52YWxpZEhleFZhbHVlRXJyb3IiLCJzdGFydHNXaXRoIiwiY29uY2F0IiwidmFsdWVzIiwicmVkdWNlIiwiYWNjIiwieCIsInJlcGxhY2UiLCJVaW50OEFycmF5IiwiZnJvbUJ5dGVzIiwiaXNBcnJheSIsImZyb21Cb29sZWFuIiwiaGV4IiwiTnVtYmVyIiwic2l6ZSIsImFzc2VydFNpemUiLCJwYWRMZWZ0Iiwic3RyaW5nIiwicGFkUmlnaHQiLCJmcm9tTnVtYmVyIiwic2lnbmVkIiwidmFsdWVfIiwiQmlnSW50IiwibWF4VmFsdWUiLCJNQVhfU0FGRV9JTlRFR0VSIiwibWluVmFsdWUiLCJzdWZmaXgiLCJJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yIiwibWF4IiwidW5kZWZpbmVkIiwibWluIiwic3RyaW5nVmFsdWUiLCJhc1VpbnROIiwiZnJvbVN0cmluZyIsImVuY29kZSIsImlzRXF1YWwiLCJoZXhBIiwiaGV4QiIsImZyb21IZXgiLCJwYWQiLCJkaXIiLCJyYW5kb20iLCJzbGljZSIsInN0YXJ0IiwiZW5kIiwiYXNzZXJ0U3RhcnRPZmZzZXQiLCJhc3NlcnRFbmRPZmZzZXQiLCJNYXRoIiwiY2VpbCIsInRyaW1MZWZ0IiwidHJpbSIsInRyaW1SaWdodCIsInRvQmlnSW50IiwibWF4X3Vuc2lnbmVkIiwibWF4X3NpZ25lZCIsInRvQm9vbGVhbiIsImhleF8iLCJJbnZhbGlkSGV4Qm9vbGVhbkVycm9yIiwidG9CeXRlcyIsInRvTnVtYmVyIiwiYnl0ZXMiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInZhbGlkYXRlIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm1ldGFNZXNzYWdlcyIsInN0cmluZ2lmeSIsIkludmFsaWRMZW5ndGhFcnJvciIsIlNpemVPdmVyZmxvd0Vycm9yIiwiZ2l2ZW5TaXplIiwibWF4U2l6ZSIsIlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciIsIm9mZnNldCIsInBvc2l0aW9uIiwiU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIiwidGFyZ2V0U2l6ZSIsInR5cGUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Json.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\nconst bigIntSuffix = \"#__bigint\";\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */ function parse(string, reviver) {\n    return JSON.parse(string, (key, value_)=>{\n        const value = value_;\n        if (typeof value === \"string\" && value.endsWith(bigIntSuffix)) return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === \"function\" ? reviver(key, value) : value;\n    });\n}\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */ function stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value)=>{\n        if (typeof replacer === \"function\") return replacer(key, value);\n        if (typeof value === \"bigint\") return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n} //# sourceMappingURL=Json.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFNQSxlQUFlO0FBQ3JCOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVNDLE1BQU1DLE1BQU0sRUFBRUMsT0FBTztJQUNqQyxPQUFPQyxLQUFLSCxLQUFLLENBQUNDLFFBQVEsQ0FBQ0csS0FBS0M7UUFDNUIsTUFBTUMsUUFBUUQ7UUFDZCxJQUFJLE9BQU9DLFVBQVUsWUFBWUEsTUFBTUMsUUFBUSxDQUFDUixlQUM1QyxPQUFPUyxPQUFPRixNQUFNRyxLQUFLLENBQUMsR0FBRyxDQUFDVixhQUFhVyxNQUFNO1FBQ3JELE9BQU8sT0FBT1IsWUFBWSxhQUFhQSxRQUFRRSxLQUFLRSxTQUFTQTtJQUNqRTtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVNLLFVBQVVMLEtBQUssRUFBRU0sUUFBUSxFQUFFQyxLQUFLO0lBQzVDLE9BQU9WLEtBQUtRLFNBQVMsQ0FBQ0wsT0FBTyxDQUFDRixLQUFLRTtRQUMvQixJQUFJLE9BQU9NLGFBQWEsWUFDcEIsT0FBT0EsU0FBU1IsS0FBS0U7UUFDekIsSUFBSSxPQUFPQSxVQUFVLFVBQ2pCLE9BQU9BLE1BQU1RLFFBQVEsS0FBS2Y7UUFDOUIsT0FBT087SUFDWCxHQUFHTztBQUNQLEVBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjNDMzNy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvSnNvbi5qcz80ZTg3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJpZ0ludFN1ZmZpeCA9ICcjX19iaWdpbnQnO1xuLyoqXG4gKiBQYXJzZXMgYSBKU09OIHN0cmluZywgd2l0aCBzdXBwb3J0IGZvciBgYmlnaW50YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEpzb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBqc29uID0gSnNvbi5wYXJzZSgne1wiZm9vXCI6XCJiYXJcIixcImJhelwiOlwiNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjAjX19iaWdpbnRcIn0nKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBmb286ICdiYXInLFxuICogLy8gQGxvZzogICBiYXo6IDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwblxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHN0cmluZyAtIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAqIEBwYXJhbSByZXZpdmVyIC0gQSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIHJlc3VsdHMuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uoc3RyaW5nLCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyaW5nLCAoa2V5LCB2YWx1ZV8pID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZV87XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKGJpZ0ludFN1ZmZpeCkpXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlLnNsaWNlKDAsIC1iaWdJbnRTdWZmaXgubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IHJldml2ZXIoa2V5LCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9KTtcbn1cbi8qKlxuICogU3RyaW5naWZpZXMgYSB2YWx1ZSB0byBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiwgd2l0aCBzdXBwb3J0IGZvciBgYmlnaW50YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEpzb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBqc29uID0gSnNvbi5zdHJpbmdpZnkoe1xuICogICBmb286ICdiYXInLFxuICogICBiYXo6IDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwbixcbiAqIH0pXG4gKiAvLyBAbG9nOiAne1wiZm9vXCI6XCJiYXJcIixcImJhelwiOlwiNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjAjX19iaWdpbnRcIn0nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3RyaW5naWZ5LlxuICogQHBhcmFtIHJlcGxhY2VyIC0gQSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIHJlc3VsdHMuIEl0IGlzIHBhc3NlZCB0aGUga2V5IGFuZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHksIGFuZCBtdXN0IHJldHVybiB0aGUgdmFsdWUgdG8gYmUgdXNlZCBpbiB0aGUgSlNPTiBzdHJpbmcuIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYCwgdGhlIHByb3BlcnR5IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIEpTT04gc3RyaW5nLlxuICogQHBhcmFtIHNwYWNlIC0gQSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgZGV0ZXJtaW5lcyB0aGUgaW5kZW50YXRpb24gb2YgdGhlIEpTT04gc3RyaW5nLiBJZiBpdCBpcyBhIG51bWJlciwgaXQgaW5kaWNhdGVzIHRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIHVzZSBhcyBpbmRlbnRhdGlvbjsgaWYgaXQgaXMgYSBzdHJpbmcgKGUuZy4gYCdcXHQnYCksIGl0IHVzZXMgdGhlIHN0cmluZyBhcyB0aGUgaW5kZW50YXRpb24gY2hhcmFjdGVyLlxuICogQHJldHVybnMgVGhlIEpTT04gc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkgKyBiaWdJbnRTdWZmaXg7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCBzcGFjZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Kc29uLmpzLm1hcCJdLCJuYW1lcyI6WyJiaWdJbnRTdWZmaXgiLCJwYXJzZSIsInN0cmluZyIsInJldml2ZXIiLCJKU09OIiwia2V5IiwidmFsdWVfIiwidmFsdWUiLCJlbmRzV2l0aCIsIkJpZ0ludCIsInNsaWNlIiwibGVuZ3RoIiwic3RyaW5naWZ5IiwicmVwbGFjZXIiLCJzcGFjZSIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/PublicKey.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/PublicKey.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidCompressedPrefixError: () => (/* binding */ InvalidCompressedPrefixError),\n/* harmony export */   InvalidError: () => (/* binding */ InvalidError),\n/* harmony export */   InvalidPrefixError: () => (/* binding */ InvalidPrefixError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidUncompressedPrefixError: () => (/* binding */ InvalidUncompressedPrefixError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   compress: () => (/* binding */ compress),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */ function assert(publicKey, options = {}) {\n    const { compressed } = options;\n    const { prefix, x, y } = publicKey;\n    // Uncompressed\n    if (compressed === false || typeof x === \"bigint\" && typeof y === \"bigint\") {\n        if (prefix !== 4) throw new InvalidPrefixError({\n            prefix,\n            cause: new InvalidUncompressedPrefixError()\n        });\n        return;\n    }\n    // Compressed\n    if (compressed === true || typeof x === \"bigint\" && typeof y === \"undefined\") {\n        if (prefix !== 3 && prefix !== 2) throw new InvalidPrefixError({\n            prefix,\n            cause: new InvalidCompressedPrefixError()\n        });\n        return;\n    }\n    // Unknown/invalid\n    throw new InvalidError({\n        publicKey\n    });\n}\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */ function compress(publicKey) {\n    const { x, y } = publicKey;\n    return {\n        prefix: y % 2n === 0n ? 2 : 3,\n        x\n    };\n}\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */ function from(value) {\n    const publicKey = (()=>{\n        if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.validate(value)) return fromHex(value);\n        if (_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.validate(value)) return fromBytes(value);\n        const { prefix, x, y } = value;\n        if (typeof x === \"bigint\" && typeof y === \"bigint\") return {\n            prefix: prefix ?? 0x04,\n            x,\n            y\n        };\n        return {\n            prefix,\n            x\n        };\n    })();\n    assert(publicKey);\n    return publicKey;\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */ function fromBytes(publicKey) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(publicKey));\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */ function fromHex(publicKey) {\n    if (publicKey.length !== 132 && publicKey.length !== 130 && publicKey.length !== 68) throw new InvalidSerializedSizeError({\n        publicKey\n    });\n    if (publicKey.length === 130) {\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 32));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 32, 64));\n        return {\n            prefix: 4,\n            x,\n            y\n        };\n    }\n    if (publicKey.length === 132) {\n        const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 33, 65));\n        return {\n            prefix,\n            x,\n            y\n        };\n    }\n    const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n    const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n    return {\n        prefix,\n        x\n    };\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */ function toBytes(publicKey, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(toHex(publicKey, options));\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */ function toHex(publicKey, options = {}) {\n    assert(publicKey);\n    const { prefix, x, y } = publicKey;\n    const { includePrefix = true } = options;\n    const publicKey_ = _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(includePrefix ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(prefix, {\n        size: 1\n    }) : \"0x\", _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(x, {\n        size: 32\n    }), // If the public key is not compressed, add the y coordinate.\n    typeof y === \"bigint\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(y, {\n        size: 32\n    }) : \"0x\");\n    return publicKey_;\n}\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */ function validate(publicKey, options = {}) {\n    try {\n        assert(publicKey, options);\n        return true;\n    } catch (_error) {\n        return false;\n    }\n}\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */ class InvalidError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }){\n        super(`Value \\`${_Json_js__WEBPACK_IMPORTED_MODULE_3__.stringify(publicKey)}\\` is not a valid public key.`, {\n            metaMessages: [\n                \"Public key must contain:\",\n                \"- an `x` and `prefix` value (compressed)\",\n                \"- an `x`, `y`, and `prefix` value (uncompressed)\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidError\"\n        });\n    }\n}\n/** Thrown when a public key has an invalid prefix. */ class InvalidPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ prefix, cause }){\n        super(`Prefix \"${prefix}\" is invalid.`, {\n            cause\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidPrefixError\"\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for a compressed public key. */ class InvalidCompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor(){\n        super(\"Prefix must be 2 or 3 for compressed public keys.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidCompressedPrefixError\"\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */ class InvalidUncompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor(){\n        super(\"Prefix must be 4 for uncompressed public keys.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidUncompressedPrefixError\"\n        });\n    }\n}\n/** Thrown when the public key has an invalid serialized size. */ class InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }){\n        super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n            metaMessages: [\n                \"Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).\",\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.from(publicKey))} bytes.`\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidSerializedSizeError\"\n        });\n    }\n} //# sourceMappingURL=PublicKey.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1B1YmxpY0tleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNFO0FBQ047QUFDRTtBQUNsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ00sU0FBU0ksT0FBT0MsU0FBUyxFQUFFQyxVQUFVLENBQUMsQ0FBQztJQUMxQyxNQUFNLEVBQUVDLFVBQVUsRUFBRSxHQUFHRDtJQUN2QixNQUFNLEVBQUVFLE1BQU0sRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBR0w7SUFDekIsZUFBZTtJQUNmLElBQUlFLGVBQWUsU0FDZCxPQUFPRSxNQUFNLFlBQVksT0FBT0MsTUFBTSxVQUFXO1FBQ2xELElBQUlGLFdBQVcsR0FDWCxNQUFNLElBQUlHLG1CQUFtQjtZQUN6Qkg7WUFDQUksT0FBTyxJQUFJQztRQUNmO1FBQ0o7SUFDSjtJQUNBLGFBQWE7SUFDYixJQUFJTixlQUFlLFFBQ2QsT0FBT0UsTUFBTSxZQUFZLE9BQU9DLE1BQU0sYUFBYztRQUNyRCxJQUFJRixXQUFXLEtBQUtBLFdBQVcsR0FDM0IsTUFBTSxJQUFJRyxtQkFBbUI7WUFDekJIO1lBQ0FJLE9BQU8sSUFBSUU7UUFDZjtRQUNKO0lBQ0o7SUFDQSxrQkFBa0I7SUFDbEIsTUFBTSxJQUFJQyxhQUFhO1FBQUVWO0lBQVU7QUFDdkM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNNLFNBQVNXLFNBQVNYLFNBQVM7SUFDOUIsTUFBTSxFQUFFSSxDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHTDtJQUNqQixPQUFPO1FBQ0hHLFFBQVFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxJQUFJO1FBQzVCRDtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQ0MsR0FDTSxTQUFTUSxLQUFLQyxLQUFLO0lBQ3RCLE1BQU1iLFlBQVksQ0FBQztRQUNmLElBQUlILDZDQUFZLENBQUNnQixRQUNiLE9BQU9FLFFBQVFGO1FBQ25CLElBQUlsQiwrQ0FBYyxDQUFDa0IsUUFDZixPQUFPRyxVQUFVSDtRQUNyQixNQUFNLEVBQUVWLE1BQU0sRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBR1E7UUFDekIsSUFBSSxPQUFPVCxNQUFNLFlBQVksT0FBT0MsTUFBTSxVQUN0QyxPQUFPO1lBQUVGLFFBQVFBLFVBQVU7WUFBTUM7WUFBR0M7UUFBRTtRQUMxQyxPQUFPO1lBQUVGO1lBQVFDO1FBQUU7SUFDdkI7SUFDQUwsT0FBT0M7SUFDUCxPQUFPQTtBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVNnQixVQUFVaEIsU0FBUztJQUMvQixPQUFPZSxRQUFRbEIsOENBQWEsQ0FBQ0c7QUFDakM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBOEJDLEdBQ00sU0FBU2UsUUFBUWYsU0FBUztJQUM3QixJQUFJQSxVQUFVaUIsTUFBTSxLQUFLLE9BQ3JCakIsVUFBVWlCLE1BQU0sS0FBSyxPQUNyQmpCLFVBQVVpQixNQUFNLEtBQUssSUFDckIsTUFBTSxJQUFJQywyQkFBMkI7UUFBRWxCO0lBQVU7SUFDckQsSUFBSUEsVUFBVWlCLE1BQU0sS0FBSyxLQUFLO1FBQzFCLE1BQU1iLElBQUllLE9BQU90QiwwQ0FBUyxDQUFDRyxXQUFXLEdBQUc7UUFDekMsTUFBTUssSUFBSWMsT0FBT3RCLDBDQUFTLENBQUNHLFdBQVcsSUFBSTtRQUMxQyxPQUFPO1lBQ0hHLFFBQVE7WUFDUkM7WUFDQUM7UUFDSjtJQUNKO0lBQ0EsSUFBSUwsVUFBVWlCLE1BQU0sS0FBSyxLQUFLO1FBQzFCLE1BQU1kLFNBQVNrQixPQUFPeEIsMENBQVMsQ0FBQ0csV0FBVyxHQUFHO1FBQzlDLE1BQU1JLElBQUllLE9BQU90QiwwQ0FBUyxDQUFDRyxXQUFXLEdBQUc7UUFDekMsTUFBTUssSUFBSWMsT0FBT3RCLDBDQUFTLENBQUNHLFdBQVcsSUFBSTtRQUMxQyxPQUFPO1lBQ0hHO1lBQ0FDO1lBQ0FDO1FBQ0o7SUFDSjtJQUNBLE1BQU1GLFNBQVNrQixPQUFPeEIsMENBQVMsQ0FBQ0csV0FBVyxHQUFHO0lBQzlDLE1BQU1JLElBQUllLE9BQU90QiwwQ0FBUyxDQUFDRyxXQUFXLEdBQUc7SUFDekMsT0FBTztRQUNIRztRQUNBQztJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVNrQixRQUFRdEIsU0FBUyxFQUFFQyxVQUFVLENBQUMsQ0FBQztJQUMzQyxPQUFPTiw4Q0FBYSxDQUFDNEIsTUFBTXZCLFdBQVdDO0FBQzFDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTc0IsTUFBTXZCLFNBQVMsRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDekNGLE9BQU9DO0lBQ1AsTUFBTSxFQUFFRyxNQUFNLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUdMO0lBQ3pCLE1BQU0sRUFBRXdCLGdCQUFnQixJQUFJLEVBQUUsR0FBR3ZCO0lBQ2pDLE1BQU13QixhQUFhNUIsMkNBQVUsQ0FBQzJCLGdCQUFnQjNCLCtDQUFjLENBQUNNLFFBQVE7UUFBRXlCLE1BQU07SUFBRSxLQUFLLE1BQU0vQiwrQ0FBYyxDQUFDTyxHQUFHO1FBQUV3QixNQUFNO0lBQUcsSUFDdkgsNkRBQTZEO0lBQzdELE9BQU92QixNQUFNLFdBQVdSLCtDQUFjLENBQUNRLEdBQUc7UUFBRXVCLE1BQU07SUFBRyxLQUFLO0lBQzFELE9BQU9IO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxTQUFTWCxTQUFTZCxTQUFTLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQzVDLElBQUk7UUFDQUYsT0FBT0MsV0FBV0M7UUFDbEIsT0FBTztJQUNYLEVBQ0EsT0FBTzRCLFFBQVE7UUFDWCxPQUFPO0lBQ1g7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxNQUFNbkIscUJBQXFCZCxpREFBZ0I7SUFDOUNtQyxZQUFZLEVBQUUvQixTQUFTLEVBQUUsQ0FBRTtRQUN2QixLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUVGLCtDQUFjLENBQUNFLFdBQVcsNkJBQTZCLENBQUMsRUFBRTtZQUN2RWlDLGNBQWM7Z0JBQ1Y7Z0JBQ0E7Z0JBQ0E7YUFDSDtRQUNMO1FBQ0FDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVnpCLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSxvREFBb0QsR0FDN0MsTUFBTVAsMkJBQTJCVixpREFBZ0I7SUFDcERtQyxZQUFZLEVBQUU1QixNQUFNLEVBQUVJLEtBQUssRUFBRSxDQUFFO1FBQzNCLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRUosT0FBTyxhQUFhLENBQUMsRUFBRTtZQUNwQ0k7UUFDSjtRQUNBMkIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWekIsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBLGtGQUFrRixHQUMzRSxNQUFNSixxQ0FBcUNiLGlEQUFnQjtJQUM5RG1DLGFBQWM7UUFDVixLQUFLLENBQUM7UUFDTkcsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWekIsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBLHFGQUFxRixHQUM5RSxNQUFNTCx1Q0FBdUNaLGlEQUFnQjtJQUNoRW1DLGFBQWM7UUFDVixLQUFLLENBQUM7UUFDTkcsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWekIsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBLCtEQUErRCxHQUN4RCxNQUFNSyxtQ0FBbUN0QixpREFBZ0I7SUFDNURtQyxZQUFZLEVBQUUvQixTQUFTLEVBQUUsQ0FBRTtRQUN2QixLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUVBLFVBQVUsaUNBQWlDLENBQUMsRUFBRTtZQUMzRGlDLGNBQWM7Z0JBQ1Y7Z0JBQ0EsQ0FBQyxTQUFTLEVBQUVwQyx5Q0FBUSxDQUFDQSx5Q0FBUSxDQUFDRyxZQUFZLE9BQU8sQ0FBQzthQUNyRDtRQUNMO1FBQ0FrQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1Z6QixPQUFPO1FBQ1g7SUFDSjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjNDMzNy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUHVibGljS2V5LmpzPzM0Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi9Kc29uLmpzJztcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogUHVibGljS2V5LmFzc2VydCh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeTogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogfSlcbiAqIC8vIEBlcnJvcjogUHVibGljS2V5LkludmFsaWRFcnJvcjogVmFsdWUgXFxge1wieVwiOlwiMVwifVxcYCBpcyBub3QgYSB2YWxpZCBwdWJsaWMga2V5LlxuICogLy8gQGVycm9yOiBQdWJsaWMga2V5IG11c3QgY29udGFpbjpcbiAqIC8vIEBlcnJvcjogLSBhbiBgeGAgYW5kIGBwcmVmaXhgIHZhbHVlIChjb21wcmVzc2VkKVxuICogLy8gQGVycm9yOiAtIGFuIGB4YCwgYHlgLCBhbmQgYHByZWZpeGAgdmFsdWUgKHVuY29tcHJlc3NlZClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjb21wcmVzc2VkIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgLy8gVW5jb21wcmVzc2VkXG4gICAgaWYgKGNvbXByZXNzZWQgPT09IGZhbHNlIHx8XG4gICAgICAgICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHkgPT09ICdiaWdpbnQnKSkge1xuICAgICAgICBpZiAocHJlZml4ICE9PSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmVmaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDb21wcmVzc2VkXG4gICAgaWYgKGNvbXByZXNzZWQgPT09IHRydWUgfHxcbiAgICAgICAgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIGlmIChwcmVmaXggIT09IDMgJiYgcHJlZml4ICE9PSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmVmaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVW5rbm93bi9pbnZhbGlkXG4gICAgdGhyb3cgbmV3IEludmFsaWRFcnJvcih7IHB1YmxpY0tleSB9KTtcbn1cbi8qKlxuICogQ29tcHJlc3NlcyBhIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgY29tcHJlc3NlZCA9IFB1YmxpY0tleS5jb21wcmVzcyhwdWJsaWNLZXkpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiAzLFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgdG8gY29tcHJlc3MuXG4gKiBAcmV0dXJucyBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHJlc3MocHVibGljS2V5KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlZml4OiB5ICUgMm4gPT09IDBuID8gMiA6IDMsXG4gICAgICAgIHgsXG4gICAgfTtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgdHlwZWQge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IG9iamVjdCBmcm9tIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9LCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvciB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDQsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6ICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oJzB4MDQ4MzE4NTM1YjU0MTA1ZDRhN2FhZTYwYzA4ZmM0NWY5Njg3MTgxYjRmZGZjNjI1YmQxYTc1M2ZhNzM5N2ZlZDc1MzU0N2YxMWNhODY5NjY0NmYyZjNhY2IwOGUzMTAxNmFmYWMyM2U2MzBjNWQxMWY1OWY2MWZlZjU3YjBkMmFhNScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogNCxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgcHVibGljIGtleSB2YWx1ZSB0byBpbnN0YW50aWF0ZS5cbiAqIEByZXR1cm5zIFRoZSBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChIZXgudmFsaWRhdGUodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21IZXgodmFsdWUpO1xuICAgICAgICBpZiAoQnl0ZXMudmFsaWRhdGUodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21CeXRlcyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgeSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4geyBwcmVmaXg6IHByZWZpeCA/PyAweDA0LCB4LCB5IH07XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgeCB9O1xuICAgIH0pKCk7XG4gICAgYXNzZXJ0KHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IGZyb20gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KFsxMjgsIDMsIDEzMSwgLi4uXSkpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogNCxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyhwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gZnJvbUhleChIZXguZnJvbUJ5dGVzKHB1YmxpY0tleSkpO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gZnJvbSBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tSGV4KCcweDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiA0LFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRGVzZXJpYWxpemluZyBhIENvbXByZXNzZWQgUHVibGljIEtleVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbUhleCgnMHgwMzgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDMsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICogQHJldHVybnMgVGhlIGRlc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChwdWJsaWNLZXkpIHtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMTMyICYmXG4gICAgICAgIHB1YmxpY0tleS5sZW5ndGggIT09IDEzMCAmJlxuICAgICAgICBwdWJsaWNLZXkubGVuZ3RoICE9PSA2OClcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yKHsgcHVibGljS2V5IH0pO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAxMzApIHtcbiAgICAgICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAwLCAzMikpO1xuICAgICAgICBjb25zdCB5ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDMyLCA2NCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4OiA0LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAxMzIpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gTnVtYmVyKEhleC5zbGljZShwdWJsaWNLZXksIDAsIDEpKTtcbiAgICAgICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAxLCAzMykpO1xuICAgICAgICBjb25zdCB5ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDMzLCA2NSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IE51bWJlcihIZXguc2xpY2UocHVibGljS2V5LCAwLCAxKSk7XG4gICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAxLCAzMykpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgeCxcbiAgICB9O1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IHRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IGJ5dGVzID0gUHVibGljS2V5LnRvQnl0ZXMocHVibGljS2V5KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxMjgsIDMsIDEzMSwgLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodG9IZXgocHVibGljS2V5LCBvcHRpb25zKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gdG8ge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oe1xuICogICBwcmVmaXg6IDQsXG4gKiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBoZXggPSBQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHgwNDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGFzc2VydChwdWJsaWNLZXkpO1xuICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgY29uc3QgeyBpbmNsdWRlUHJlZml4ID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwdWJsaWNLZXlfID0gSGV4LmNvbmNhdChpbmNsdWRlUHJlZml4ID8gSGV4LmZyb21OdW1iZXIocHJlZml4LCB7IHNpemU6IDEgfSkgOiAnMHgnLCBIZXguZnJvbU51bWJlcih4LCB7IHNpemU6IDMyIH0pLCBcbiAgICAvLyBJZiB0aGUgcHVibGljIGtleSBpcyBub3QgY29tcHJlc3NlZCwgYWRkIHRoZSB5IGNvb3JkaW5hdGUuXG4gICAgdHlwZW9mIHkgPT09ICdiaWdpbnQnID8gSGV4LmZyb21OdW1iZXIoeSwgeyBzaXplOiAzMiB9KSA6ICcweCcpO1xuICAgIHJldHVybiBwdWJsaWNLZXlfO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0uIFJldHVybnMgYHRydWVgIGlmIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gUHVibGljS2V5LnZhbGlkYXRlKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB5OiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiB9KVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUocHVibGljS2V5LCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQocHVibGljS2V5LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBwdWJsaWMga2V5IGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBQdWJsaWNLZXkuYXNzZXJ0KHsgeTogMW4gfSlcbiAqIC8vIEBlcnJvcjogUHVibGljS2V5LkludmFsaWRFcnJvcjogVmFsdWUgYHtcInlcIjoxbn1gIGlzIG5vdCBhIHZhbGlkIHB1YmxpYyBrZXkuXG4gKiAvLyBAZXJyb3I6IFB1YmxpYyBrZXkgbXVzdCBjb250YWluOlxuICogLy8gQGVycm9yOiAtIGFuIGB4YCBhbmQgYHByZWZpeGAgdmFsdWUgKGNvbXByZXNzZWQpXG4gKiAvLyBAZXJyb3I6IC0gYW4gYHhgLCBgeWAsIGFuZCBgcHJlZml4YCB2YWx1ZSAodW5jb21wcmVzc2VkKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHB1YmxpY0tleSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke0pzb24uc3RyaW5naWZ5KHB1YmxpY0tleSl9XFxgIGlzIG5vdCBhIHZhbGlkIHB1YmxpYyBrZXkuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1B1YmxpYyBrZXkgbXVzdCBjb250YWluOicsXG4gICAgICAgICAgICAgICAgJy0gYW4gYHhgIGFuZCBgcHJlZml4YCB2YWx1ZSAoY29tcHJlc3NlZCknLFxuICAgICAgICAgICAgICAgICctIGFuIGB4YCwgYHlgLCBhbmQgYHByZWZpeGAgdmFsdWUgKHVuY29tcHJlc3NlZCknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gYSBwdWJsaWMga2V5IGhhcyBhbiBpbnZhbGlkIHByZWZpeC4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkUHJlZml4RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHByZWZpeCwgY2F1c2UgfSkge1xuICAgICAgICBzdXBlcihgUHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgaW52YWxpZC5gLCB7XG4gICAgICAgICAgICBjYXVzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZFByZWZpeEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHB1YmxpYyBrZXkgaGFzIGFuIGludmFsaWQgcHJlZml4IGZvciBhIGNvbXByZXNzZWQgcHVibGljIGtleS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQ29tcHJlc3NlZFByZWZpeEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdQcmVmaXggbXVzdCBiZSAyIG9yIDMgZm9yIGNvbXByZXNzZWQgcHVibGljIGtleXMuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBwdWJsaWMga2V5IGhhcyBhbiBpbnZhbGlkIHByZWZpeCBmb3IgYW4gdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdQcmVmaXggbXVzdCBiZSA0IGZvciB1bmNvbXByZXNzZWQgcHVibGljIGtleXMuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHB1YmxpYyBrZXkgaGFzIGFuIGludmFsaWQgc2VyaWFsaXplZCBzaXplLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBwdWJsaWNLZXkgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHtwdWJsaWNLZXl9XFxgIGlzIGFuIGludmFsaWQgcHVibGljIGtleSBzaXplLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdFeHBlY3RlZDogMzMgYnl0ZXMgKGNvbXByZXNzZWQgKyBwcmVmaXgpLCA2NCBieXRlcyAodW5jb21wcmVzc2VkKSBvciA2NSBieXRlcyAodW5jb21wcmVzc2VkICsgcHJlZml4KS4nLFxuICAgICAgICAgICAgICAgIGBSZWNlaXZlZCAke0hleC5zaXplKEhleC5mcm9tKHB1YmxpY0tleSkpfSBieXRlcy5gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVB1YmxpY0tleS5qcy5tYXAiXSwibmFtZXMiOlsiQnl0ZXMiLCJFcnJvcnMiLCJIZXgiLCJKc29uIiwiYXNzZXJ0IiwicHVibGljS2V5Iiwib3B0aW9ucyIsImNvbXByZXNzZWQiLCJwcmVmaXgiLCJ4IiwieSIsIkludmFsaWRQcmVmaXhFcnJvciIsImNhdXNlIiwiSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yIiwiSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvciIsIkludmFsaWRFcnJvciIsImNvbXByZXNzIiwiZnJvbSIsInZhbHVlIiwidmFsaWRhdGUiLCJmcm9tSGV4IiwiZnJvbUJ5dGVzIiwibGVuZ3RoIiwiSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IiLCJCaWdJbnQiLCJzbGljZSIsIk51bWJlciIsInRvQnl0ZXMiLCJ0b0hleCIsImluY2x1ZGVQcmVmaXgiLCJwdWJsaWNLZXlfIiwiY29uY2F0IiwiZnJvbU51bWJlciIsInNpemUiLCJfZXJyb3IiLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsInN0cmluZ2lmeSIsIm1ldGFNZXNzYWdlcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/PublicKey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Rlp.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Rlp.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlpCursor: () => (/* binding */ decodeRlpCursor),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   readLength: () => (/* binding */ readLength),\n/* harmony export */   readList: () => (/* binding */ readList),\n/* harmony export */   to: () => (/* binding */ to),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/cursor.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/cursor.js\");\n\n\n\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */ function toBytes(value) {\n    return to(value, \"Bytes\");\n}\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */ function toHex(value) {\n    return to(value, \"Hex\");\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n/** @internal */ function to(value, to) {\n    const to_ = to ?? (typeof value === \"string\" ? \"Hex\" : \"Bytes\");\n    const bytes = (()=>{\n        if (typeof value === \"string\") {\n            if (value.length > 3 && value.length % 2 !== 0) throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.InvalidLengthError(value);\n            return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(value);\n        }\n        return value;\n    })();\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(bytes, {\n        recursiveReadLimit: Number.POSITIVE_INFINITY\n    });\n    const result = decodeRlpCursor(cursor, to_);\n    return result;\n}\n/** @internal */ /** @internal */ function decodeRlpCursor(cursor, to = \"Hex\") {\n    if (cursor.bytes.length === 0) return to === \"Hex\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes) : cursor.bytes;\n    const prefix = cursor.readByte();\n    if (prefix < 0x80) cursor.decrementPosition(1);\n    // bytes\n    if (prefix < 0xc0) {\n        const length = readLength(cursor, prefix, 0x80);\n        const bytes = cursor.readBytes(length);\n        return to === \"Hex\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes) : bytes;\n    }\n    // list\n    const length = readLength(cursor, prefix, 0xc0);\n    return readList(cursor, length, to);\n}\n/** @internal */ function readLength(cursor, prefix, offset) {\n    if (offset === 0x80 && prefix < 0x80) return 1;\n    if (prefix <= offset + 55) return prefix - offset;\n    if (prefix === offset + 55 + 1) return cursor.readUint8();\n    if (prefix === offset + 55 + 2) return cursor.readUint16();\n    if (prefix === offset + 55 + 3) return cursor.readUint24();\n    if (prefix === offset + 55 + 4) return cursor.readUint32();\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(\"Invalid RLP prefix\");\n}\n/** @internal */ function readList(cursor, length, to) {\n    const position = cursor.position;\n    const value = [];\n    while(cursor.position - position < length)value.push(decodeRlpCursor(cursor, to));\n    return value;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */ function from(value, options) {\n    const { as } = options;\n    const encodable = getEncodable(value);\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (as === \"Hex\") return _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes);\n    return cursor.bytes;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */ function fromBytes(bytes, options = {}) {\n    const { as = \"Bytes\" } = options;\n    return from(bytes, {\n        as\n    });\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */ function fromHex(hex, options = {}) {\n    const { as = \"Hex\" } = options;\n    return from(hex, {\n        as\n    });\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes)) return getEncodableList(bytes.map((x)=>getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x)=>acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (()=>{\n        if (bodyLength <= 55) return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode (cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            } else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);\n                else cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list){\n                encode(cursor);\n            }\n        }\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === \"string\" ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (()=>{\n        if (bytes.length === 1 && bytes[0] < 0x80) return 1;\n        if (bytes.length <= 55) return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode (cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            } else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            } else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length);\n                else cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        }\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length <= 0xff) return 1;\n    if (length <= 0xffff) return 2;\n    if (length <= 0xffffff) return 3;\n    if (length <= 0xffffffff) return 4;\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(\"Length is too large.\");\n} //# sourceMappingURL=Rlp.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1JscC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ0U7QUFDTjtBQUNlO0FBQy9DOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNJLFFBQVFDLEtBQUs7SUFDekIsT0FBT0MsR0FBR0QsT0FBTztBQUNyQjtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNFLE1BQU1GLEtBQUs7SUFDdkIsT0FBT0MsR0FBR0QsT0FBTztBQUNyQjtBQUNBLGlGQUFpRjtBQUNqRixXQUFXO0FBQ1gsaUZBQWlGO0FBQ2pGLGNBQWMsR0FDUCxTQUFTQyxHQUFHRCxLQUFLLEVBQUVDLEVBQUU7SUFDeEIsTUFBTUUsTUFBTUYsTUFBTyxRQUFPRCxVQUFVLFdBQVcsUUFBUSxPQUFNO0lBQzdELE1BQU1JLFFBQVEsQ0FBQztRQUNYLElBQUksT0FBT0osVUFBVSxVQUFVO1lBQzNCLElBQUlBLE1BQU1LLE1BQU0sR0FBRyxLQUFLTCxNQUFNSyxNQUFNLEdBQUcsTUFBTSxHQUN6QyxNQUFNLElBQUlSLHVEQUFzQixDQUFDRztZQUNyQyxPQUFPTCw4Q0FBYSxDQUFDSztRQUN6QjtRQUNBLE9BQU9BO0lBQ1g7SUFDQSxNQUFNUSxTQUFTVix1REFBYSxDQUFDTSxPQUFPO1FBQ2hDTSxvQkFBb0JDLE9BQU9DLGlCQUFpQjtJQUNoRDtJQUNBLE1BQU1DLFNBQVNDLGdCQUFnQk4sUUFBUUw7SUFDdkMsT0FBT1U7QUFDWDtBQUNBLGNBQWMsR0FDZCxjQUFjLEdBQ1AsU0FBU0MsZ0JBQWdCTixNQUFNLEVBQUVQLEtBQUssS0FBSztJQUM5QyxJQUFJTyxPQUFPSixLQUFLLENBQUNDLE1BQU0sS0FBSyxHQUN4QixPQUFRSixPQUFPLFFBQVFKLDhDQUFhLENBQUNXLE9BQU9KLEtBQUssSUFBSUksT0FBT0osS0FBSztJQUNyRSxNQUFNWSxTQUFTUixPQUFPUyxRQUFRO0lBQzlCLElBQUlELFNBQVMsTUFDVFIsT0FBT1Us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RDtZQUNyQixPQUNLO2dCQUNESSxPQUFPMEMsUUFBUSxDQUFDLE9BQU8sS0FBS007Z0JBQzVCLElBQUlBLHNCQUFzQixHQUN0QmhELE9BQU8yQyxTQUFTLENBQUMvQyxNQUFNQyxNQUFNO3FCQUM1QixJQUFJbUQsc0JBQXNCLEdBQzNCaEQsT0FBTzRDLFVBQVUsQ0FBQ2hELE1BQU1DLE1BQU07cUJBQzdCLElBQUltRCxzQkFBc0IsR0FDM0JoRCxPQUFPNkMsVUFBVSxDQUFDakQsTUFBTUMsTUFBTTtxQkFFOUJHLE9BQU84QyxVQUFVLENBQUNsRCxNQUFNQyxNQUFNO2dCQUNsQ0csT0FBT2lELFNBQVMsQ0FBQ3JEO1lBQ3JCO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBUzZDLGdCQUFnQjVDLE1BQU07SUFDM0IsSUFBSUEsVUFBVSxNQUNWLE9BQU87SUFDWCxJQUFJQSxVQUFVLFFBQ1YsT0FBTztJQUNYLElBQUlBLFVBQVUsVUFDVixPQUFPO0lBQ1gsSUFBSUEsVUFBVSxZQUNWLE9BQU87SUFDWCxNQUFNLElBQUlULGlEQUFnQixDQUFDO0FBQy9CLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjNDMzNy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUmxwLmpzPzg2YzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEN1cnNvciBmcm9tICcuL2ludGVybmFsL2N1cnNvci5qcyc7XG4vKipcbiAqIERlY29kZXMgYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICogUmxwLnRvQnl0ZXMoJzB4OGI2ODY1NmM2YzZmMjA3NzZmNzI2YzY0JylcbiAqIC8vIFVpbnQ4QXJyYXkoWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvKHZhbHVlLCAnQnl0ZXMnKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIFJlY3Vyc2l2ZS1MZW5ndGggUHJlZml4IChSTFApIHZhbHVlIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBSbHAgfSBmcm9tICdveCdcbiAqIFJscC50b0hleCgnMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gMHg2ODY1NmM2YzZmMjA3NzZmNzI2YzY0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICByZXR1cm4gdG8odmFsdWUsICdIZXgnKTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJuYWxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvKHZhbHVlLCB0bykge1xuICAgIGNvbnN0IHRvXyA9IHRvID8/ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnKTtcbiAgICBjb25zdCBieXRlcyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMyAmJiB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBIZXguSW52YWxpZExlbmd0aEVycm9yKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkoKTtcbiAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKGJ5dGVzLCB7XG4gICAgICAgIHJlY3Vyc2l2ZVJlYWRMaW1pdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZVJscEN1cnNvcihjdXJzb3IsIHRvXyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSbHBDdXJzb3IoY3Vyc29yLCB0byA9ICdIZXgnKSB7XG4gICAgaWYgKGN1cnNvci5ieXRlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAodG8gPT09ICdIZXgnID8gSGV4LmZyb21CeXRlcyhjdXJzb3IuYnl0ZXMpIDogY3Vyc29yLmJ5dGVzKTtcbiAgICBjb25zdCBwcmVmaXggPSBjdXJzb3IucmVhZEJ5dGUoKTtcbiAgICBpZiAocHJlZml4IDwgMHg4MClcbiAgICAgICAgY3Vyc29yLmRlY3JlbWVudFBvc2l0aW9uKDEpO1xuICAgIC8vIGJ5dGVzXG4gICAgaWYgKHByZWZpeCA8IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgMHg4MCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gY3Vyc29yLnJlYWRCeXRlcyhsZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHRvID09PSAnSGV4JyA/IEhleC5mcm9tQnl0ZXMoYnl0ZXMpIDogYnl0ZXMpO1xuICAgIH1cbiAgICAvLyBsaXN0XG4gICAgY29uc3QgbGVuZ3RoID0gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgMHhjMCk7XG4gICAgcmV0dXJuIHJlYWRMaXN0KGN1cnNvciwgbGVuZ3RoLCB0byk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMHg4MCAmJiBwcmVmaXggPCAweDgwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAocHJlZml4IDw9IG9mZnNldCArIDU1KVxuICAgICAgICByZXR1cm4gcHJlZml4IC0gb2Zmc2V0O1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMSlcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDgoKTtcbiAgICBpZiAocHJlZml4ID09PSBvZmZzZXQgKyA1NSArIDIpXG4gICAgICAgIHJldHVybiBjdXJzb3IucmVhZFVpbnQxNigpO1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMylcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDI0KCk7XG4gICAgaWYgKHByZWZpeCA9PT0gb2Zmc2V0ICsgNTUgKyA0KVxuICAgICAgICByZXR1cm4gY3Vyc29yLnJlYWRVaW50MzIoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignSW52YWxpZCBSTFAgcHJlZml4Jyk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZExpc3QoY3Vyc29yLCBsZW5ndGgsIHRvKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBjdXJzb3IucG9zaXRpb247XG4gICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvc2l0aW9uIC0gcG9zaXRpb24gPCBsZW5ndGgpXG4gICAgICAgIHZhbHVlLnB1c2goZGVjb2RlUmxwQ3Vyc29yKGN1cnNvciwgdG8pKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgUmxwIH0gZnJvbSAnb3gnXG4gKlxuICogUmxwLmZyb20oJzB4Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCcsIHsgYXM6ICdIZXgnIH0pXG4gKiAvLyBAbG9nOiAweDhiNjg2NTZjNmM2ZjIwNzc2ZjcyNmM2NFxuICpcbiAqIFJscC5mcm9tKEJ5dGVzLmZyb20oWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKSwgeyBhczogJ0J5dGVzJyB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBlbmNvZGFibGUgPSBnZXRFbmNvZGFibGUodmFsdWUpO1xuICAgIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUobmV3IFVpbnQ4QXJyYXkoZW5jb2RhYmxlLmxlbmd0aCkpO1xuICAgIGVuY29kYWJsZS5lbmNvZGUoY3Vyc29yKTtcbiAgICBpZiAoYXMgPT09ICdIZXgnKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhjdXJzb3IuYnl0ZXMpO1xuICAgIHJldHVybiBjdXJzb3IuYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBSbHAgfSBmcm9tICdveCdcbiAqXG4gKiBSbHAuZnJvbUJ5dGVzKEJ5dGVzLmZyb20oWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGJ5dGVzLCB7IGFzIH0pO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICpcbiAqIFJscC5mcm9tSGV4KCcweDY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gQGxvZzogMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGhleCwgeyBhcyB9KTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJuYWxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlKGJ5dGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYnl0ZXMpKVxuICAgICAgICByZXR1cm4gZ2V0RW5jb2RhYmxlTGlzdChieXRlcy5tYXAoKHgpID0+IGdldEVuY29kYWJsZSh4KSkpO1xuICAgIHJldHVybiBnZXRFbmNvZGFibGVCeXRlcyhieXRlcyk7XG59XG5mdW5jdGlvbiBnZXRFbmNvZGFibGVMaXN0KGxpc3QpIHtcbiAgICBjb25zdCBib2R5TGVuZ3RoID0gbGlzdC5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgeC5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHNpemVPZkJvZHlMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYm9keUxlbmd0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGJvZHlMZW5ndGggPD0gNTUpXG4gICAgICAgICAgICByZXR1cm4gMSArIGJvZHlMZW5ndGg7XG4gICAgICAgIHJldHVybiAxICsgc2l6ZU9mQm9keUxlbmd0aCArIGJvZHlMZW5ndGg7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGVuY29kZShjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChib2R5TGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4YzAgKyBib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZSgweGMwICsgNTUgKyBzaXplT2ZCb2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAzKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDMyKGJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGVuY29kZSB9IG9mIGxpc3QpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGUoY3Vyc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlQnl0ZXMoYnl0ZXNPckhleCkge1xuICAgIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGJ5dGVzT3JIZXggPT09ICdzdHJpbmcnID8gQnl0ZXMuZnJvbUhleChieXRlc09ySGV4KSA6IGJ5dGVzT3JIZXg7XG4gICAgY29uc3Qgc2l6ZU9mQnl0ZXNMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYnl0ZXMubGVuZ3RoKTtcbiAgICBjb25zdCBsZW5ndGggPSAoKCkgPT4ge1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAxICYmIGJ5dGVzWzBdIDwgMHg4MClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoIDw9IDU1KVxuICAgICAgICAgICAgcmV0dXJuIDEgKyBieXRlcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiAxICsgc2l6ZU9mQnl0ZXNMZW5ndGggKyBieXRlcy5sZW5ndGg7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGVuY29kZShjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDEgJiYgYnl0ZXNbMF0gPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHg4MCArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHg4MCArIDU1ICsgc2l6ZU9mQnl0ZXNMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAzKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MzIoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2l6ZU9mTGVuZ3RoKGxlbmd0aCkge1xuICAgIGlmIChsZW5ndGggPD0gMHhmZilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGxlbmd0aCA8PSAweGZmX2ZmKVxuICAgICAgICByZXR1cm4gMjtcbiAgICBpZiAobGVuZ3RoIDw9IDB4ZmZfZmZfZmYpXG4gICAgICAgIHJldHVybiAzO1xuICAgIGlmIChsZW5ndGggPD0gMHhmZl9mZl9mZl9mZilcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoJ0xlbmd0aCBpcyB0b28gbGFyZ2UuJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SbHAuanMubWFwIl0sIm5hbWVzIjpbIkJ5dGVzIiwiRXJyb3JzIiwiSGV4IiwiQ3Vyc29yIiwidG9CeXRlcyIsInZhbHVlIiwidG8iLCJ0b0hleCIsInRvXyIsImJ5dGVzIiwibGVuZ3RoIiwiSW52YWxpZExlbmd0aEVycm9yIiwiZnJvbUhleCIsImN1cnNvciIsImNyZWF0ZSIsInJlY3Vyc2l2ZVJlYWRMaW1pdCIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwicmVzdWx0IiwiZGVjb2RlUmxwQ3Vyc29yIiwiZnJvbUJ5dGVzIiwicHJlZml4IiwicmVhZEJ5dGUiLCJkZWNyZW1lbnRQb3NpdGlvbiIsInJlYWRMZW5ndGgiLCJyZWFkQnl0ZXMiLCJyZWFkTGlzdCIsIm9mZnNldCIsInJlYWRVaW50OCIsInJlYWRVaW50MTYiLCJyZWFkVWludDI0IiwicmVhZFVpbnQzMiIsIkJhc2VFcnJvciIsInBvc2l0aW9uIiwicHVzaCIsImZyb20iLCJvcHRpb25zIiwiYXMiLCJlbmNvZGFibGUiLCJnZXRFbmNvZGFibGUiLCJVaW50OEFycmF5IiwiZW5jb2RlIiwiaGV4IiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0RW5jb2RhYmxlTGlzdCIsIm1hcCIsIngiLCJnZXRFbmNvZGFibGVCeXRlcyIsImxpc3QiLCJib2R5TGVuZ3RoIiwicmVkdWNlIiwiYWNjIiwic2l6ZU9mQm9keUxlbmd0aCIsImdldFNpemVPZkxlbmd0aCIsInB1c2hCeXRlIiwicHVzaFVpbnQ4IiwicHVzaFVpbnQxNiIsInB1c2hVaW50MjQiLCJwdXNoVWludDMyIiwiYnl0ZXNPckhleCIsInNpemVPZkJ5dGVzTGVuZ3RoIiwicHVzaEJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Rlp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Secp256k1.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Secp256k1.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createKeyPair: () => (/* binding */ createKeyPair),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   noble: () => (/* binding */ noble),\n/* harmony export */   randomPrivateKey: () => (/* binding */ randomPrivateKey),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_entropy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/entropy.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/entropy.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/./node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\n\n/** Re-export of noble/curves secp256k1 utilities. */ const noble = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1;\n/**\n * Creates a new secp256k1 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey, publicKey } = Secp256k1.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */ function createKeyPair(options = {}) {\n    const { as = \"Hex\" } = options;\n    const privateKey = randomPrivateKey({\n        as\n    });\n    const publicKey = getPublicKey({\n        privateKey\n    });\n    return {\n        privateKey: privateKey,\n        publicKey\n    };\n}\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */ function getPublicKey(options) {\n    const { privateKey } = options;\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint.fromPrivateKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey).slice(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey: privateKeyA } = Secp256k1.createKeyPair()\n * const { publicKey: publicKeyB } = Secp256k1.createKeyPair()\n *\n * const sharedSecret = Secp256k1.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */ function getSharedSecret(options) {\n    const { as = \"Hex\", privateKey, publicKey } = options;\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint.fromHex(_PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toHex(publicKey).slice(2));\n    const sharedPoint = point.multiply(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.normPrivateKeyToScalar(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey).slice(2)));\n    const sharedSecret = sharedPoint.toRawBytes(true); // compressed format\n    if (as === \"Hex\") return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(sharedSecret);\n    return sharedSecret;\n}\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */ function randomPrivateKey(options = {}) {\n    const { as = \"Hex\" } = options;\n    const bytes = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.randomPrivateKey();\n    if (as === \"Hex\") return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes);\n    return bytes;\n}\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */ function recoverAddress(options) {\n    return _Address_js__WEBPACK_IMPORTED_MODULE_3__.fromPublicKey(recoverPublicKey(options));\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */ function recoverPublicKey(options) {\n    const { payload, signature } = options;\n    const { r, s, yParity } = signature;\n    const signature_ = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n    const point = signature_.recoverPublicKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(payload).substring(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */ function sign(options) {\n    const { extraEntropy = _internal_entropy_js__WEBPACK_IMPORTED_MODULE_4__.extraEntropy, hash, payload, privateKey } = options;\n    const { r, s, recovery } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.sign(_Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(payload), _Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(privateKey), {\n        extraEntropy: typeof extraEntropy === \"boolean\" ? extraEntropy : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(extraEntropy).slice(2),\n        lowS: true,\n        ...hash ? {\n            prehash: true\n        } : {}\n    });\n    return {\n        r,\n        s,\n        yParity: recovery\n    };\n}\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */ function verify(options) {\n    const { address, hash, payload, publicKey, signature } = options;\n    if (address) return _Address_js__WEBPACK_IMPORTED_MODULE_3__.isEqual(address, recoverAddress({\n        payload,\n        signature\n    }));\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.verify(signature, _Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(payload), _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toBytes(publicKey), ...hash ? [\n        {\n            prehash: true,\n            lowS: true\n        }\n    ] : []);\n} //# sourceMappingURL=Secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0Q7QUFDWjtBQUNKO0FBQ0o7QUFDaUI7QUFDTDtBQUM1QyxtREFBbUQsR0FDNUMsTUFBTU0sUUFBUU4sOERBQVNBLENBQUM7QUFDL0I7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU08sY0FBY0MsVUFBVSxDQUFDLENBQUM7SUFDdEMsTUFBTSxFQUFFQyxLQUFLLEtBQUssRUFBRSxHQUFHRDtJQUN2QixNQUFNRSxhQUFhQyxpQkFBaUI7UUFBRUY7SUFBRztJQUN6QyxNQUFNRyxZQUFZQyxhQUFhO1FBQUVIO0lBQVc7SUFDNUMsT0FBTztRQUNIQSxZQUFZQTtRQUNaRTtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTQyxhQUFhTCxPQUFPO0lBQ2hDLE1BQU0sRUFBRUUsVUFBVSxFQUFFLEdBQUdGO0lBQ3ZCLE1BQU1NLFFBQVFkLDhEQUFTQSxDQUFDZSxlQUFlLENBQUNDLGNBQWMsQ0FBQ2IseUNBQVEsQ0FBQ08sWUFBWVEsS0FBSyxDQUFDO0lBQ2xGLE9BQU9iLCtDQUFjLENBQUNTO0FBQzFCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVNLLGdCQUFnQlgsT0FBTztJQUNuQyxNQUFNLEVBQUVDLEtBQUssS0FBSyxFQUFFQyxVQUFVLEVBQUVFLFNBQVMsRUFBRSxHQUFHSjtJQUM5QyxNQUFNTSxRQUFRZCw4REFBU0EsQ0FBQ2UsZUFBZSxDQUFDSyxPQUFPLENBQUNmLGdEQUFlLENBQUNPLFdBQVdNLEtBQUssQ0FBQztJQUNqRixNQUFNSSxjQUFjUixNQUFNUyxRQUFRLENBQUN2Qiw4REFBU0EsQ0FBQ3dCLEtBQUssQ0FBQ0Msc0JBQXNCLENBQUN0Qix5Q0FBUSxDQUFDTyxZQUFZUSxLQUFLLENBQUM7SUFDckcsTUFBTVEsZUFBZUosWUFBWUssVUFBVSxDQUFDLE9BQU8sb0JBQW9CO0lBQ3ZFLElBQUlsQixPQUFPLE9BQ1AsT0FBT04sOENBQWEsQ0FBQ3VCO0lBQ3pCLE9BQU9BO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTZixpQkFBaUJILFVBQVUsQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sRUFBRUMsS0FBSyxLQUFLLEVBQUUsR0FBR0Q7SUFDdkIsTUFBTXFCLFFBQVE3Qiw4REFBU0EsQ0FBQ3dCLEtBQUssQ0FBQ2IsZ0JBQWdCO0lBQzlDLElBQUlGLE9BQU8sT0FDUCxPQUFPTiw4Q0FBYSxDQUFDMEI7SUFDekIsT0FBT0E7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVNDLGVBQWV0QixPQUFPO0lBQ2xDLE9BQU9QLHNEQUFxQixDQUFDK0IsaUJBQWlCeEI7QUFDbEQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDTSxTQUFTd0IsaUJBQWlCeEIsT0FBTztJQUNwQyxNQUFNLEVBQUV5QixPQUFPLEVBQUVDLFNBQVMsRUFBRSxHQUFHMUI7SUFDL0IsTUFBTSxFQUFFMkIsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLE9BQU8sRUFBRSxHQUFHSDtJQUMxQixNQUFNSSxhQUFhLElBQUl0Qyw4REFBU0EsQ0FBQ3VDLFNBQVMsQ0FBQ0MsT0FBT0wsSUFBSUssT0FBT0osSUFBSUssY0FBYyxDQUFDSjtJQUNoRixNQUFNdkIsUUFBUXdCLFdBQVdOLGdCQUFnQixDQUFDN0IseUNBQVEsQ0FBQzhCLFNBQVNTLFNBQVMsQ0FBQztJQUN0RSxPQUFPckMsK0NBQWMsQ0FBQ1M7QUFDMUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxTQUFTNkIsS0FBS25DLE9BQU87SUFDeEIsTUFBTSxFQUFFb0MsZUFBZXhDLDhEQUFvQixFQUFFeUMsSUFBSSxFQUFFWixPQUFPLEVBQUV2QixVQUFVLEVBQUcsR0FBR0Y7SUFDNUUsTUFBTSxFQUFFMkIsQ0FBQyxFQUFFQyxDQUFDLEVBQUVVLFFBQVEsRUFBRSxHQUFHOUMsOERBQVNBLENBQUMyQyxJQUFJLENBQUN6QywyQ0FBVSxDQUFDK0IsVUFBVS9CLDJDQUFVLENBQUNRLGFBQWE7UUFDbkZrQyxjQUFjLE9BQU9BLGlCQUFpQixZQUNoQ0EsZUFDQXpDLHlDQUFRLENBQUN5QyxjQUFjMUIsS0FBSyxDQUFDO1FBQ25DNkIsTUFBTTtRQUNOLEdBQUlGLE9BQU87WUFBRUcsU0FBUztRQUFLLElBQUksQ0FBQyxDQUFDO0lBQ3JDO0lBQ0EsT0FBTztRQUNIYjtRQUNBQztRQUNBQyxTQUFTUztJQUNiO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFDQyxHQUNNLFNBQVNHLE9BQU96QyxPQUFPO0lBQzFCLE1BQU0sRUFBRTBDLE9BQU8sRUFBRUwsSUFBSSxFQUFFWixPQUFPLEVBQUVyQixTQUFTLEVBQUVzQixTQUFTLEVBQUUsR0FBRzFCO0lBQ3pELElBQUkwQyxTQUNBLE9BQU9qRCxnREFBZSxDQUFDaUQsU0FBU3BCLGVBQWU7UUFBRUc7UUFBU0M7SUFBVTtJQUN4RSxPQUFPbEMsOERBQVNBLENBQUNpRCxNQUFNLENBQUNmLFdBQVdoQywyQ0FBVSxDQUFDK0IsVUFBVTVCLGtEQUFpQixDQUFDTyxlQUFnQmlDLE9BQU87UUFBQztZQUFFRyxTQUFTO1lBQU1ELE1BQU07UUFBSztLQUFFLEdBQUcsRUFBRTtBQUN6SSxFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYzQzMzctZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NlY3AyNTZrMS5qcz9hZWIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbmltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEVudHJvcHkgZnJvbSAnLi9pbnRlcm5hbC9lbnRyb3B5LmpzJztcbmltcG9ydCAqIGFzIFB1YmxpY0tleSBmcm9tICcuL1B1YmxpY0tleS5qcyc7XG4vKiogUmUtZXhwb3J0IG9mIG5vYmxlL2N1cnZlcyBzZWNwMjU2azEgdXRpbGl0aWVzLiAqL1xuZXhwb3J0IGNvbnN0IG5vYmxlID0gc2VjcDI1NmsxO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNlY3AyNTZrMSBFQ0RTQSBrZXkgcGFpciBjb25zaXN0aW5nIG9mIGEgcHJpdmF0ZSBrZXkgYW5kIGl0cyBjb3JyZXNwb25kaW5nIHB1YmxpYyBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB7IHByaXZhdGVLZXksIHB1YmxpY0tleSB9ID0gU2VjcDI1NmsxLmNyZWF0ZUtleVBhaXIoKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUga2V5IHBhaXIuXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIGtleSBwYWlyIGNvbnRhaW5pbmcgYm90aCBwcml2YXRlIGFuZCBwdWJsaWMga2V5cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUtleVBhaXIob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSByYW5kb21Qcml2YXRlS2V5KHsgYXMgfSk7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5LFxuICAgICAgICBwdWJsaWNLZXksXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNlY3AyNTZrMSBFQ0RTQSBwdWJsaWMga2V5IGZyb20gYSBwcm92aWRlZCBwcml2YXRlIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbXB1dGUgdGhlIHB1YmxpYyBrZXkuXG4gKiBAcmV0dXJucyBUaGUgY29tcHV0ZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YmxpY0tleShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwcml2YXRlS2V5IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tUHJpdmF0ZUtleShIZXguZnJvbShwcml2YXRlS2V5KS5zbGljZSgyKSk7XG4gICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tKHBvaW50KTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSBzaGFyZWQgc2VjcmV0IHVzaW5nIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZS1IZWxsbWFuKSBiZXR3ZWVuIGEgcHJpdmF0ZSBrZXkgYW5kIGEgcHVibGljIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleTogcHJpdmF0ZUtleUEgfSA9IFNlY3AyNTZrMS5jcmVhdGVLZXlQYWlyKClcbiAqIGNvbnN0IHsgcHVibGljS2V5OiBwdWJsaWNLZXlCIH0gPSBTZWNwMjU2azEuY3JlYXRlS2V5UGFpcigpXG4gKlxuICogY29uc3Qgc2hhcmVkU2VjcmV0ID0gU2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldCh7XG4gKiAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXlBLFxuICogICBwdWJsaWNLZXk6IHB1YmxpY0tleUJcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbXB1dGUgdGhlIHNoYXJlZCBzZWNyZXQuXG4gKiBAcmV0dXJucyBUaGUgY29tcHV0ZWQgc2hhcmVkIHNlY3JldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnLCBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoUHVibGljS2V5LnRvSGV4KHB1YmxpY0tleSkuc2xpY2UoMikpO1xuICAgIGNvbnN0IHNoYXJlZFBvaW50ID0gcG9pbnQubXVsdGlwbHkoc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoSGV4LmZyb20ocHJpdmF0ZUtleSkuc2xpY2UoMikpKTtcbiAgICBjb25zdCBzaGFyZWRTZWNyZXQgPSBzaGFyZWRQb2ludC50b1Jhd0J5dGVzKHRydWUpOyAvLyBjb21wcmVzc2VkIGZvcm1hdFxuICAgIGlmIChhcyA9PT0gJ0hleCcpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKHNoYXJlZFNlY3JldCk7XG4gICAgcmV0dXJuIHNoYXJlZFNlY3JldDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIEVDRFNBIHByaXZhdGUga2V5IG9uIHRoZSBzZWNwMjU2azEgY3VydmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gU2VjcDI1NmsxLnJhbmRvbVByaXZhdGVLZXkoKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIHByaXZhdGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tUHJpdmF0ZUtleShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICAgIGlmIChhcyA9PT0gJ0hleCcpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIFJlY292ZXJzIHRoZSBzaWduaW5nIGFkZHJlc3MgZnJvbSB0aGUgc2lnbmVkIHBheWxvYWQgYW5kIHNpZ25hdHVyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKlxuICogY29uc3QgYWRkcmVzcyA9IFNlY3AyNTZrMS5yZWNvdmVyQWRkcmVzcyh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcmVjb3Zlcnkgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSByZWNvdmVyZWQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJBZGRyZXNzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gQWRkcmVzcy5mcm9tUHVibGljS2V5KHJlY292ZXJQdWJsaWNLZXkob3B0aW9ucykpO1xufVxuLyoqXG4gKiBSZWNvdmVycyB0aGUgc2lnbmluZyBwdWJsaWMga2V5IGZyb20gdGhlIHNpZ25lZCBwYXlsb2FkIGFuZCBzaWduYXR1cmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFNlY3AyNTZrMS5yZWNvdmVyUHVibGljS2V5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHJlY292ZXJlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkLCBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9IG5ldyBzZWNwMjU2azEuU2lnbmF0dXJlKEJpZ0ludChyKSwgQmlnSW50KHMpKS5hZGRSZWNvdmVyeUJpdCh5UGFyaXR5KTtcbiAgICBjb25zdCBwb2ludCA9IHNpZ25hdHVyZV8ucmVjb3ZlclB1YmxpY0tleShIZXguZnJvbShwYXlsb2FkKS5zdWJzdHJpbmcoMikpO1xuICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbShwb2ludCk7XG59XG4vKipcbiAqIFNpZ25zIHRoZSBwYXlsb2FkIHdpdGggdGhlIHByb3ZpZGVkIHByaXZhdGUga2V5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwcml2YXRlS2V5OiAnMHguLi4nIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHNpZ25pbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBFQ0RTQSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGV4dHJhRW50cm9weSA9IEVudHJvcHkuZXh0cmFFbnRyb3B5LCBoYXNoLCBwYXlsb2FkLCBwcml2YXRlS2V5LCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5IH0gPSBzZWNwMjU2azEuc2lnbihCeXRlcy5mcm9tKHBheWxvYWQpLCBCeXRlcy5mcm9tKHByaXZhdGVLZXkpLCB7XG4gICAgICAgIGV4dHJhRW50cm9weTogdHlwZW9mIGV4dHJhRW50cm9weSA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICA/IGV4dHJhRW50cm9weVxuICAgICAgICAgICAgOiBIZXguZnJvbShleHRyYUVudHJvcHkpLnNsaWNlKDIpLFxuICAgICAgICBsb3dTOiB0cnVlLFxuICAgICAgICAuLi4oaGFzaCA/IHsgcHJlaGFzaDogdHJ1ZSB9IDoge30pLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHIsXG4gICAgICAgIHMsXG4gICAgICAgIHlQYXJpdHk6IHJlY292ZXJ5LFxuICAgIH07XG59XG4vKipcbiAqIFZlcmlmaWVzIGEgcGF5bG9hZCB3YXMgc2lnbmVkIGJ5IHRoZSBwcm92aWRlZCBhZGRyZXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVmVyaWZ5IHdpdGggRXRoZXJldW0gQWRkcmVzc1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICpcbiAqIGNvbnN0IHZlcmlmaWVkID0gU2VjcDI1NmsxLnZlcmlmeSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgYWRkcmVzczogJzB4ZjM5ZmQ2ZTUxYWFkODhmNmY0Y2U2YWI4ODI3Mjc5Y2ZmZmI5MjI2NicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBWZXJpZnkgd2l0aCBQdWJsaWMgS2V5XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSAnMHguLi4nXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBTZWNwMjU2azEuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleSB9KVxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXkgfSlcbiAqXG4gKiBjb25zdCB2ZXJpZmllZCA9IFNlY3AyNTZrMS52ZXJpZnkoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHB1YmxpY0tleSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSB2ZXJpZmljYXRpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHBheWxvYWQgd2FzIHNpZ25lZCBieSB0aGUgcHJvdmlkZWQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBoYXNoLCBwYXlsb2FkLCBwdWJsaWNLZXksIHNpZ25hdHVyZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoYWRkcmVzcylcbiAgICAgICAgcmV0dXJuIEFkZHJlc3MuaXNFcXVhbChhZGRyZXNzLCByZWNvdmVyQWRkcmVzcyh7IHBheWxvYWQsIHNpZ25hdHVyZSB9KSk7XG4gICAgcmV0dXJuIHNlY3AyNTZrMS52ZXJpZnkoc2lnbmF0dXJlLCBCeXRlcy5mcm9tKHBheWxvYWQpLCBQdWJsaWNLZXkudG9CeXRlcyhwdWJsaWNLZXkpLCAuLi4oaGFzaCA/IFt7IHByZWhhc2g6IHRydWUsIGxvd1M6IHRydWUgfV0gOiBbXSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6WyJzZWNwMjU2azEiLCJBZGRyZXNzIiwiQnl0ZXMiLCJIZXgiLCJFbnRyb3B5IiwiUHVibGljS2V5Iiwibm9ibGUiLCJjcmVhdGVLZXlQYWlyIiwib3B0aW9ucyIsImFzIiwicHJpdmF0ZUtleSIsInJhbmRvbVByaXZhdGVLZXkiLCJwdWJsaWNLZXkiLCJnZXRQdWJsaWNLZXkiLCJwb2ludCIsIlByb2plY3RpdmVQb2ludCIsImZyb21Qcml2YXRlS2V5IiwiZnJvbSIsInNsaWNlIiwiZ2V0U2hhcmVkU2VjcmV0IiwiZnJvbUhleCIsInRvSGV4Iiwic2hhcmVkUG9pbnQiLCJtdWx0aXBseSIsInV0aWxzIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsInNoYXJlZFNlY3JldCIsInRvUmF3Qnl0ZXMiLCJmcm9tQnl0ZXMiLCJieXRlcyIsInJlY292ZXJBZGRyZXNzIiwiZnJvbVB1YmxpY0tleSIsInJlY292ZXJQdWJsaWNLZXkiLCJwYXlsb2FkIiwic2lnbmF0dXJlIiwiciIsInMiLCJ5UGFyaXR5Iiwic2lnbmF0dXJlXyIsIlNpZ25hdHVyZSIsIkJpZ0ludCIsImFkZFJlY292ZXJ5Qml0Iiwic3Vic3RyaW5nIiwic2lnbiIsImV4dHJhRW50cm9weSIsImhhc2giLCJyZWNvdmVyeSIsImxvd1MiLCJwcmVoYXNoIiwidmVyaWZ5IiwiYWRkcmVzcyIsImlzRXF1YWwiLCJ0b0J5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Signature.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Signature.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidRError: () => (/* binding */ InvalidRError),\n/* harmony export */   InvalidSError: () => (/* binding */ InvalidSError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidVError: () => (/* binding */ InvalidVError),\n/* harmony export */   InvalidYParityError: () => (/* binding */ InvalidYParityError),\n/* harmony export */   MissingPropertiesError: () => (/* binding */ MissingPropertiesError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromDerBytes: () => (/* binding */ fromDerBytes),\n/* harmony export */   fromDerHex: () => (/* binding */ fromDerHex),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromLegacy: () => (/* binding */ fromLegacy),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toDerBytes: () => (/* binding */ toDerBytes),\n/* harmony export */   toDerHex: () => (/* binding */ toDerHex),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toLegacy: () => (/* binding */ toLegacy),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   vToYParity: () => (/* binding */ vToYParity),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   yParityToV: () => (/* binding */ yParityToV)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Solidity.js */ \"(ssr)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */ function assert(signature, options = {}) {\n    const { recovered } = options;\n    if (typeof signature.r === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (typeof signature.s === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (recovered && typeof signature.yParity === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (signature.r < 0n || signature.r > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256) throw new InvalidRError({\n        value: signature.r\n    });\n    if (signature.s < 0n || signature.s > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256) throw new InvalidSError({\n        value: signature.s\n    });\n    if (typeof signature.yParity === \"number\" && signature.yParity !== 0 && signature.yParity !== 1) throw new InvalidYParityError({\n        value: signature.yParity\n    });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */ function fromBytes(signature) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */ function fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132) throw new InvalidSerializedSizeError({\n        signature\n    });\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 0, 32));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 32, 64));\n    const yParity = (()=>{\n        const yParity = Number(`0x${signature.slice(130)}`);\n        if (Number.isNaN(yParity)) return undefined;\n        try {\n            return vToYParity(yParity);\n        } catch  {\n            throw new InvalidYParityError({\n                value: yParity\n            });\n        }\n    })();\n    if (typeof yParity === \"undefined\") return {\n        r,\n        s\n    };\n    return {\n        r,\n        s,\n        yParity\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */ function extract(value) {\n    if (typeof value.r === \"undefined\") return undefined;\n    if (typeof value.s === \"undefined\") return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */ function from(signature) {\n    const signature_ = (()=>{\n        if (typeof signature === \"string\") return fromHex(signature);\n        if (signature instanceof Uint8Array) return fromBytes(signature);\n        if (typeof signature.r === \"string\") return fromRpc(signature);\n        if (signature.v) return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...typeof signature.yParity !== \"undefined\" ? {\n                yParity: signature.yParity\n            } : {}\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromDerBytes(signature) {\n    return fromDerHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromDerHex(signature) {\n    const { r, s } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromDER(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature).slice(2));\n    return {\n        r,\n        s\n    };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */ function fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v)\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */ function fromRpc(signature) {\n    const yParity = (()=>{\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === \"number\" && typeof yParity !== \"number\") yParity = vToYParity(v);\n        if (typeof yParity !== \"number\") throw new InvalidYParityError({\n            value: signature.yParity\n        });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === \"0x\" ? 0n : BigInt(r),\n        s: s === \"0x\" ? 0n : BigInt(s),\n        yParity: yParity === \"0x\" ? 0 : Number(yParity)\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */ function toBytes(signature) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */ function toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, {\n        size: 32\n    }), _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, {\n        size: 32\n    }), // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === \"number\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(yParityToV(signature.yParity), {\n        size: 1\n    }) : \"0x\");\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */ function toDerBytes(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */ function toDerHex(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return `0x${sig.toDERHex()}`;\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */ function toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity)\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */ function toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, {\n            size: 32\n        }),\n        s: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, {\n            size: 32\n        }),\n        yParity: yParity === 0 ? \"0x0\" : \"0x1\"\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */ function toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? \"0x01\" : \"0x\",\n        r === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r)),\n        s === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s))\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */ function validate(signature, options = {}) {\n    try {\n        assert(signature, options);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */ function vToYParity(v) {\n    if (v === 0 || v === 27) return 0;\n    if (v === 1 || v === 28) return 1;\n    if (v >= 35) return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({\n        value: v\n    });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */ function yParityToV(yParity) {\n    if (yParity === 0) return 27;\n    if (yParity === 1) return 28;\n    throw new InvalidYParityError({\n        value: yParity\n    });\n}\n/** Thrown when the serialized signature is of an invalid size. */ class InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }){\n        super(`Value \\`${signature}\\` is an invalid signature size.`, {\n            metaMessages: [\n                \"Expected: 64 bytes or 65 bytes.\",\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature))} bytes.`\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidSerializedSizeError\"\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */ class MissingPropertiesError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }){\n        super(`Signature \\`${_Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.MissingPropertiesError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */ class InvalidRError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidRError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */ class InvalidSError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidSError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */ class InvalidYParityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidYParityError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */ class InvalidVError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidVError\"\n        });\n    }\n} //# sourceMappingURL=Signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNoQjtBQUNFO0FBQ047QUFDRTtBQUNRO0FBQzFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDTSxTQUFTTSxPQUFPQyxTQUFTLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQzFDLE1BQU0sRUFBRUMsU0FBUyxFQUFFLEdBQUdEO0lBQ3RCLElBQUksT0FBT0QsVUFBVUcsQ0FBQyxLQUFLLGFBQ3ZCLE1BQU0sSUFBSUMsdUJBQXVCO1FBQUVKO0lBQVU7SUFDakQsSUFBSSxPQUFPQSxVQUFVSyxDQUFDLEtBQUssYUFDdkIsTUFBTSxJQUFJRCx1QkFBdUI7UUFBRUo7SUFBVTtJQUNqRCxJQUFJRSxhQUFhLE9BQU9GLFVBQVVNLE9BQU8sS0FBSyxhQUMxQyxNQUFNLElBQUlGLHVCQUF1QjtRQUFFSjtJQUFVO0lBQ2pELElBQUlBLFVBQVVHLENBQUMsR0FBRyxFQUFFLElBQUlILFVBQVVHLENBQUMsR0FBR0wsb0RBQW1CLEVBQ3JELE1BQU0sSUFBSVUsY0FBYztRQUFFQyxPQUFPVCxVQUFVRyxDQUFDO0lBQUM7SUFDakQsSUFBSUgsVUFBVUssQ0FBQyxHQUFHLEVBQUUsSUFBSUwsVUFBVUssQ0FBQyxHQUFHUCxvREFBbUIsRUFDckQsTUFBTSxJQUFJWSxjQUFjO1FBQUVELE9BQU9ULFVBQVVLLENBQUM7SUFBQztJQUNqRCxJQUFJLE9BQU9MLFVBQVVNLE9BQU8sS0FBSyxZQUM3Qk4sVUFBVU0sT0FBTyxLQUFLLEtBQ3RCTixVQUFVTSxPQUFPLEtBQUssR0FDdEIsTUFBTSxJQUFJSyxvQkFBb0I7UUFBRUYsT0FBT1QsVUFBVU0sT0FBTztJQUFDO0FBQ2pFO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxTQUFTTSxVQUFVWixTQUFTO0lBQy9CLE9BQU9hLFFBQVFqQiw4Q0FBYSxDQUFDSTtBQUNqQztBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTYSxRQUFRYixTQUFTO0lBQzdCLElBQUlBLFVBQVVjLE1BQU0sS0FBSyxPQUFPZCxVQUFVYyxNQUFNLEtBQUssS0FDakQsTUFBTSxJQUFJQywyQkFBMkI7UUFBRWY7SUFBVTtJQUNyRCxNQUFNRyxJQUFJYSxPQUFPcEIsMENBQVMsQ0FBQ0ksV0FBVyxHQUFHO0lBQ3pDLE1BQU1LLElBQUlXLE9BQU9wQiwwQ0FBUyxDQUFDSSxXQUFXLElBQUk7SUFDMUMsTUFBTU0sVUFBVSxDQUFDO1FBQ2IsTUFBTUEsVUFBVVksT0FBTyxDQUFDLEVBQUUsRUFBRWxCLFVBQVVpQixLQUFLLENBQUMsS0FBSyxDQUFDO1FBQ2xELElBQUlDLE9BQU9DLEtBQUssQ0FBQ2IsVUFDYixPQUFPYztRQUNYLElBQUk7WUFDQSxPQUFPQyxXQUFXZjtRQUN0QixFQUNBLE9BQU07WUFDRixNQUFNLElBQUlLLG9CQUFvQjtnQkFBRUYsT0FBT0g7WUFBUTtRQUNuRDtJQUNKO0lBQ0EsSUFBSSxPQUFPQSxZQUFZLGFBQ25CLE9BQU87UUFDSEg7UUFDQUU7SUFDSjtJQUNKLE9BQU87UUFDSEY7UUFDQUU7UUFDQUM7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDTSxTQUFTZ0IsUUFBUWIsS0FBSztJQUN6QixJQUFJLE9BQU9BLE1BQU1OLENBQUMsS0FBSyxhQUNuQixPQUFPaUI7SUFDWCxJQUFJLE9BQU9YLE1BQU1KLENBQUMsS0FBSyxhQUNuQixPQUFPZTtJQUNYLE9BQU9HLEtBQUtkO0FBQ2hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcURDLEdBQ00sU0FBU2MsS0FBS3ZCLFNBQVM7SUFDMUIsTUFBTXdCLGFBQWEsQ0FBQztRQUNoQixJQUFJLE9BQU94QixjQUFjLFVBQ3JCLE9BQU9hLFFBQVFiO1FBQ25CLElBQUlBLHFCQUFxQnlCLFlBQ3JCLE9BQU9iLFVBQVVaO1FBQ3JCLElBQUksT0FBT0EsVUFBVUcsQ0FBQyxLQUFLLFVBQ3ZCLE9BQU91QixRQUFRMUI7UUFDbkIsSUFBSUEsVUFBVTJCLENBQUMsRUFDWCxPQUFPQyxXQUFXNUI7UUFDdEIsT0FBTztZQUNIRyxHQUFHSCxVQUFVRyxDQUFDO1lBQ2RFLEdBQUdMLFVBQVVLLENBQUM7WUFDZCxHQUFJLE9BQU9MLFVBQVVNLE9BQU8sS0FBSyxjQUMzQjtnQkFBRUEsU0FBU04sVUFBVU0sT0FBTztZQUFDLElBQzdCLENBQUMsQ0FBQztRQUNaO0lBQ0o7SUFDQVAsT0FBT3lCO0lBQ1AsT0FBT0E7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVNLLGFBQWE3QixTQUFTO0lBQ2xDLE9BQU84QixXQUFXbEMsOENBQWEsQ0FBQ0k7QUFDcEM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLFNBQVM4QixXQUFXOUIsU0FBUztJQUNoQyxNQUFNLEVBQUVHLENBQUMsRUFBRUUsQ0FBQyxFQUFFLEdBQUdaLDhEQUFTQSxDQUFDc0MsU0FBUyxDQUFDQyxPQUFPLENBQUNwQyx5Q0FBUSxDQUFDSSxXQUFXaUIsS0FBSyxDQUFDO0lBQ3ZFLE9BQU87UUFBRWQ7UUFBR0U7SUFBRTtBQUNsQjtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTdUIsV0FBVzVCLFNBQVM7SUFDaEMsT0FBTztRQUNIRyxHQUFHSCxVQUFVRyxDQUFDO1FBQ2RFLEdBQUdMLFVBQVVLLENBQUM7UUFDZEMsU0FBU2UsV0FBV3JCLFVBQVUyQixDQUFDO0lBQ25DO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLFNBQVNELFFBQVExQixTQUFTO0lBQzdCLE1BQU1NLFVBQVUsQ0FBQztRQUNiLE1BQU1xQixJQUFJM0IsVUFBVTJCLENBQUMsR0FBR1QsT0FBT2xCLFVBQVUyQixDQUFDLElBQUlQO1FBQzlDLElBQUlkLFVBQVVOLFVBQVVNLE9BQU8sR0FBR1ksT0FBT2xCLFVBQVVNLE9BQU8sSUFBSWM7UUFDOUQsSUFBSSxPQUFPTyxNQUFNLFlBQVksT0FBT3JCLFlBQVksVUFDNUNBLFVBQVVlLFdBQVdNO1FBQ3pCLElBQUksT0FBT3JCLFlBQVksVUFDbkIsTUFBTSxJQUFJSyxvQkFBb0I7WUFBRUYsT0FBT1QsVUFBVU0sT0FBTztRQUFDO1FBQzdELE9BQU9BO0lBQ1g7SUFDQSxPQUFPO1FBQ0hILEdBQUdhLE9BQU9oQixVQUFVRyxDQUFDO1FBQ3JCRSxHQUFHVyxPQUFPaEIsVUFBVUssQ0FBQztRQUNyQkM7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBUzJCLFVBQVVDLEtBQUs7SUFDM0IsTUFBTSxDQUFDNUIsU0FBU0gsR0FBR0UsRUFBRSxHQUFHNkI7SUFDeEIsT0FBT1gsS0FBSztRQUNScEIsR0FBR0EsTUFBTSxPQUFPLEVBQUUsR0FBR2EsT0FBT2I7UUFDNUJFLEdBQUdBLE1BQU0sT0FBTyxFQUFFLEdBQUdXLE9BQU9YO1FBQzVCQyxTQUFTQSxZQUFZLE9BQU8sSUFBSVksT0FBT1o7SUFDM0M7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVM2QixRQUFRbkMsU0FBUztJQUM3QixPQUFPTiw4Q0FBYSxDQUFDMEMsTUFBTXBDO0FBQy9CO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBU29DLE1BQU1wQyxTQUFTO0lBQzNCRCxPQUFPQztJQUNQLE1BQU1HLElBQUlILFVBQVVHLENBQUM7SUFDckIsTUFBTUUsSUFBSUwsVUFBVUssQ0FBQztJQUNyQixNQUFNbUIsYUFBYTVCLDJDQUFVLENBQUNBLCtDQUFjLENBQUNPLEdBQUc7UUFBRW9DLE1BQU07SUFBRyxJQUFJM0MsK0NBQWMsQ0FBQ1MsR0FBRztRQUFFa0MsTUFBTTtJQUFHLElBQzVGLHlFQUF5RTtJQUN6RSxPQUFPdkMsVUFBVU0sT0FBTyxLQUFLLFdBQ3ZCViwrQ0FBYyxDQUFDNEMsV0FBV3hDLFVBQVVNLE9BQU8sR0FBRztRQUFFaUMsTUFBTTtJQUFFLEtBQ3hEO0lBQ04sT0FBT2Y7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDTSxTQUFTaUIsV0FBV3pDLFNBQVM7SUFDaEMsTUFBTTBDLE1BQU0sSUFBSWpELDhEQUFTQSxDQUFDc0MsU0FBUyxDQUFDL0IsVUFBVUcsQ0FBQyxFQUFFSCxVQUFVSyxDQUFDO0lBQzVELE9BQU9xQyxJQUFJQyxhQUFhO0FBQzVCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVNDLFNBQVM1QyxTQUFTO0lBQzlCLE1BQU0wQyxNQUFNLElBQUlqRCw4REFBU0EsQ0FBQ3NDLFNBQVMsQ0FBQy9CLFVBQVVHLENBQUMsRUFBRUgsVUFBVUssQ0FBQztJQUM1RCxPQUFPLENBQUMsRUFBRSxFQUFFcUMsSUFBSUcsUUFBUSxHQUFHLENBQUM7QUFDaEM7QUFDQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sU0FBU0MsU0FBUzlDLFNBQVM7SUFDOUIsT0FBTztRQUNIRyxHQUFHSCxVQUFVRyxDQUFDO1FBQ2RFLEdBQUdMLFVBQVVLLENBQUM7UUFDZHNCLEdBQUdhLFdBQVd4QyxVQUFVTSxPQUFPO0lBQ25DO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLFNBQVN5QyxNQUFNL0MsU0FBUztJQUMzQixNQUFNLEVBQUVHLENBQUMsRUFBRUUsQ0FBQyxFQUFFQyxPQUFPLEVBQUUsR0FBR047SUFDMUIsT0FBTztRQUNIRyxHQUFHUCwrQ0FBYyxDQUFDTyxHQUFHO1lBQUVvQyxNQUFNO1FBQUc7UUFDaENsQyxHQUFHVCwrQ0FBYyxDQUFDUyxHQUFHO1lBQUVrQyxNQUFNO1FBQUc7UUFDaENqQyxTQUFTQSxZQUFZLElBQUksUUFBUTtJQUNyQztBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBUzBDLFFBQVFoRCxTQUFTO0lBQzdCLE1BQU0sRUFBRUcsQ0FBQyxFQUFFRSxDQUFDLEVBQUVDLE9BQU8sRUFBRSxHQUFHTjtJQUMxQixPQUFPO1FBQ0hNLFVBQVUsU0FBUztRQUNuQkgsTUFBTSxFQUFFLEdBQUcsT0FBT1AsNkNBQVksQ0FBQ0EsK0NBQWMsQ0FBQ087UUFDOUNFLE1BQU0sRUFBRSxHQUFHLE9BQU9ULDZDQUFZLENBQUNBLCtDQUFjLENBQUNTO0tBQ2pEO0FBQ0w7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLFNBQVM2QyxTQUFTbEQsU0FBUyxFQUFFQyxVQUFVLENBQUMsQ0FBQztJQUM1QyxJQUFJO1FBQ0FGLE9BQU9DLFdBQVdDO1FBQ2xCLE9BQU87SUFDWCxFQUNBLE9BQU07UUFDRixPQUFPO0lBQ1g7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTb0IsV0FBV00sQ0FBQztJQUN4QixJQUFJQSxNQUFNLEtBQUtBLE1BQU0sSUFDakIsT0FBTztJQUNYLElBQUlBLE1BQU0sS0FBS0EsTUFBTSxJQUNqQixPQUFPO0lBQ1gsSUFBSUEsS0FBSyxJQUNMLE9BQU9BLElBQUksTUFBTSxJQUFJLElBQUk7SUFDN0IsTUFBTSxJQUFJd0IsY0FBYztRQUFFMUMsT0FBT2tCO0lBQUU7QUFDdkM7QUFDQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sU0FBU2EsV0FBV2xDLE9BQU87SUFDOUIsSUFBSUEsWUFBWSxHQUNaLE9BQU87SUFDWCxJQUFJQSxZQUFZLEdBQ1osT0FBTztJQUNYLE1BQU0sSUFBSUssb0JBQW9CO1FBQUVGLE9BQU9IO0lBQVE7QUFDbkQ7QUFDQSxnRUFBZ0UsR0FDekQsTUFBTVMsbUNBQW1DcEIsaURBQWdCO0lBQzVEMEQsWUFBWSxFQUFFckQsU0FBUyxFQUFFLENBQUU7UUFDdkIsS0FBSyxDQUFDLENBQUMsUUFBUSxFQUFFQSxVQUFVLGdDQUFnQyxDQUFDLEVBQUU7WUFDMURzRCxjQUFjO2dCQUNWO2dCQUNBLENBQUMsU0FBUyxFQUFFMUQseUNBQVEsQ0FBQ0EseUNBQVEsQ0FBQ0ksWUFBWSxPQUFPLENBQUM7YUFDckQ7UUFDTDtRQUNBdUQsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWbEQsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBLG9GQUFvRixHQUM3RSxNQUFNTCwrQkFBK0JULGlEQUFnQjtJQUN4RDBELFlBQVksRUFBRXJELFNBQVMsRUFBRSxDQUFFO1FBQ3ZCLEtBQUssQ0FBQyxDQUFDLFlBQVksRUFBRUgsK0NBQWMsQ0FBQ0csV0FBVyw4REFBOEQsQ0FBQztRQUM5R3VELE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVmxELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSx3REFBd0QsR0FDakQsTUFBTUQsc0JBQXNCYixpREFBZ0I7SUFDL0MwRCxZQUFZLEVBQUU1QyxLQUFLLEVBQUUsQ0FBRTtRQUNuQixLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUVBLE1BQU0sdUVBQXVFLENBQUM7UUFDL0Y4QyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZsRCxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0Esd0RBQXdELEdBQ2pELE1BQU1DLHNCQUFzQmYsaURBQWdCO0lBQy9DMEQsWUFBWSxFQUFFNUMsS0FBSyxFQUFFLENBQUU7UUFDbkIsS0FBSyxDQUFDLENBQUMsUUFBUSxFQUFFQSxNQUFNLHVFQUF1RSxDQUFDO1FBQy9GOEMsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWbEQsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBLDhEQUE4RCxHQUN2RCxNQUFNRSw0QkFBNEJoQixpREFBZ0I7SUFDckQwRCxZQUFZLEVBQUU1QyxLQUFLLEVBQUUsQ0FBRTtRQUNuQixLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUVBLE1BQU0seURBQXlELENBQUM7UUFDakY4QyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZsRCxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0Esd0RBQXdELEdBQ2pELE1BQU0wQyxzQkFBc0J4RCxpREFBZ0I7SUFDL0MwRCxZQUFZLEVBQUU1QyxLQUFLLEVBQUUsQ0FBRTtRQUNuQixLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUVBLE1BQU0sbURBQW1ELENBQUM7UUFDM0U4QyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZsRCxPQUFPO1FBQ1g7SUFDSjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjNDMzNy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU2lnbmF0dXJlLmpzP2VkZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi9Kc29uLmpzJztcbmltcG9ydCAqIGFzIFNvbGlkaXR5IGZyb20gJy4vU29saWRpdHkuanMnO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSBTaWduYXR1cmUgaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuYXNzZXJ0KHtcbiAqICAgcjogLTQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBlcnJvcjogSW52YWxpZFNpZ25hdHVyZVJFcnJvcjpcbiAqIC8vIEBlcnJvcjogVmFsdWUgYC01NDkuLi5uYCBpcyBhbiBpbnZhbGlkIHIgdmFsdWUuXG4gKiAvLyBAZXJyb3I6IHIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIDJeMjU2LlxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgb2JqZWN0IHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChzaWduYXR1cmUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcmVjb3ZlcmVkIH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS5zID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgaWYgKHJlY292ZXJlZCAmJiB0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAoc2lnbmF0dXJlLnIgPCAwbiB8fCBzaWduYXR1cmUuciA+IFNvbGlkaXR5Lm1heFVpbnQyNTYpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUkVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS5yIH0pO1xuICAgIGlmIChzaWduYXR1cmUucyA8IDBuIHx8IHNpZ25hdHVyZS5zID4gU29saWRpdHkubWF4VWludDI1NilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTRXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnMgfSk7XG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgc2lnbmF0dXJlLnlQYXJpdHkgIT09IDAgJiZcbiAgICAgICAgc2lnbmF0dXJlLnlQYXJpdHkgIT09IDEpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS55UGFyaXR5IH0pO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHNpZ25hdHVyZSBpbnRvIGEgc3RydWN0dXJlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkoWzEyOCwgMywgMTMxLCAuLi5dKSlcbiAqIC8vIEBsb2c6IHsgcjogNTIzMS4uLm4sIHM6IDM1MjIuLi5uLCB5UGFyaXR5OiAwIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgZGVzZXJpYWxpemVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyhzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZnJvbUhleChIZXguZnJvbUJ5dGVzKHNpZ25hdHVyZSkpO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gc2lnbmF0dXJlIGludG8gYSBzdHJ1Y3R1cmVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tSGV4KCcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MWMnKVxuICogLy8gQGxvZzogeyByOiA1MjMxLi4ubiwgczogMzUyMi4uLm4sIHlQYXJpdHk6IDAgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWQgLSBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgZGVzZXJpYWxpemVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgoc2lnbmF0dXJlKSB7XG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMCAmJiBzaWduYXR1cmUubGVuZ3RoICE9PSAxMzIpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBjb25zdCByID0gQmlnSW50KEhleC5zbGljZShzaWduYXR1cmUsIDAsIDMyKSk7XG4gICAgY29uc3QgcyA9IEJpZ0ludChIZXguc2xpY2Uoc2lnbmF0dXJlLCAzMiwgNjQpKTtcbiAgICBjb25zdCB5UGFyaXR5ID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgeVBhcml0eSA9IE51bWJlcihgMHgke3NpZ25hdHVyZS5zbGljZSgxMzApfWApO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHlQYXJpdHkpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2VG9ZUGFyaXR5KHlQYXJpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHlQYXJpdHkgfSk7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIGlmICh0eXBlb2YgeVBhcml0eSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICByLFxuICAgICAgICBzLFxuICAgICAgICB5UGFyaXR5LFxuICAgIH07XG59XG4vKipcbiAqIEV4dHJhY3RzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGZyb20gYW4gYXJiaXRyYXJ5IG9iamVjdCB0aGF0IG1heSBpbmNsdWRlIHNpZ25hdHVyZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZXh0cmFjdCh7XG4gKiAgIGJhejogJ2JhcnJ5JyxcbiAqICAgZm9vOiAnYmFyJyxcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiAgIHplYnJhOiAnc3RyaXBlcycsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMVxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFyYml0cmFyeSBvYmplY3QgdG8gZXh0cmFjdCB0aGUgc2lnbmF0dXJlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgZXh0cmFjdGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3QodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlLnIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUucyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGZyb20odmFsdWUpO1xufVxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYSB0eXBlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gb2JqZWN0IGZyb20gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0sIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fSwge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSwgb3Ige0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gU2VyaWFsaXplZFxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbSgnMHg2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiODAxJylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDEsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gTGVnYWN5XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tKHtcbiAqICAgcjogNDczMjM0NTcwMDc0NTM2NTcyMDc4ODk3MzAyNDM4MjY5NjU3NjE5MjIyOTY1OTk2ODA0NzM4ODY1ODgyODcwMTU3NTU2NTI3MDEwNzJuLFxuICogICBzOiA1NzIyODgwMzIwMjcyNzEzMTUwMjk0OTM1ODMxMzQ1NjA3MTI4MDQ4ODE4NDI3MDI1ODI5MzY3NDI0MjEyNDM0MDExMzgyNDg4Mjc4OG4sXG4gKiAgIHY6IDI3LFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDczMjM0NTcwMDc0NTM2NTcyMDc4ODk3MzAyNDM4MjY5NjU3NjE5MjIyOTY1OTk2ODA0NzM4ODY1ODgyODcwMTU3NTU2NTI3MDEwNzJuLFxuICogLy8gQGxvZzogICBzOiA1NzIyODgwMzIwMjcyNzEzMTUwMjk0OTM1ODMxMzQ1NjA3MTI4MDQ4ODE4NDI3MDI1ODI5MzY3NDI0MjEyNDM0MDExMzgyNDg4Mjc4OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDBcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHZhbHVlIHRvIGluc3RhbnRpYXRlLlxuICogQHJldHVybnMgVGhlIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZV8gPSAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUhleChzaWduYXR1cmUpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tQnl0ZXMoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUuciA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZnJvbVJwYyhzaWduYXR1cmUpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlLnYpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUxlZ2FjeShzaWduYXR1cmUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgICAgICBzOiBzaWduYXR1cmUucyxcbiAgICAgICAgICAgIC4uLih0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB7IHlQYXJpdHk6IHNpZ25hdHVyZS55UGFyaXR5IH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGFzc2VydChzaWduYXR1cmVfKTtcbiAgICByZXR1cm4gc2lnbmF0dXJlXztcbn1cbi8qKlxuICogQ29udmVydHMgYSBERVItZW5jb2RlZCBzaWduYXR1cmUgdG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tRGVyQnl0ZXMobmV3IFVpbnQ4QXJyYXkoWzEzMiwgNTEsIDIzLCAuLi5dKSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21EZXJCeXRlcyhzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZnJvbURlckhleChIZXguZnJvbUJ5dGVzKHNpZ25hdHVyZSkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tRGVySGV4KCcweDMwNDQwMjIwNmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjAyMjA0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21EZXJIZXgoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeyByLCBzIH0gPSBzZWNwMjU2azEuU2lnbmF0dXJlLmZyb21ERVIoSGV4LmZyb20oc2lnbmF0dXJlKS5zbGljZSgyKSk7XG4gICAgcmV0dXJuIHsgciwgcyB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgbGVnYWN5ID0gU2lnbmF0dXJlLmZyb21MZWdhY3koeyByOiAxbiwgczogMm4sIHY6IDI4IH0pXG4gKiAvLyBAbG9nOiB7IHI6IDFuLCBzOiAybiwgeVBhcml0eTogMSB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTGVnYWN5KHNpZ25hdHVyZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IHNpZ25hdHVyZS5yLFxuICAgICAgICBzOiBzaWduYXR1cmUucyxcbiAgICAgICAgeVBhcml0eTogdlRvWVBhcml0eShzaWduYXR1cmUudiksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30gaW50byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tUnBjKHtcbiAqICAgcjogJzB4NjM1ZGMyMDMzZTYwMTg1YmIzNjcwOWMyOWM3NWQ2NGVhNTFkZmJkOTFjMzJlZjRiZTE5OGU0Y2ViMTY5ZmI0ZCcsXG4gKiAgIHM6ICcweDUwYzI2NjdhYzRjNzcxMDcyNzQ2YWNmZGNmMWYxNDgzMzM2ZGNjYThiZDJkZjQ3Y2Q4MzE3NWRiZTYwZjA1NDAnLFxuICogICB5UGFyaXR5OiAnMHgwJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuUnBjfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHlQYXJpdHkgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCB2ID0gc2lnbmF0dXJlLnYgPyBOdW1iZXIoc2lnbmF0dXJlLnYpIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgeVBhcml0eSA9IHNpZ25hdHVyZS55UGFyaXR5ID8gTnVtYmVyKHNpZ25hdHVyZS55UGFyaXR5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeVBhcml0eSAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB5UGFyaXR5ID0gdlRvWVBhcml0eSh2KTtcbiAgICAgICAgaWYgKHR5cGVvZiB5UGFyaXR5ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS55UGFyaXR5IH0pO1xuICAgICAgICByZXR1cm4geVBhcml0eTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IEJpZ0ludChzaWduYXR1cmUuciksXG4gICAgICAgIHM6IEJpZ0ludChzaWduYXR1cmUucyksXG4gICAgICAgIHlQYXJpdHksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfSB0byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tVHVwbGUoWycweDAxJywgJzB4N2InLCAnMHgxYzgnXSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogMTIzbixcbiAqIC8vIEBsb2c6ICAgczogNDU2bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMSxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0dXBsZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UdXBsZSh0dXBsZSkge1xuICAgIGNvbnN0IFt5UGFyaXR5LCByLCBzXSA9IHR1cGxlO1xuICAgIHJldHVybiBmcm9tKHtcbiAgICAgICAgcjogciA9PT0gJzB4JyA/IDBuIDogQmlnSW50KHIpLFxuICAgICAgICBzOiBzID09PSAnMHgnID8gMG4gOiBCaWdJbnQocyksXG4gICAgICAgIHlQYXJpdHk6IHlQYXJpdHkgPT09ICcweCcgPyAwIDogTnVtYmVyKHlQYXJpdHkpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9CeXRlcyh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxXG4gKiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMTAyLCAxNiwgMTAsIC4uLl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodG9IZXgoc2lnbmF0dXJlKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8ge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLnRvSGV4KHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDFcbiAqIH0pXG4gKiAvLyBAbG9nOiAnMHg2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiODFjJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoc2lnbmF0dXJlKSB7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZSk7XG4gICAgY29uc3QgciA9IHNpZ25hdHVyZS5yO1xuICAgIGNvbnN0IHMgPSBzaWduYXR1cmUucztcbiAgICBjb25zdCBzaWduYXR1cmVfID0gSGV4LmNvbmNhdChIZXguZnJvbU51bWJlcihyLCB7IHNpemU6IDMyIH0pLCBIZXguZnJvbU51bWJlcihzLCB7IHNpemU6IDMyIH0pLCBcbiAgICAvLyBJZiB0aGUgc2lnbmF0dXJlIGlzIHJlY292ZXJlZCwgYWRkIHRoZSByZWNvdmVyeSBieXRlIHRvIHRoZSBzaWduYXR1cmUuXG4gICAgdHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ID09PSAnbnVtYmVyJ1xuICAgICAgICA/IEhleC5mcm9tTnVtYmVyKHlQYXJpdHlUb1Yoc2lnbmF0dXJlLnlQYXJpdHkpLCB7IHNpemU6IDEgfSlcbiAgICAgICAgOiAnMHgnKTtcbiAgICByZXR1cm4gc2lnbmF0dXJlXztcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gREVSLWVuY29kZWQgZm9ybWF0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlX2RlciA9IFNpZ25hdHVyZS50b0RlckJ5dGVzKHNpZ25hdHVyZSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWzEzMiwgNTEsIDIzLCAuLi5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGVyQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnID0gbmV3IHNlY3AyNTZrMS5TaWduYXR1cmUoc2lnbmF0dXJlLnIsIHNpZ25hdHVyZS5zKTtcbiAgICByZXR1cm4gc2lnLnRvREVSUmF3Qnl0ZXMoKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gREVSLWVuY29kZWQgZm9ybWF0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlX2RlciA9IFNpZ25hdHVyZS50b0RlckhleChzaWduYXR1cmUpXG4gKiAvLyBAbG9nOiAnMHgzMDQ0MDIyMDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmYwMjIwNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiOCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZXJIZXgoc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnID0gbmV3IHNlY3AyNTZrMS5TaWduYXR1cmUoc2lnbmF0dXJlLnIsIHNpZ25hdHVyZS5zKTtcbiAgICByZXR1cm4gYDB4JHtzaWcudG9ERVJIZXgoKX1gO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgbGVnYWN5ID0gU2lnbmF0dXJlLnRvTGVnYWN5KHsgcjogMW4sIHM6IDJuLCB5UGFyaXR5OiAxIH0pXG4gKiAvLyBAbG9nOiB7IHI6IDFuLCBzOiAybiwgdjogMjggfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9MZWdhY3koc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICB2OiB5UGFyaXR5VG9WKHNpZ25hdHVyZS55UGFyaXR5KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLnRvUnBjKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDFcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMsIHlQYXJpdHkgfSA9IHNpZ25hdHVyZTtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBIZXguZnJvbU51bWJlcihyLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICBzOiBIZXguZnJvbU51bWJlcihzLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICB5UGFyaXR5OiB5UGFyaXR5ID09PSAwID8gJzB4MCcgOiAnMHgxJyxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBhIHNlcmlhbGl6ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5UdXBsZX0gdG8gYmUgdXNlZCBmb3Igc2lnbmF0dXJlcyBpbiBUcmFuc2FjdGlvbiBFbnZlbG9wZXMsIEVJUC03NzAyIEF1dGhvcml6YXRpb24gTGlzdHMsIGV0Yy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZVR1cGxlID0gU2lnbmF0dXJlLnRvVHVwbGUoe1xuICogICByOiAxMjNuLFxuICogICBzOiA0NTZuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IFt5UGFyaXR5OiAnMHgwMScsIHI6ICcweDdiJywgczogJzB4MWM4J11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5UdXBsZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R1cGxlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcywgeVBhcml0eSB9ID0gc2lnbmF0dXJlO1xuICAgIHJldHVybiBbXG4gICAgICAgIHlQYXJpdHkgPyAnMHgwMScgOiAnMHgnLFxuICAgICAgICByID09PSAwbiA/ICcweCcgOiBIZXgudHJpbUxlZnQoSGV4LmZyb21OdW1iZXIocikpLFxuICAgICAgICBzID09PSAwbiA/ICcweCcgOiBIZXgudHJpbUxlZnQoSGV4LmZyb21OdW1iZXIocykpLFxuICAgIF07XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIFNpZ25hdHVyZS4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFNpZ25hdHVyZS52YWxpZGF0ZSh7XG4gKiAgIHI6IC00OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgb2JqZWN0IHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHNpZ25hdHVyZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHNpZ25hdHVyZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgRUNEU0EgYHZgIHZhbHVlIHRvIGEgYHlQYXJpdHlgIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeVBhcml0eSA9IFNpZ25hdHVyZS52VG9ZUGFyaXR5KDI4KVxuICogLy8gQGxvZzogMVxuICogYGBgXG4gKlxuICogQHBhcmFtIHYgLSBUaGUgRUNEU0EgYHZgIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYHlQYXJpdHlgIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdlRvWVBhcml0eSh2KSB7XG4gICAgaWYgKHYgPT09IDAgfHwgdiA9PT0gMjcpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmICh2ID09PSAxIHx8IHYgPT09IDI4KVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodiA+PSAzNSlcbiAgICAgICAgcmV0dXJuIHYgJSAyID09PSAwID8gMSA6IDA7XG4gICAgdGhyb3cgbmV3IEludmFsaWRWRXJyb3IoeyB2YWx1ZTogdiB9KTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBFQ0RTQSBgdmAgdmFsdWUgdG8gYSBgeVBhcml0eWAgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2ID0gU2lnbmF0dXJlLnlQYXJpdHlUb1YoMSlcbiAqIC8vIEBsb2c6IDI4XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0geVBhcml0eSAtIFRoZSBFQ0RTQSBgeVBhcml0eWAgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBgdmAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5UGFyaXR5VG9WKHlQYXJpdHkpIHtcbiAgICBpZiAoeVBhcml0eSA9PT0gMClcbiAgICAgICAgcmV0dXJuIDI3O1xuICAgIGlmICh5UGFyaXR5ID09PSAxKVxuICAgICAgICByZXR1cm4gMjg7XG4gICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogeVBhcml0eSB9KTtcbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2VyaWFsaXplZCBzaWduYXR1cmUgaXMgb2YgYW4gaW52YWxpZCBzaXplLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHtzaWduYXR1cmV9XFxgIGlzIGFuIGludmFsaWQgc2lnbmF0dXJlIHNpemUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkOiA2NCBieXRlcyBvciA2NSBieXRlcy4nLFxuICAgICAgICAgICAgICAgIGBSZWNlaXZlZCAke0hleC5zaXplKEhleC5mcm9tKHNpZ25hdHVyZSkpfSBieXRlcy5gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGlzIG1pc3NpbmcgZWl0aGVyIGFuIGByYCwgYHNgLCBvciBgeVBhcml0eWAgcHJvcGVydHkuICovXG5leHBvcnQgY2xhc3MgTWlzc2luZ1Byb3BlcnRpZXNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2lnbmF0dXJlIH0pIHtcbiAgICAgICAgc3VwZXIoYFNpZ25hdHVyZSBcXGAke0pzb24uc3RyaW5naWZ5KHNpZ25hdHVyZSl9XFxgIGlzIG1pc3NpbmcgZWl0aGVyIGFuIFxcYHJcXGAsIFxcYHNcXGAsIG9yIFxcYHlQYXJpdHlcXGAgcHJvcGVydHkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuTWlzc2luZ1Byb3BlcnRpZXNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHJgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRSRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgciB2YWx1ZS4gciBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gMl4yNTYuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFJFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHNgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgcyB2YWx1ZS4gcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gMl4yNTYuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHlQYXJpdHlgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRZUGFyaXR5RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgeS1wYXJpdHkgdmFsdWUuIFktcGFyaXR5IG11c3QgYmUgMCBvciAxLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRZUGFyaXR5RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGhhcyBhbiBpbnZhbGlkIGB2YCB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHYgdmFsdWUuIHYgbXVzdCBiZSAyNywgMjggb3IgPj0zNS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkVkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbInNlY3AyNTZrMSIsIkJ5dGVzIiwiRXJyb3JzIiwiSGV4IiwiSnNvbiIsIlNvbGlkaXR5IiwiYXNzZXJ0Iiwic2lnbmF0dXJlIiwib3B0aW9ucyIsInJlY292ZXJlZCIsInIiLCJNaXNzaW5nUHJvcGVydGllc0Vycm9yIiwicyIsInlQYXJpdHkiLCJtYXhVaW50MjU2IiwiSW52YWxpZFJFcnJvciIsInZhbHVlIiwiSW52YWxpZFNFcnJvciIsIkludmFsaWRZUGFyaXR5RXJyb3IiLCJmcm9tQnl0ZXMiLCJmcm9tSGV4IiwibGVuZ3RoIiwiSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IiLCJCaWdJbnQiLCJzbGljZSIsIk51bWJlciIsImlzTmFOIiwidW5kZWZpbmVkIiwidlRvWVBhcml0eSIsImV4dHJhY3QiLCJmcm9tIiwic2lnbmF0dXJlXyIsIlVpbnQ4QXJyYXkiLCJmcm9tUnBjIiwidiIsImZyb21MZWdhY3kiLCJmcm9tRGVyQnl0ZXMiLCJmcm9tRGVySGV4IiwiU2lnbmF0dXJlIiwiZnJvbURFUiIsImZyb21UdXBsZSIsInR1cGxlIiwidG9CeXRlcyIsInRvSGV4IiwiY29uY2F0IiwiZnJvbU51bWJlciIsInNpemUiLCJ5UGFyaXR5VG9WIiwidG9EZXJCeXRlcyIsInNpZyIsInRvREVSUmF3Qnl0ZXMiLCJ0b0RlckhleCIsInRvREVSSGV4IiwidG9MZWdhY3kiLCJ0b1JwYyIsInRvVHVwbGUiLCJ0cmltTGVmdCIsInZhbGlkYXRlIiwiSW52YWxpZFZFcnJvciIsIkJhc2VFcnJvciIsImNvbnN0cnVjdG9yIiwibWV0YU1lc3NhZ2VzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJzdHJpbmdpZnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Solidity.js":
/*!***********************************************!*\
  !*** ./node_modules/ox/_esm/core/Solidity.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayRegex: () => (/* binding */ arrayRegex),\n/* harmony export */   bytesRegex: () => (/* binding */ bytesRegex),\n/* harmony export */   integerRegex: () => (/* binding */ integerRegex),\n/* harmony export */   maxInt104: () => (/* binding */ maxInt104),\n/* harmony export */   maxInt112: () => (/* binding */ maxInt112),\n/* harmony export */   maxInt120: () => (/* binding */ maxInt120),\n/* harmony export */   maxInt128: () => (/* binding */ maxInt128),\n/* harmony export */   maxInt136: () => (/* binding */ maxInt136),\n/* harmony export */   maxInt144: () => (/* binding */ maxInt144),\n/* harmony export */   maxInt152: () => (/* binding */ maxInt152),\n/* harmony export */   maxInt16: () => (/* binding */ maxInt16),\n/* harmony export */   maxInt160: () => (/* binding */ maxInt160),\n/* harmony export */   maxInt168: () => (/* binding */ maxInt168),\n/* harmony export */   maxInt176: () => (/* binding */ maxInt176),\n/* harmony export */   maxInt184: () => (/* binding */ maxInt184),\n/* harmony export */   maxInt192: () => (/* binding */ maxInt192),\n/* harmony export */   maxInt200: () => (/* binding */ maxInt200),\n/* harmony export */   maxInt208: () => (/* binding */ maxInt208),\n/* harmony export */   maxInt216: () => (/* binding */ maxInt216),\n/* harmony export */   maxInt224: () => (/* binding */ maxInt224),\n/* harmony export */   maxInt232: () => (/* binding */ maxInt232),\n/* harmony export */   maxInt24: () => (/* binding */ maxInt24),\n/* harmony export */   maxInt240: () => (/* binding */ maxInt240),\n/* harmony export */   maxInt248: () => (/* binding */ maxInt248),\n/* harmony export */   maxInt256: () => (/* binding */ maxInt256),\n/* harmony export */   maxInt32: () => (/* binding */ maxInt32),\n/* harmony export */   maxInt40: () => (/* binding */ maxInt40),\n/* harmony export */   maxInt48: () => (/* binding */ maxInt48),\n/* harmony export */   maxInt56: () => (/* binding */ maxInt56),\n/* harmony export */   maxInt64: () => (/* binding */ maxInt64),\n/* harmony export */   maxInt72: () => (/* binding */ maxInt72),\n/* harmony export */   maxInt8: () => (/* binding */ maxInt8),\n/* harmony export */   maxInt80: () => (/* binding */ maxInt80),\n/* harmony export */   maxInt88: () => (/* binding */ maxInt88),\n/* harmony export */   maxInt96: () => (/* binding */ maxInt96),\n/* harmony export */   maxUint104: () => (/* binding */ maxUint104),\n/* harmony export */   maxUint112: () => (/* binding */ maxUint112),\n/* harmony export */   maxUint120: () => (/* binding */ maxUint120),\n/* harmony export */   maxUint128: () => (/* binding */ maxUint128),\n/* harmony export */   maxUint136: () => (/* binding */ maxUint136),\n/* harmony export */   maxUint144: () => (/* binding */ maxUint144),\n/* harmony export */   maxUint152: () => (/* binding */ maxUint152),\n/* harmony export */   maxUint16: () => (/* binding */ maxUint16),\n/* harmony export */   maxUint160: () => (/* binding */ maxUint160),\n/* harmony export */   maxUint168: () => (/* binding */ maxUint168),\n/* harmony export */   maxUint176: () => (/* binding */ maxUint176),\n/* harmony export */   maxUint184: () => (/* binding */ maxUint184),\n/* harmony export */   maxUint192: () => (/* binding */ maxUint192),\n/* harmony export */   maxUint200: () => (/* binding */ maxUint200),\n/* harmony export */   maxUint208: () => (/* binding */ maxUint208),\n/* harmony export */   maxUint216: () => (/* binding */ maxUint216),\n/* harmony export */   maxUint224: () => (/* binding */ maxUint224),\n/* harmony export */   maxUint232: () => (/* binding */ maxUint232),\n/* harmony export */   maxUint24: () => (/* binding */ maxUint24),\n/* harmony export */   maxUint240: () => (/* binding */ maxUint240),\n/* harmony export */   maxUint248: () => (/* binding */ maxUint248),\n/* harmony export */   maxUint256: () => (/* binding */ maxUint256),\n/* harmony export */   maxUint32: () => (/* binding */ maxUint32),\n/* harmony export */   maxUint40: () => (/* binding */ maxUint40),\n/* harmony export */   maxUint48: () => (/* binding */ maxUint48),\n/* harmony export */   maxUint56: () => (/* binding */ maxUint56),\n/* harmony export */   maxUint64: () => (/* binding */ maxUint64),\n/* harmony export */   maxUint72: () => (/* binding */ maxUint72),\n/* harmony export */   maxUint8: () => (/* binding */ maxUint8),\n/* harmony export */   maxUint80: () => (/* binding */ maxUint80),\n/* harmony export */   maxUint88: () => (/* binding */ maxUint88),\n/* harmony export */   maxUint96: () => (/* binding */ maxUint96),\n/* harmony export */   minInt104: () => (/* binding */ minInt104),\n/* harmony export */   minInt112: () => (/* binding */ minInt112),\n/* harmony export */   minInt120: () => (/* binding */ minInt120),\n/* harmony export */   minInt128: () => (/* binding */ minInt128),\n/* harmony export */   minInt136: () => (/* binding */ minInt136),\n/* harmony export */   minInt144: () => (/* binding */ minInt144),\n/* harmony export */   minInt152: () => (/* binding */ minInt152),\n/* harmony export */   minInt16: () => (/* binding */ minInt16),\n/* harmony export */   minInt160: () => (/* binding */ minInt160),\n/* harmony export */   minInt168: () => (/* binding */ minInt168),\n/* harmony export */   minInt176: () => (/* binding */ minInt176),\n/* harmony export */   minInt184: () => (/* binding */ minInt184),\n/* harmony export */   minInt192: () => (/* binding */ minInt192),\n/* harmony export */   minInt200: () => (/* binding */ minInt200),\n/* harmony export */   minInt208: () => (/* binding */ minInt208),\n/* harmony export */   minInt216: () => (/* binding */ minInt216),\n/* harmony export */   minInt224: () => (/* binding */ minInt224),\n/* harmony export */   minInt232: () => (/* binding */ minInt232),\n/* harmony export */   minInt24: () => (/* binding */ minInt24),\n/* harmony export */   minInt240: () => (/* binding */ minInt240),\n/* harmony export */   minInt248: () => (/* binding */ minInt248),\n/* harmony export */   minInt256: () => (/* binding */ minInt256),\n/* harmony export */   minInt32: () => (/* binding */ minInt32),\n/* harmony export */   minInt40: () => (/* binding */ minInt40),\n/* harmony export */   minInt48: () => (/* binding */ minInt48),\n/* harmony export */   minInt56: () => (/* binding */ minInt56),\n/* harmony export */   minInt64: () => (/* binding */ minInt64),\n/* harmony export */   minInt72: () => (/* binding */ minInt72),\n/* harmony export */   minInt8: () => (/* binding */ minInt8),\n/* harmony export */   minInt80: () => (/* binding */ minInt80),\n/* harmony export */   minInt88: () => (/* binding */ minInt88),\n/* harmony export */   minInt96: () => (/* binding */ minInt96)\n/* harmony export */ });\nconst arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nconst bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nconst integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nconst maxInt8 = 2n ** (8n - 1n) - 1n;\nconst maxInt16 = 2n ** (16n - 1n) - 1n;\nconst maxInt24 = 2n ** (24n - 1n) - 1n;\nconst maxInt32 = 2n ** (32n - 1n) - 1n;\nconst maxInt40 = 2n ** (40n - 1n) - 1n;\nconst maxInt48 = 2n ** (48n - 1n) - 1n;\nconst maxInt56 = 2n ** (56n - 1n) - 1n;\nconst maxInt64 = 2n ** (64n - 1n) - 1n;\nconst maxInt72 = 2n ** (72n - 1n) - 1n;\nconst maxInt80 = 2n ** (80n - 1n) - 1n;\nconst maxInt88 = 2n ** (88n - 1n) - 1n;\nconst maxInt96 = 2n ** (96n - 1n) - 1n;\nconst maxInt104 = 2n ** (104n - 1n) - 1n;\nconst maxInt112 = 2n ** (112n - 1n) - 1n;\nconst maxInt120 = 2n ** (120n - 1n) - 1n;\nconst maxInt128 = 2n ** (128n - 1n) - 1n;\nconst maxInt136 = 2n ** (136n - 1n) - 1n;\nconst maxInt144 = 2n ** (144n - 1n) - 1n;\nconst maxInt152 = 2n ** (152n - 1n) - 1n;\nconst maxInt160 = 2n ** (160n - 1n) - 1n;\nconst maxInt168 = 2n ** (168n - 1n) - 1n;\nconst maxInt176 = 2n ** (176n - 1n) - 1n;\nconst maxInt184 = 2n ** (184n - 1n) - 1n;\nconst maxInt192 = 2n ** (192n - 1n) - 1n;\nconst maxInt200 = 2n ** (200n - 1n) - 1n;\nconst maxInt208 = 2n ** (208n - 1n) - 1n;\nconst maxInt216 = 2n ** (216n - 1n) - 1n;\nconst maxInt224 = 2n ** (224n - 1n) - 1n;\nconst maxInt232 = 2n ** (232n - 1n) - 1n;\nconst maxInt240 = 2n ** (240n - 1n) - 1n;\nconst maxInt248 = 2n ** (248n - 1n) - 1n;\nconst maxInt256 = 2n ** (256n - 1n) - 1n;\nconst minInt8 = -(2n ** (8n - 1n));\nconst minInt16 = -(2n ** (16n - 1n));\nconst minInt24 = -(2n ** (24n - 1n));\nconst minInt32 = -(2n ** (32n - 1n));\nconst minInt40 = -(2n ** (40n - 1n));\nconst minInt48 = -(2n ** (48n - 1n));\nconst minInt56 = -(2n ** (56n - 1n));\nconst minInt64 = -(2n ** (64n - 1n));\nconst minInt72 = -(2n ** (72n - 1n));\nconst minInt80 = -(2n ** (80n - 1n));\nconst minInt88 = -(2n ** (88n - 1n));\nconst minInt96 = -(2n ** (96n - 1n));\nconst minInt104 = -(2n ** (104n - 1n));\nconst minInt112 = -(2n ** (112n - 1n));\nconst minInt120 = -(2n ** (120n - 1n));\nconst minInt128 = -(2n ** (128n - 1n));\nconst minInt136 = -(2n ** (136n - 1n));\nconst minInt144 = -(2n ** (144n - 1n));\nconst minInt152 = -(2n ** (152n - 1n));\nconst minInt160 = -(2n ** (160n - 1n));\nconst minInt168 = -(2n ** (168n - 1n));\nconst minInt176 = -(2n ** (176n - 1n));\nconst minInt184 = -(2n ** (184n - 1n));\nconst minInt192 = -(2n ** (192n - 1n));\nconst minInt200 = -(2n ** (200n - 1n));\nconst minInt208 = -(2n ** (208n - 1n));\nconst minInt216 = -(2n ** (216n - 1n));\nconst minInt224 = -(2n ** (224n - 1n));\nconst minInt232 = -(2n ** (232n - 1n));\nconst minInt240 = -(2n ** (240n - 1n));\nconst minInt248 = -(2n ** (248n - 1n));\nconst minInt256 = -(2n ** (256n - 1n));\nconst maxUint8 = 2n ** 8n - 1n;\nconst maxUint16 = 2n ** 16n - 1n;\nconst maxUint24 = 2n ** 24n - 1n;\nconst maxUint32 = 2n ** 32n - 1n;\nconst maxUint40 = 2n ** 40n - 1n;\nconst maxUint48 = 2n ** 48n - 1n;\nconst maxUint56 = 2n ** 56n - 1n;\nconst maxUint64 = 2n ** 64n - 1n;\nconst maxUint72 = 2n ** 72n - 1n;\nconst maxUint80 = 2n ** 80n - 1n;\nconst maxUint88 = 2n ** 88n - 1n;\nconst maxUint96 = 2n ** 96n - 1n;\nconst maxUint104 = 2n ** 104n - 1n;\nconst maxUint112 = 2n ** 112n - 1n;\nconst maxUint120 = 2n ** 120n - 1n;\nconst maxUint128 = 2n ** 128n - 1n;\nconst maxUint136 = 2n ** 136n - 1n;\nconst maxUint144 = 2n ** 144n - 1n;\nconst maxUint152 = 2n ** 152n - 1n;\nconst maxUint160 = 2n ** 160n - 1n;\nconst maxUint168 = 2n ** 168n - 1n;\nconst maxUint176 = 2n ** 176n - 1n;\nconst maxUint184 = 2n ** 184n - 1n;\nconst maxUint192 = 2n ** 192n - 1n;\nconst maxUint200 = 2n ** 200n - 1n;\nconst maxUint208 = 2n ** 208n - 1n;\nconst maxUint216 = 2n ** 216n - 1n;\nconst maxUint224 = 2n ** 224n - 1n;\nconst maxUint232 = 2n ** 232n - 1n;\nconst maxUint240 = 2n ** 240n - 1n;\nconst maxUint248 = 2n ** 248n - 1n;\nconst maxUint256 = 2n ** 256n - 1n; //# sourceMappingURL=Solidity.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NvbGlkaXR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPLE1BQU1BLGFBQWEscUJBQXFCO0FBQy9DLHNEQUFzRDtBQUN0RCwyQkFBMkI7QUFDcEIsTUFBTUMsYUFBYSx1Q0FBdUM7QUFDakUsaUZBQWlGO0FBQ2pGLDJCQUEyQjtBQUNwQixNQUFNQyxlQUFlLGlJQUFpSTtBQUN0SixNQUFNQyxVQUFVLEVBQUUsSUFBSyxHQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUNyQyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxVQUFVLENBQUUsR0FBRSxJQUFLLEdBQUUsR0FBRyxFQUFFLEdBQUc7QUFDbkMsTUFBTUMsV0FBVyxDQUFFLEdBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxHQUFHO0FBQ3JDLE1BQU1DLFdBQVcsQ0FBRSxHQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsR0FBRztBQUNyQyxNQUFNQyxXQUFXLENBQUUsR0FBRSxJQUFLLElBQUcsR0FBRyxFQUFFLEdBQUc7QUFDckMsTUFBTUMsV0FBVyxDQUFFLEdBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxHQUFHO0FBQ3JDLE1BQU1DLFdBQVcsQ0FBRSxHQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsR0FBRztBQUNyQyxNQUFNQyxXQUFXLENBQUUsR0FBRSxJQUFLLElBQUcsR0FBRyxFQUFFLEdBQUc7QUFDckMsTUFBTUMsV0FBVyxDQUFFLEdBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxHQUFHO0FBQ3JDLE1BQU1DLFdBQVcsQ0FBRSxHQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsR0FBRztBQUNyQyxNQUFNQyxXQUFXLENBQUUsR0FBRSxJQUFLLElBQUcsR0FBRyxFQUFFLEdBQUc7QUFDckMsTUFBTUMsV0FBVyxDQUFFLEdBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxHQUFHO0FBQ3JDLE1BQU1DLFdBQVcsQ0FBRSxHQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsR0FBRztBQUNyQyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFlBQVksQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsR0FBRztBQUN2QyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFlBQVksQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsR0FBRztBQUN2QyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFlBQVksQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsR0FBRztBQUN2QyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFlBQVksQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsR0FBRztBQUN2QyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFlBQVksQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsR0FBRztBQUN2QyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFlBQVksQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsR0FBRztBQUN2QyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFdBQVcsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDL0IsTUFBTUMsWUFBWSxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNqQyxNQUFNQyxZQUFZLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2pDLE1BQU1DLFlBQVksRUFBRSxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDakMsTUFBTUMsWUFBWSxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNqQyxNQUFNQyxZQUFZLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2pDLE1BQU1DLFlBQVksRUFBRSxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDakMsTUFBTUMsWUFBWSxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNqQyxNQUFNQyxZQUFZLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2pDLE1BQU1DLFlBQVksRUFBRSxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDakMsTUFBTUMsWUFBWSxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNqQyxNQUFNQyxZQUFZLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2pDLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxNQUFNQyxhQUFhLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25DLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxNQUFNQyxhQUFhLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25DLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxNQUFNQyxhQUFhLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25DLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxNQUFNQyxhQUFhLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25DLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxNQUFNQyxhQUFhLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25DLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxNQUFNQyxhQUFhLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25DLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUMxQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmM0MzM3LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Tb2xpZGl0eS5qcz80YzNkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBhcnJheVJlZ2V4ID0gL14oLiopXFxbKFswLTldKilcXF0kLztcbi8vIGBieXRlczxNPmA6IGJpbmFyeSB0eXBlIG9mIGBNYCBieXRlcywgYDAgPCBNIDw9IDMyYFxuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2YTU1XG5leHBvcnQgY29uc3QgYnl0ZXNSZWdleCA9IC9eYnl0ZXMoWzEtOV18MVswLTldfDJbMC05XXwzWzAtMl0pPyQvO1xuLy8gYCh1KWludDxNPmA6ICh1bilzaWduZWQgaW50ZWdlciB0eXBlIG9mIGBNYCBiaXRzLCBgMCA8IE0gPD0gMjU2YCwgYE0gJSA4ID09IDBgXG4vLyBodHRwczovL3JlZ2V4ci5jb20vNnY4aHBcbmV4cG9ydCBjb25zdCBpbnRlZ2VyUmVnZXggPSAvXih1P2ludCkoOHwxNnwyNHwzMnw0MHw0OHw1Nnw2NHw3Mnw4MHw4OHw5NnwxMDR8MTEyfDEyMHwxMjh8MTM2fDE0NHwxNTJ8MTYwfDE2OHwxNzZ8MTg0fDE5MnwyMDB8MjA4fDIxNnwyMjR8MjMyfDI0MHwyNDh8MjU2KT8kLztcbmV4cG9ydCBjb25zdCBtYXhJbnQ4ID0gMm4gKiogKDhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTYgPSAybiAqKiAoMTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjQgPSAybiAqKiAoMjRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MzIgPSAybiAqKiAoMzJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NDAgPSAybiAqKiAoNDBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NDggPSAybiAqKiAoNDhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NTYgPSAybiAqKiAoNTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NjQgPSAybiAqKiAoNjRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NzIgPSAybiAqKiAoNzJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50ODAgPSAybiAqKiAoODBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50ODggPSAybiAqKiAoODhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50OTYgPSAybiAqKiAoOTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTA0ID0gMm4gKiogKDEwNG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxMTIgPSAybiAqKiAoMTEybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDEyMCA9IDJuICoqICgxMjBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTI4ID0gMm4gKiogKDEyOG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxMzYgPSAybiAqKiAoMTM2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE0NCA9IDJuICoqICgxNDRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTUyID0gMm4gKiogKDE1Mm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxNjAgPSAybiAqKiAoMTYwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE2OCA9IDJuICoqICgxNjhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTc2ID0gMm4gKiogKDE3Nm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxODQgPSAybiAqKiAoMTg0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE5MiA9IDJuICoqICgxOTJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjAwID0gMm4gKiogKDIwMG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyMDggPSAybiAqKiAoMjA4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDIxNiA9IDJuICoqICgyMTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjI0ID0gMm4gKiogKDIyNG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyMzIgPSAybiAqKiAoMjMybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDI0MCA9IDJuICoqICgyNDBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjQ4ID0gMm4gKiogKDI0OG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyNTYgPSAybiAqKiAoMjU2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1pbkludDggPSAtKDJuICoqICg4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTYgPSAtKDJuICoqICgxNm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDI0ID0gLSgybiAqKiAoMjRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQzMiA9IC0oMm4gKiogKDMybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50NDAgPSAtKDJuICoqICg0MG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDQ4ID0gLSgybiAqKiAoNDhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ1NiA9IC0oMm4gKiogKDU2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50NjQgPSAtKDJuICoqICg2NG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDcyID0gLSgybiAqKiAoNzJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ4MCA9IC0oMm4gKiogKDgwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50ODggPSAtKDJuICoqICg4OG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDk2ID0gLSgybiAqKiAoOTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMDQgPSAtKDJuICoqICgxMDRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMTIgPSAtKDJuICoqICgxMTJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMjAgPSAtKDJuICoqICgxMjBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMjggPSAtKDJuICoqICgxMjhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMzYgPSAtKDJuICoqICgxMzZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNDQgPSAtKDJuICoqICgxNDRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNTIgPSAtKDJuICoqICgxNTJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNjAgPSAtKDJuICoqICgxNjBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNjggPSAtKDJuICoqICgxNjhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNzYgPSAtKDJuICoqICgxNzZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxODQgPSAtKDJuICoqICgxODRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxOTIgPSAtKDJuICoqICgxOTJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMDAgPSAtKDJuICoqICgyMDBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMDggPSAtKDJuICoqICgyMDhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMTYgPSAtKDJuICoqICgyMTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMjQgPSAtKDJuICoqICgyMjRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMzIgPSAtKDJuICoqICgyMzJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyNDAgPSAtKDJuICoqICgyNDBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyNDggPSAtKDJuICoqICgyNDhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyNTYgPSAtKDJuICoqICgyNTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtYXhVaW50OCA9IDJuICoqIDhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE2ID0gMm4gKiogMTZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDI0ID0gMm4gKiogMjRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDMyID0gMm4gKiogMzJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDQwID0gMm4gKiogNDBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDQ4ID0gMm4gKiogNDhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDU2ID0gMm4gKiogNTZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDY0ID0gMm4gKiogNjRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDcyID0gMm4gKiogNzJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDgwID0gMm4gKiogODBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDg4ID0gMm4gKiogODhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDk2ID0gMm4gKiogOTZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDEwNCA9IDJuICoqIDEwNG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTEyID0gMm4gKiogMTEybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxMjAgPSAybiAqKiAxMjBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDEyOCA9IDJuICoqIDEyOG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTM2ID0gMm4gKiogMTM2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNDQgPSAybiAqKiAxNDRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE1MiA9IDJuICoqIDE1Mm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTYwID0gMm4gKiogMTYwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNjggPSAybiAqKiAxNjhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE3NiA9IDJuICoqIDE3Nm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTg0ID0gMm4gKiogMTg0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxOTIgPSAybiAqKiAxOTJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIwMCA9IDJuICoqIDIwMG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjA4ID0gMm4gKiogMjA4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyMTYgPSAybiAqKiAyMTZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIyNCA9IDJuICoqIDIyNG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjMyID0gMm4gKiogMjMybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyNDAgPSAybiAqKiAyNDBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDI0OCA9IDJuICoqIDI0OG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjU2ID0gMm4gKiogMjU2biAtIDFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U29saWRpdHkuanMubWFwIl0sIm5hbWVzIjpbImFycmF5UmVnZXgiLCJieXRlc1JlZ2V4IiwiaW50ZWdlclJlZ2V4IiwibWF4SW50OCIsIm1heEludDE2IiwibWF4SW50MjQiLCJtYXhJbnQzMiIsIm1heEludDQwIiwibWF4SW50NDgiLCJtYXhJbnQ1NiIsIm1heEludDY0IiwibWF4SW50NzIiLCJtYXhJbnQ4MCIsIm1heEludDg4IiwibWF4SW50OTYiLCJtYXhJbnQxMDQiLCJtYXhJbnQxMTIiLCJtYXhJbnQxMjAiLCJtYXhJbnQxMjgiLCJtYXhJbnQxMzYiLCJtYXhJbnQxNDQiLCJtYXhJbnQxNTIiLCJtYXhJbnQxNjAiLCJtYXhJbnQxNjgiLCJtYXhJbnQxNzYiLCJtYXhJbnQxODQiLCJtYXhJbnQxOTIiLCJtYXhJbnQyMDAiLCJtYXhJbnQyMDgiLCJtYXhJbnQyMTYiLCJtYXhJbnQyMjQiLCJtYXhJbnQyMzIiLCJtYXhJbnQyNDAiLCJtYXhJbnQyNDgiLCJtYXhJbnQyNTYiLCJtaW5JbnQ4IiwibWluSW50MTYiLCJtaW5JbnQyNCIsIm1pbkludDMyIiwibWluSW50NDAiLCJtaW5JbnQ0OCIsIm1pbkludDU2IiwibWluSW50NjQiLCJtaW5JbnQ3MiIsIm1pbkludDgwIiwibWluSW50ODgiLCJtaW5JbnQ5NiIsIm1pbkludDEwNCIsIm1pbkludDExMiIsIm1pbkludDEyMCIsIm1pbkludDEyOCIsIm1pbkludDEzNiIsIm1pbkludDE0NCIsIm1pbkludDE1MiIsIm1pbkludDE2MCIsIm1pbkludDE2OCIsIm1pbkludDE3NiIsIm1pbkludDE4NCIsIm1pbkludDE5MiIsIm1pbkludDIwMCIsIm1pbkludDIwOCIsIm1pbkludDIxNiIsIm1pbkludDIyNCIsIm1pbkludDIzMiIsIm1pbkludDI0MCIsIm1pbkludDI0OCIsIm1pbkludDI1NiIsIm1heFVpbnQ4IiwibWF4VWludDE2IiwibWF4VWludDI0IiwibWF4VWludDMyIiwibWF4VWludDQwIiwibWF4VWludDQ4IiwibWF4VWludDU2IiwibWF4VWludDY0IiwibWF4VWludDcyIiwibWF4VWludDgwIiwibWF4VWludDg4IiwibWF4VWludDk2IiwibWF4VWludDEwNCIsIm1heFVpbnQxMTIiLCJtYXhVaW50MTIwIiwibWF4VWludDEyOCIsIm1heFVpbnQxMzYiLCJtYXhVaW50MTQ0IiwibWF4VWludDE1MiIsIm1heFVpbnQxNjAiLCJtYXhVaW50MTY4IiwibWF4VWludDE3NiIsIm1heFVpbnQxODQiLCJtYXhVaW50MTkyIiwibWF4VWludDIwMCIsIm1heFVpbnQyMDgiLCJtYXhVaW50MjE2IiwibWF4VWludDIyNCIsIm1heFVpbnQyMzIiLCJtYXhVaW50MjQwIiwibWF4VWludDI0OCIsIm1heFVpbnQyNTYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Solidity.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Withdrawal.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_esm/core/Withdrawal.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n/**\n * Converts a {@link ox#Withdrawal.Rpc} to an {@link ox#Withdrawal.Withdrawal}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.fromRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: '0x620323',\n *   index: '0x0',\n *   validatorIndex: '0x1',\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: 6423331n,\n * // @log:   index: 0,\n * // @log:   validatorIndex: 1\n * // @log: }\n * ```\n *\n * @param withdrawal - The RPC withdrawal to convert.\n * @returns An instantiated {@link ox#Withdrawal.Withdrawal}.\n */ function fromRpc(withdrawal) {\n    return {\n        ...withdrawal,\n        amount: BigInt(withdrawal.amount),\n        index: Number(withdrawal.index),\n        validatorIndex: Number(withdrawal.validatorIndex)\n    };\n}\n/**\n * Converts a {@link ox#Withdrawal.Withdrawal} to an {@link ox#Withdrawal.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.toRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: 6423331n,\n *   index: 0,\n *   validatorIndex: 1,\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: '0x620323',\n * // @log:   index: '0x0',\n * // @log:   validatorIndex: '0x1',\n * // @log: }\n * ```\n *\n * @param withdrawal - The Withdrawal to convert.\n * @returns An RPC Withdrawal.\n */ function toRpc(withdrawal) {\n    return {\n        address: withdrawal.address,\n        amount: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.amount),\n        index: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.index),\n        validatorIndex: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.validatorIndex)\n    };\n} //# sourceMappingURL=Withdrawal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1dpdGhkcmF3YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdDO0FBQ2hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVCQyxHQUNNLFNBQVNDLFFBQVFDLFVBQVU7SUFDOUIsT0FBTztRQUNILEdBQUdBLFVBQVU7UUFDYkMsUUFBUUMsT0FBT0YsV0FBV0MsTUFBTTtRQUNoQ0UsT0FBT0MsT0FBT0osV0FBV0csS0FBSztRQUM5QkUsZ0JBQWdCRCxPQUFPSixXQUFXSyxjQUFjO0lBQ3BEO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDTSxTQUFTQyxNQUFNTixVQUFVO0lBQzVCLE9BQU87UUFDSE8sU0FBU1AsV0FBV08sT0FBTztRQUMzQk4sUUFBUUgsK0NBQWMsQ0FBQ0UsV0FBV0MsTUFBTTtRQUN4Q0UsT0FBT0wsK0NBQWMsQ0FBQ0UsV0FBV0csS0FBSztRQUN0Q0UsZ0JBQWdCUCwrQ0FBYyxDQUFDRSxXQUFXSyxjQUFjO0lBQzVEO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmM0MzM3LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9XaXRoZHJhd2FsLmpzPzk4ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjV2l0aGRyYXdhbC5ScGN9IHRvIGFuIHtAbGluayBveCNXaXRoZHJhd2FsLldpdGhkcmF3YWx9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2l0aGRyYXdhbCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHdpdGhkcmF3YWwgPSBXaXRoZHJhd2FsLmZyb21ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhJyxcbiAqICAgYW1vdW50OiAnMHg2MjAzMjMnLFxuICogICBpbmRleDogJzB4MCcsXG4gKiAgIHZhbGlkYXRvckluZGV4OiAnMHgxJyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLFxuICogLy8gQGxvZzogICBhbW91bnQ6IDY0MjMzMzFuLFxuICogLy8gQGxvZzogICBpbmRleDogMCxcbiAqIC8vIEBsb2c6ICAgdmFsaWRhdG9ySW5kZXg6IDFcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3aXRoZHJhd2FsIC0gVGhlIFJQQyB3aXRoZHJhd2FsIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1dpdGhkcmF3YWwuV2l0aGRyYXdhbH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKHdpdGhkcmF3YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi53aXRoZHJhd2FsLFxuICAgICAgICBhbW91bnQ6IEJpZ0ludCh3aXRoZHJhd2FsLmFtb3VudCksXG4gICAgICAgIGluZGV4OiBOdW1iZXIod2l0aGRyYXdhbC5pbmRleCksXG4gICAgICAgIHZhbGlkYXRvckluZGV4OiBOdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjV2l0aGRyYXdhbC5XaXRoZHJhd2FsfSB0byBhbiB7QGxpbmsgb3gjV2l0aGRyYXdhbC5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2l0aGRyYXdhbCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHdpdGhkcmF3YWwgPSBXaXRoZHJhd2FsLnRvUnBjKHtcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYScsXG4gKiAgIGFtb3VudDogNjQyMzMzMW4sXG4gKiAgIGluZGV4OiAwLFxuICogICB2YWxpZGF0b3JJbmRleDogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLFxuICogLy8gQGxvZzogICBhbW91bnQ6ICcweDYyMDMyMycsXG4gKiAvLyBAbG9nOiAgIGluZGV4OiAnMHgwJyxcbiAqIC8vIEBsb2c6ICAgdmFsaWRhdG9ySW5kZXg6ICcweDEnLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHdpdGhkcmF3YWwgLSBUaGUgV2l0aGRyYXdhbCB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gUlBDIFdpdGhkcmF3YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyh3aXRoZHJhd2FsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogd2l0aGRyYXdhbC5hZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuYW1vdW50KSxcbiAgICAgICAgaW5kZXg6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuaW5kZXgpLFxuICAgICAgICB2YWxpZGF0b3JJbmRleDogSGV4LmZyb21OdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpdGhkcmF3YWwuanMubWFwIl0sIm5hbWVzIjpbIkhleCIsImZyb21ScGMiLCJ3aXRoZHJhd2FsIiwiYW1vdW50IiwiQmlnSW50IiwiaW5kZXgiLCJOdW1iZXIiLCJ2YWxpZGF0b3JJbmRleCIsInRvUnBjIiwiYWRkcmVzcyIsImZyb21OdW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Withdrawal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/abiItem.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/abiItem.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAmbiguousTypes: () => (/* binding */ getAmbiguousTypes),\n/* harmony export */   isArgOfType: () => (/* binding */ isArgOfType),\n/* harmony export */   normalizeSignature: () => (/* binding */ normalizeSignature)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n\n\n/** @internal */ function normalizeSignature(signature) {\n    let active = true;\n    let current = \"\";\n    let level = 0;\n    let result = \"\";\n    let valid = false;\n    for(let i = 0; i < signature.length; i++){\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if ([\n            \"(\",\n            \")\",\n            \",\"\n        ].includes(char)) active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === \"(\") level++;\n        if (char === \")\") level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active) continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === \" \" && [\n                \"event\",\n                \"function\",\n                \"error\",\n                \"\"\n            ].includes(result)) result = \"\";\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === \")\") {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === \" \") {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== \",\" && current !== \",\" && current !== \",(\") {\n                current = \"\";\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid) throw new _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError(\"Unable to normalize signature.\");\n    return result;\n}\n/** @internal */ function isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch(abiParameterType){\n        case \"address\":\n            return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(arg, {\n                strict: false\n            });\n        case \"bool\":\n            return argType === \"boolean\";\n        case \"function\":\n            return argType === \"string\";\n        case \"string\":\n            return argType === \"string\";\n        default:\n            {\n                if (abiParameterType === \"tuple\" && \"components\" in abiParameter) return Object.values(abiParameter.components).every((component, index)=>{\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n                // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n                // https://regexr.com/6v8hp\n                if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === \"number\" || argType === \"bigint\";\n                // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n                // https://regexr.com/6va55\n                if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === \"string\" || arg instanceof Uint8Array;\n                // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n                // https://regexr.com/6va6i\n                if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                    return Array.isArray(arg) && arg.every((x)=>isArgOfType(x, {\n                            ...abiParameter,\n                            // Pop off `[]` or `[M]` from end of type\n                            type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, \"\")\n                        }));\n                }\n                return false;\n            }\n    }\n}\n/** @internal */ function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for(const parameterIndex in sourceParameters){\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === \"tuple\" && targetParameter.type === \"tuple\" && \"components\" in sourceParameter && \"components\" in targetParameter) return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [\n            sourceParameter.type,\n            targetParameter.type\n        ];\n        const ambiguous = (()=>{\n            if (types.includes(\"address\") && types.includes(\"bytes20\")) return true;\n            if (types.includes(\"address\") && types.includes(\"string\")) return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                strict: false\n            });\n            if (types.includes(\"address\") && types.includes(\"bytes\")) return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                strict: false\n            });\n            return false;\n        })();\n        if (ambiguous) return types;\n    }\n    return;\n} //# sourceMappingURL=abiItem.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2FiaUl0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUM7QUFDRjtBQUN2QyxjQUFjLEdBQ1AsU0FBU0UsbUJBQW1CQyxTQUFTO0lBQ3hDLElBQUlDLFNBQVM7SUFDYixJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsUUFBUTtJQUNaLElBQUlDLFNBQVM7SUFDYixJQUFJQyxRQUFRO0lBQ1osSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLFVBQVVPLE1BQU0sRUFBRUQsSUFBSztRQUN2QyxNQUFNRSxPQUFPUixTQUFTLENBQUNNLEVBQUU7UUFDekIsMERBQTBEO1FBQzFELElBQUk7WUFBQztZQUFLO1lBQUs7U0FBSSxDQUFDRyxRQUFRLENBQUNELE9BQ3pCUCxTQUFTO1FBQ2IsdUVBQXVFO1FBQ3ZFLElBQUlPLFNBQVMsS0FDVEw7UUFDSixJQUFJSyxTQUFTLEtBQ1RMO1FBQ0osMkRBQTJEO1FBQzNELElBQUksQ0FBQ0YsUUFDRDtRQUNKLGtEQUFrRDtRQUNsRCxJQUFJRSxVQUFVLEdBQUc7WUFDYixJQUFJSyxTQUFTLE9BQU87Z0JBQUM7Z0JBQVM7Z0JBQVk7Z0JBQVM7YUFBRyxDQUFDQyxRQUFRLENBQUNMLFNBQzVEQSxTQUFTO2lCQUNSO2dCQUNEQSxVQUFVSTtnQkFDViwrREFBK0Q7Z0JBQy9ELElBQUlBLFNBQVMsS0FBSztvQkFDZEgsUUFBUTtvQkFDUjtnQkFDSjtZQUNKO1lBQ0E7UUFDSjtRQUNBLGdCQUFnQjtRQUNoQixJQUFJRyxTQUFTLEtBQUs7WUFDZCx3R0FBd0c7WUFDeEcsSUFBSVIsU0FBUyxDQUFDTSxJQUFJLEVBQUUsS0FBSyxPQUFPSixZQUFZLE9BQU9BLFlBQVksTUFBTTtnQkFDakVBLFVBQVU7Z0JBQ1ZELFNBQVM7WUFDYjtZQUNBO1FBQ0o7UUFDQUcsVUFBVUk7UUFDVk4sV0FBV007SUFDZjtJQUNBLElBQUksQ0FBQ0gsT0FDRCxNQUFNLElBQUlQLGlEQUFnQixDQUFDO0lBQy9CLE9BQU9NO0FBQ1g7QUFDQSxjQUFjLEdBQ1AsU0FBU08sWUFBWUMsR0FBRyxFQUFFQyxZQUFZO0lBQ3pDLE1BQU1DLFVBQVUsT0FBT0Y7SUFDdkIsTUFBTUcsbUJBQW1CRixhQUFhRyxJQUFJO0lBQzFDLE9BQVFEO1FBQ0osS0FBSztZQUNELE9BQU9sQixpREFBZ0IsQ0FBQ2UsS0FBSztnQkFBRU0sUUFBUTtZQUFNO1FBQ2pELEtBQUs7WUFDRCxPQUFPSixZQUFZO1FBQ3ZCLEtBQUs7WUFDRCxPQUFPQSxZQUFZO1FBQ3ZCLEtBQUs7WUFDRCxPQUFPQSxZQUFZO1FBQ3ZCO1lBQVM7Z0JBQ0wsSUFBSUMscUJBQXFCLFdBQVcsZ0JBQWdCRixjQUNoRCxPQUFPTSxPQUFPQyxNQUFNLENBQUNQLGFBQWFRLFVBQVUsRUFBRUMsS0FBSyxDQUFDLENBQUNDLFdBQVdDO29CQUM1RCxPQUFPYixZQUFZUSxPQUFPQyxNQUFNLENBQUNSLElBQUksQ0FBQ1ksTUFBTSxFQUFFRDtnQkFDbEQ7Z0JBQ0osaUZBQWlGO2dCQUNqRiwyQkFBMkI7Z0JBQzNCLElBQUksK0hBQStIRSxJQUFJLENBQUNWLG1CQUNwSSxPQUFPRCxZQUFZLFlBQVlBLFlBQVk7Z0JBQy9DLHNEQUFzRDtnQkFDdEQsMkJBQTJCO2dCQUMzQixJQUFJLHVDQUF1Q1csSUFBSSxDQUFDVixtQkFDNUMsT0FBT0QsWUFBWSxZQUFZRixlQUFlYztnQkFDbEQsNkRBQTZEO2dCQUM3RCwyQkFBMkI7Z0JBQzNCLElBQUksb0NBQW9DRCxJQUFJLENBQUNWLG1CQUFtQjtvQkFDNUQsT0FBUVksTUFBTUMsT0FBTyxDQUFDaEIsUUFDbEJBLElBQUlVLEtBQUssQ0FBQyxDQUFDTyxJQUFNbEIsWUFBWWtCLEdBQUc7NEJBQzVCLEdBQUdoQixZQUFZOzRCQUNmLHlDQUF5Qzs0QkFDekNHLE1BQU1ELGlCQUFpQmUsT0FBTyxDQUFDLG9CQUFvQjt3QkFDdkQ7Z0JBQ1I7Z0JBQ0EsT0FBTztZQUNYO0lBQ0o7QUFDSjtBQUNBLGNBQWMsR0FDUCxTQUFTQyxrQkFBa0JDLGdCQUFnQixFQUFFQyxnQkFBZ0IsRUFBRUMsSUFBSTtJQUN0RSxJQUFLLE1BQU1DLGtCQUFrQkgsaUJBQWtCO1FBQzNDLE1BQU1JLGtCQUFrQkosZ0JBQWdCLENBQUNHLGVBQWU7UUFDeEQsTUFBTUUsa0JBQWtCSixnQkFBZ0IsQ0FBQ0UsZUFBZTtRQUN4RCxJQUFJQyxnQkFBZ0JwQixJQUFJLEtBQUssV0FDekJxQixnQkFBZ0JyQixJQUFJLEtBQUssV0FDekIsZ0JBQWdCb0IsbUJBQ2hCLGdCQUFnQkMsaUJBQ2hCLE9BQU9OLGtCQUFrQkssZ0JBQWdCZixVQUFVLEVBQUVnQixnQkFBZ0JoQixVQUFVLEVBQUVhLElBQUksQ0FBQ0MsZUFBZTtRQUN6RyxNQUFNRyxRQUFRO1lBQUNGLGdCQUFnQnBCLElBQUk7WUFBRXFCLGdCQUFnQnJCLElBQUk7U0FBQztRQUMxRCxNQUFNdUIsWUFBWSxDQUFDO1lBQ2YsSUFBSUQsTUFBTTdCLFFBQVEsQ0FBQyxjQUFjNkIsTUFBTTdCLFFBQVEsQ0FBQyxZQUM1QyxPQUFPO1lBQ1gsSUFBSTZCLE1BQU03QixRQUFRLENBQUMsY0FBYzZCLE1BQU03QixRQUFRLENBQUMsV0FDNUMsT0FBT1osaURBQWdCLENBQUNxQyxJQUFJLENBQUNDLGVBQWUsRUFBRTtnQkFDMUNqQixRQUFRO1lBQ1o7WUFDSixJQUFJb0IsTUFBTTdCLFFBQVEsQ0FBQyxjQUFjNkIsTUFBTTdCLFFBQVEsQ0FBQyxVQUM1QyxPQUFPWixpREFBZ0IsQ0FBQ3FDLElBQUksQ0FBQ0MsZUFBZSxFQUFFO2dCQUMxQ2pCLFFBQVE7WUFDWjtZQUNKLE9BQU87UUFDWDtRQUNBLElBQUlxQixXQUNBLE9BQU9EO0lBQ2Y7SUFDQTtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjNDMzNy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvYWJpSXRlbS5qcz81NGUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vRXJyb3JzLmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgbGV0IGFjdGl2ZSA9IHRydWU7XG4gICAgbGV0IGN1cnJlbnQgPSAnJztcbiAgICBsZXQgbGV2ZWwgPSAwO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBsZXQgdmFsaWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gc2lnbmF0dXJlW2ldO1xuICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yLCB3ZSB3YW50IHRvIHJlYWN0aXZhdGUuXG4gICAgICAgIGlmIChbJygnLCAnKScsICcsJ10uaW5jbHVkZXMoY2hhcikpXG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgXCJsZXZlbFwiIHRva2VuLCB3ZSB3YW50IHRvIGluY3JlbWVudC9kZWNyZW1lbnQuXG4gICAgICAgIGlmIChjaGFyID09PSAnKCcpXG4gICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICBpZiAoY2hhciA9PT0gJyknKVxuICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IGFjdGl2ZSwgd2UgZG9uJ3Qgd2FudCB0byBtdXRhdGUgdGhlIHJlc3VsdC5cbiAgICAgICAgaWYgKCFhY3RpdmUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gSWYgbGV2ZWwgPT09IDAsIHdlIGFyZSBhdCB0aGUgZGVmaW5pdGlvbiBsZXZlbC5cbiAgICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJyAnICYmIFsnZXZlbnQnLCAnZnVuY3Rpb24nLCAnZXJyb3InLCAnJ10uaW5jbHVkZXMocmVzdWx0KSlcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaGFyO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBkZWZpbml0aW9uLCB3ZSBtdXN0IGJlIGZpbmlzaGVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgc3BhY2VzXG4gICAgICAgIGlmIChjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXMgYSBzZXBhcmF0b3IsIGFuZCB0aGUgY3VycmVudCBzZWN0aW9uIGlzbid0IGVtcHR5LCB3ZSB3YW50IHRvIGRlYWN0aXZhdGUuXG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlW2kgLSAxXSAhPT0gJywnICYmIGN1cnJlbnQgIT09ICcsJyAmJiBjdXJyZW50ICE9PSAnLCgnKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGNoYXI7XG4gICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICB9XG4gICAgaWYgKCF2YWxpZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoJ1VuYWJsZSB0byBub3JtYWxpemUgc2lnbmF0dXJlLicpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcmdPZlR5cGUoYXJnLCBhYmlQYXJhbWV0ZXIpIHtcbiAgICBjb25zdCBhcmdUeXBlID0gdHlwZW9mIGFyZztcbiAgICBjb25zdCBhYmlQYXJhbWV0ZXJUeXBlID0gYWJpUGFyYW1ldGVyLnR5cGU7XG4gICAgc3dpdGNoIChhYmlQYXJhbWV0ZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MudmFsaWRhdGUoYXJnLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdib29sZWFuJztcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBpZiAoYWJpUGFyYW1ldGVyVHlwZSA9PT0gJ3R1cGxlJyAmJiAnY29tcG9uZW50cycgaW4gYWJpUGFyYW1ldGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGFiaVBhcmFtZXRlci5jb21wb25lbnRzKS5ldmVyeSgoY29tcG9uZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcmdPZlR5cGUoT2JqZWN0LnZhbHVlcyhhcmcpW2luZGV4XSwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGAodSlpbnQ8TT5gOiAodW4pc2lnbmVkIGludGVnZXIgdHlwZSBvZiBgTWAgYml0cywgYDAgPCBNIDw9IDI1NmAsIGBNICUgOCA9PSAwYFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2OGhwXG4gICAgICAgICAgICBpZiAoL151P2ludCg4fDE2fDI0fDMyfDQwfDQ4fDU2fDY0fDcyfDgwfDg4fDk2fDEwNHwxMTJ8MTIwfDEyOHwxMzZ8MTQ0fDE1MnwxNjB8MTY4fDE3NnwxODR8MTkyfDIwMHwyMDh8MjE2fDIyNHwyMzJ8MjQwfDI0OHwyNTYpPyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdudW1iZXInIHx8IGFyZ1R5cGUgPT09ICdiaWdpbnQnO1xuICAgICAgICAgICAgLy8gYGJ5dGVzPE0+YDogYmluYXJ5IHR5cGUgb2YgYE1gIGJ5dGVzLCBgMCA8IE0gPD0gMzJgXG4gICAgICAgICAgICAvLyBodHRwczovL3JlZ2V4ci5jb20vNnZhNTVcbiAgICAgICAgICAgIGlmICgvXmJ5dGVzKFsxLTldfDFbMC05XXwyWzAtOV18M1swLTJdKT8kLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmcgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICAgICAgLy8gZml4ZWQtbGVuZ3RoIChgPHR5cGU+W01dYCkgYW5kIGR5bmFtaWMgKGA8dHlwZT5bXWApIGFycmF5c1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2YTZpXG4gICAgICAgICAgICBpZiAoL1thLXpdK1sxLTldezAsM30oXFxbWzAtOV17MCx9XFxdKSskLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KGFyZykgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJnLmV2ZXJ5KCh4KSA9PiBpc0FyZ09mVHlwZSh4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hYmlQYXJhbWV0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3Agb2ZmIGBbXWAgb3IgYFtNXWAgZnJvbSBlbmQgb2YgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYWJpUGFyYW1ldGVyVHlwZS5yZXBsYWNlKC8oXFxbWzAtOV17MCx9XFxdKSQvLCAnJyksXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QW1iaWd1b3VzVHlwZXMoc291cmNlUGFyYW1ldGVycywgdGFyZ2V0UGFyYW1ldGVycywgYXJncykge1xuICAgIGZvciAoY29uc3QgcGFyYW1ldGVySW5kZXggaW4gc291cmNlUGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBzb3VyY2VQYXJhbWV0ZXIgPSBzb3VyY2VQYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UGFyYW1ldGVyID0gdGFyZ2V0UGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF07XG4gICAgICAgIGlmIChzb3VyY2VQYXJhbWV0ZXIudHlwZSA9PT0gJ3R1cGxlJyAmJlxuICAgICAgICAgICAgdGFyZ2V0UGFyYW1ldGVyLnR5cGUgPT09ICd0dXBsZScgJiZcbiAgICAgICAgICAgICdjb21wb25lbnRzJyBpbiBzb3VyY2VQYXJhbWV0ZXIgJiZcbiAgICAgICAgICAgICdjb21wb25lbnRzJyBpbiB0YXJnZXRQYXJhbWV0ZXIpXG4gICAgICAgICAgICByZXR1cm4gZ2V0QW1iaWd1b3VzVHlwZXMoc291cmNlUGFyYW1ldGVyLmNvbXBvbmVudHMsIHRhcmdldFBhcmFtZXRlci5jb21wb25lbnRzLCBhcmdzW3BhcmFtZXRlckluZGV4XSk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW3NvdXJjZVBhcmFtZXRlci50eXBlLCB0YXJnZXRQYXJhbWV0ZXIudHlwZV07XG4gICAgICAgIGNvbnN0IGFtYmlndW91cyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJ2FkZHJlc3MnKSAmJiB0eXBlcy5pbmNsdWRlcygnYnl0ZXMyMCcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCdhZGRyZXNzJykgJiYgdHlwZXMuaW5jbHVkZXMoJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLnZhbGlkYXRlKGFyZ3NbcGFyYW1ldGVySW5kZXhdLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmljdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJ2FkZHJlc3MnKSAmJiB0eXBlcy5pbmNsdWRlcygnYnl0ZXMnKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQWRkcmVzcy52YWxpZGF0ZShhcmdzW3BhcmFtZXRlckluZGV4XSwge1xuICAgICAgICAgICAgICAgICAgICBzdHJpY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSgpO1xuICAgICAgICBpZiAoYW1iaWd1b3VzKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbiAgICByZXR1cm47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmlJdGVtLmpzLm1hcCJdLCJuYW1lcyI6WyJBZGRyZXNzIiwiRXJyb3JzIiwibm9ybWFsaXplU2lnbmF0dXJlIiwic2lnbmF0dXJlIiwiYWN0aXZlIiwiY3VycmVudCIsImxldmVsIiwicmVzdWx0IiwidmFsaWQiLCJpIiwibGVuZ3RoIiwiY2hhciIsImluY2x1ZGVzIiwiQmFzZUVycm9yIiwiaXNBcmdPZlR5cGUiLCJhcmciLCJhYmlQYXJhbWV0ZXIiLCJhcmdUeXBlIiwiYWJpUGFyYW1ldGVyVHlwZSIsInR5cGUiLCJ2YWxpZGF0ZSIsInN0cmljdCIsIk9iamVjdCIsInZhbHVlcyIsImNvbXBvbmVudHMiLCJldmVyeSIsImNvbXBvbmVudCIsImluZGV4IiwidGVzdCIsIlVpbnQ4QXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJ4IiwicmVwbGFjZSIsImdldEFtYmlndW91c1R5cGVzIiwic291cmNlUGFyYW1ldGVycyIsInRhcmdldFBhcmFtZXRlcnMiLCJhcmdzIiwicGFyYW1ldGVySW5kZXgiLCJzb3VyY2VQYXJhbWV0ZXIiLCJ0YXJnZXRQYXJhbWV0ZXIiLCJ0eXBlcyIsImFtYmlndW91cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/abiItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/abiParameters.js":
/*!*************************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/abiParameters.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeAddress: () => (/* binding */ decodeAddress),\n/* harmony export */   decodeArray: () => (/* binding */ decodeArray),\n/* harmony export */   decodeBool: () => (/* binding */ decodeBool),\n/* harmony export */   decodeBytes: () => (/* binding */ decodeBytes),\n/* harmony export */   decodeNumber: () => (/* binding */ decodeNumber),\n/* harmony export */   decodeParameter: () => (/* binding */ decodeParameter),\n/* harmony export */   decodeString: () => (/* binding */ decodeString),\n/* harmony export */   decodeTuple: () => (/* binding */ decodeTuple),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeAddress: () => (/* binding */ encodeAddress),\n/* harmony export */   encodeArray: () => (/* binding */ encodeArray),\n/* harmony export */   encodeBoolean: () => (/* binding */ encodeBoolean),\n/* harmony export */   encodeBytes: () => (/* binding */ encodeBytes),\n/* harmony export */   encodeNumber: () => (/* binding */ encodeNumber),\n/* harmony export */   encodeString: () => (/* binding */ encodeString),\n/* harmony export */   encodeTuple: () => (/* binding */ encodeTuple),\n/* harmony export */   getArrayComponents: () => (/* binding */ getArrayComponents),\n/* harmony export */   hasDynamicChild: () => (/* binding */ hasDynamicChild),\n/* harmony export */   prepareParameter: () => (/* binding */ prepareParameter),\n/* harmony export */   prepareParameters: () => (/* binding */ prepareParameters)\n/* harmony export */ });\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Solidity.js */ \"(ssr)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/** @internal */ function decodeParameter(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, {\n            ...param,\n            type\n        }, {\n            checksumAddress,\n            length,\n            staticPosition\n        });\n    }\n    if (param.type === \"tuple\") return decodeTuple(cursor, param, {\n        checksumAddress,\n        staticPosition\n    });\n    if (param.type === \"address\") return decodeAddress(cursor, {\n        checksum: checksumAddress\n    });\n    if (param.type === \"bool\") return decodeBool(cursor);\n    if (param.type.startsWith(\"bytes\")) return decodeBytes(cursor, param, {\n        staticPosition\n    });\n    if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) return decodeNumber(cursor, param);\n    if (param.type === \"string\") return decodeString(cursor, {\n        staticPosition\n    });\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */ function decodeAddress(cursor, options = {}) {\n    const { checksum = false } = options;\n    const value = cursor.readBytes(32);\n    const wrap = (address)=>checksum ? _Address_js__WEBPACK_IMPORTED_MODULE_1__.checksum(address) : address;\n    return [\n        wrap(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.slice(value, -20))),\n        32\n    ];\n}\n/** @internal */ function decodeArray(cursor, param, options) {\n    const { checksumAddress, length, staticPosition } = options;\n    // If the length of the array is not known in advance (dynamic array),\n    // this means we will need to wonder off to the pointer and decode.\n    if (!length) {\n        // Dealing with a dynamic type, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        // Get the length of the array from the offset.\n        cursor.setPosition(start);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfLength));\n        // Check if the array has any dynamic children.\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for(let i = 0; i < length; ++i){\n            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n            // Otherwise, elements will be the size of their encoding (consumed bytes).\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: startOfData\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [\n            value,\n            32\n        ];\n    }\n    // If the length of the array is known in advance,\n    // and the length of an element deeply nested in the array is not known,\n    // we need to decode the offset of the array data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const value = [];\n        for(let i = 0; i < length; ++i){\n            // Move cursor along to the next slot (next offset pointer).\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: start\n            });\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [\n            value,\n            32\n        ];\n    }\n    // If the length of the array is known in advance and the array is deeply static,\n    // then we can just decode each element in sequence.\n    let consumed = 0;\n    const value = [];\n    for(let i = 0; i < length; ++i){\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: staticPosition + consumed\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [\n        value,\n        consumed\n    ];\n}\n/** @internal */ function decodeBool(cursor) {\n    return [\n        _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBoolean(cursor.readBytes(32), {\n            size: 32\n        }),\n        32\n    ];\n}\n/** @internal */ function decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split(\"bytes\");\n    if (!size) {\n        // Dealing with dynamic types, so get the offset of the bytes data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // Set position of the cursor to start of bytes data.\n        cursor.setPosition(staticPosition + offset);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // If there is no length, we have zero data.\n        if (length === 0) {\n            // As we have gone wondering, restore to the original position + next slot.\n            cursor.setPosition(staticPosition + 32);\n            return [\n                \"0x\",\n                32\n            ];\n        }\n        const data = cursor.readBytes(length);\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [\n            _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data),\n            32\n        ];\n    }\n    const value = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(cursor.readBytes(Number.parseInt(size, 10), 32));\n    return [\n        value,\n        32\n    ];\n}\n/** @internal */ function decodeNumber(cursor, param) {\n    const signed = param.type.startsWith(\"int\");\n    const size = Number.parseInt(param.type.split(\"int\")[1] || \"256\", 10);\n    const value = cursor.readBytes(32);\n    return [\n        size > 48 ? _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBigInt(value, {\n            signed\n        }) : _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(value, {\n            signed\n        }),\n        32\n    ];\n}\n/** @internal */ function decodeTuple(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    // Tuples can have unnamed components (i.e. they are arrays), so we must\n    // determine whether the tuple is named or unnamed. In the case of a named\n    // tuple, the value will be an object where each property is the name of the\n    // component. In the case of an unnamed tuple, the value will be an array.\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name })=>!name);\n    // Initialize the value to an object or an array, depending on whether the\n    // tuple is named or unnamed.\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    // If the tuple has a dynamic child, we must first decode the offset to the\n    // tuple data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the tuple data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of referencing slot + offset.\n        const start = staticPosition + offset;\n        for(let i = 0; i < param.components.length; ++i){\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                checksumAddress,\n                staticPosition: start\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [\n            value,\n            32\n        ];\n    }\n    // If the tuple has static children, we can just decode each component\n    // in sequence.\n    for(let i = 0; i < param.components.length; ++i){\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            checksumAddress,\n            staticPosition\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [\n        value,\n        consumed\n    ];\n}\n/** @internal */ function decodeString(cursor, { staticPosition }) {\n    // Get offset to start of string data.\n    const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data (empty string).\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return [\n            \"\",\n            32\n        ];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toString(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(data));\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [\n        value,\n        32\n    ];\n}\n/** @internal */ function prepareParameters({ checksumAddress, parameters, values }) {\n    const preparedParameters = [];\n    for(let i = 0; i < parameters.length; i++){\n        preparedParameters.push(prepareParameter({\n            checksumAddress,\n            parameter: parameters[i],\n            value: values[i]\n        }));\n    }\n    return preparedParameters;\n}\n/** @internal */ function prepareParameter({ checksumAddress = false, parameter: parameter_, value }) {\n    const parameter = parameter_;\n    const arrayComponents = getArrayComponents(parameter.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, {\n            checksumAddress,\n            length,\n            parameter: {\n                ...parameter,\n                type\n            }\n        });\n    }\n    if (parameter.type === \"tuple\") {\n        return encodeTuple(value, {\n            checksumAddress,\n            parameter: parameter\n        });\n    }\n    if (parameter.type === \"address\") {\n        return encodeAddress(value, {\n            checksum: checksumAddress\n        });\n    }\n    if (parameter.type === \"bool\") {\n        return encodeBoolean(value);\n    }\n    if (parameter.type.startsWith(\"uint\") || parameter.type.startsWith(\"int\")) {\n        const signed = parameter.type.startsWith(\"int\");\n        const [, , size = \"256\"] = _Solidity_js__WEBPACK_IMPORTED_MODULE_4__.integerRegex.exec(parameter.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size)\n        });\n    }\n    if (parameter.type.startsWith(\"bytes\")) {\n        return encodeBytes(value, {\n            type: parameter.type\n        });\n    }\n    if (parameter.type === \"string\") {\n        return encodeString(value);\n    }\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(parameter.type);\n}\n/** @internal */ function encode(preparedParameters) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for(let i = 0; i < preparedParameters.length; i++){\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) staticSize += 32;\n        else staticSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParameters = [];\n    const dynamicParameters = [];\n    let dynamicSize = 0;\n    for(let i = 0; i < preparedParameters.length; i++){\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) {\n            staticParameters.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(staticSize + dynamicSize, {\n                size: 32\n            }));\n            dynamicParameters.push(encoded);\n            dynamicSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n        } else {\n            staticParameters.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */ function encodeAddress(value, options) {\n    const { checksum = false } = options;\n    _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(value, {\n        strict: checksum\n    });\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(value.toLowerCase())\n    };\n}\n/** @internal */ function encodeArray(value, options) {\n    const { checksumAddress, length, parameter } = options;\n    const dynamic = length === null;\n    if (!Array.isArray(value)) throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArrayError(value);\n    if (!dynamic && value.length !== length) throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.ArrayLengthMismatchError({\n        expectedLength: length,\n        givenLength: value.length,\n        type: `${parameter.type}[${length}]`\n    });\n    let dynamicChild = false;\n    const preparedParameters = [];\n    for(let i = 0; i < value.length; i++){\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter,\n            value: value[i]\n        });\n        if (preparedParam.dynamic) dynamicChild = true;\n        preparedParameters.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encode(preparedParameters);\n        if (dynamic) {\n            const length = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(preparedParameters.length, {\n                size: 32\n            });\n            return {\n                dynamic: true,\n                encoded: preparedParameters.length > 0 ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(length, data) : length\n            };\n        }\n        if (dynamicChild) return {\n            dynamic: true,\n            encoded: data\n        };\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded })=>encoded))\n    };\n}\n/** @internal */ function encodeBytes(value, { type }) {\n    const [, parametersize] = type.split(\"bytes\");\n    const bytesSize = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value);\n    if (!parametersize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0) value_ = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n        return {\n            dynamic: true,\n            encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(bytesSize, {\n                size: 32\n            })), value_)\n        };\n    }\n    if (bytesSize !== Number.parseInt(parametersize, 10)) throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.BytesSizeMismatchError({\n        expectedSize: Number.parseInt(parametersize, 10),\n        value\n    });\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value)\n    };\n}\n/** @internal */ function encodeBoolean(value) {\n    if (typeof value !== \"boolean\") throw new _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value))\n    };\n}\n/** @internal */ function encodeNumber(value, { signed, size }) {\n    if (typeof size === \"number\") {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min) throw new _Hex_js__WEBPACK_IMPORTED_MODULE_2__.IntegerOutOfRangeError({\n            max: max.toString(),\n            min: min.toString(),\n            signed,\n            size: size / 8,\n            value: value.toString()\n        });\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n            size: 32,\n            signed\n        })\n    };\n}\n/** @internal */ function encodeString(value) {\n    const hexValue = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n    const partsLength = Math.ceil(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue) / 32);\n    const parts = [];\n    for(let i = 0; i < partsLength; i++){\n        parts.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(hexValue, i * 32, (i + 1) * 32)));\n    }\n    return {\n        dynamic: true,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue), {\n            size: 32\n        })), ...parts)\n    };\n}\n/** @internal */ function encodeTuple(value, options) {\n    const { checksumAddress, parameter } = options;\n    let dynamic = false;\n    const preparedParameters = [];\n    for(let i = 0; i < parameter.components.length; i++){\n        const param_ = parameter.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter: param_,\n            value: value[index]\n        });\n        preparedParameters.push(preparedParam);\n        if (preparedParam.dynamic) dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic ? encode(preparedParameters) : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded })=>encoded))\n    };\n}\n/** @internal */ function getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches ? [\n        matches[2] ? Number(matches[2]) : null,\n        matches[1]\n    ] : undefined;\n}\n/** @internal */ function hasDynamicChild(param) {\n    const { type } = param;\n    if (type === \"string\") return true;\n    if (type === \"bytes\") return true;\n    if (type.endsWith(\"[]\")) return true;\n    if (type === \"tuple\") return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents && hasDynamicChild({\n        ...param,\n        type: arrayComponents[1]\n    })) return true;\n    return false;\n} //# sourceMappingURL=abiParameters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2FiaVBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDWjtBQUNKO0FBQ0U7QUFDTjtBQUNhO0FBQzlDLGNBQWMsR0FDUCxTQUFTTSxnQkFBZ0JDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxPQUFPO0lBQ2xELE1BQU0sRUFBRUMsZUFBZSxFQUFFQyxjQUFjLEVBQUUsR0FBR0Y7SUFDNUMsTUFBTUcsa0JBQWtCQyxtQkFBbUJMLE1BQU1NLElBQUk7SUFDckQsSUFBSUYsaUJBQWlCO1FBQ2pCLE1BQU0sQ0FBQ0csUUFBUUQsS0FBSyxHQUFHRjtRQUN2QixPQUFPSSxZQUFZVCxRQUFRO1lBQUUsR0FBR0MsS0FBSztZQUFFTTtRQUFLLEdBQUc7WUFBRUo7WUFBaUJLO1lBQVFKO1FBQWU7SUFDN0Y7SUFDQSxJQUFJSCxNQUFNTSxJQUFJLEtBQUssU0FDZixPQUFPRyxZQUFZVixRQUFRQyxPQUFPO1FBQzlCRTtRQUNBQztJQUNKO0lBQ0osSUFBSUgsTUFBTU0sSUFBSSxLQUFLLFdBQ2YsT0FBT0ksY0FBY1gsUUFBUTtRQUFFWSxVQUFVVDtJQUFnQjtJQUM3RCxJQUFJRixNQUFNTSxJQUFJLEtBQUssUUFDZixPQUFPTSxXQUFXYjtJQUN0QixJQUFJQyxNQUFNTSxJQUFJLENBQUNPLFVBQVUsQ0FBQyxVQUN0QixPQUFPQyxZQUFZZixRQUFRQyxPQUFPO1FBQUVHO0lBQWU7SUFDdkQsSUFBSUgsTUFBTU0sSUFBSSxDQUFDTyxVQUFVLENBQUMsV0FBV2IsTUFBTU0sSUFBSSxDQUFDTyxVQUFVLENBQUMsUUFDdkQsT0FBT0UsYUFBYWhCLFFBQVFDO0lBQ2hDLElBQUlBLE1BQU1NLElBQUksS0FBSyxVQUNmLE9BQU9VLGFBQWFqQixRQUFRO1FBQUVJO0lBQWU7SUFDakQsTUFBTSxJQUFJWCwrREFBOEIsQ0FBQ1EsTUFBTU0sSUFBSTtBQUN2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c20vY29yZS9pbnRlcm5hbC9hYmlQYXJhbWV0ZXJzLmpzP2VhOTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWJpUGFyYW1ldGVycyBmcm9tICcuLi9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuLi9IZXguanMnO1xuaW1wb3J0IHsgaW50ZWdlclJlZ2V4IH0gZnJvbSAnLi4vU29saWRpdHkuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIHN0YXRpY1Bvc2l0aW9uIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGFycmF5Q29tcG9uZW50cyA9IGdldEFycmF5Q29tcG9uZW50cyhwYXJhbS50eXBlKTtcbiAgICBpZiAoYXJyYXlDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnN0IFtsZW5ndGgsIHR5cGVdID0gYXJyYXlDb21wb25lbnRzO1xuICAgICAgICByZXR1cm4gZGVjb2RlQXJyYXkoY3Vyc29yLCB7IC4uLnBhcmFtLCB0eXBlIH0sIHsgY2hlY2tzdW1BZGRyZXNzLCBsZW5ndGgsIHN0YXRpY1Bvc2l0aW9uIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ3R1cGxlJylcbiAgICAgICAgcmV0dXJuIGRlY29kZVR1cGxlKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ2FkZHJlc3MnKVxuICAgICAgICByZXR1cm4gZGVjb2RlQWRkcmVzcyhjdXJzb3IsIHsgY2hlY2tzdW06IGNoZWNrc3VtQWRkcmVzcyB9KTtcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ2Jvb2wnKVxuICAgICAgICByZXR1cm4gZGVjb2RlQm9vbChjdXJzb3IpO1xuICAgIGlmIChwYXJhbS50eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpXG4gICAgICAgIHJldHVybiBkZWNvZGVCeXRlcyhjdXJzb3IsIHBhcmFtLCB7IHN0YXRpY1Bvc2l0aW9uIH0pO1xuICAgIGlmIChwYXJhbS50eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fCBwYXJhbS50eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKVxuICAgICAgICByZXR1cm4gZGVjb2RlTnVtYmVyKGN1cnNvciwgcGFyYW0pO1xuICAgIGlmIChwYXJhbS50eXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGRlY29kZVN0cmluZyhjdXJzb3IsIHsgc3RhdGljUG9zaXRpb24gfSk7XG4gICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuSW52YWxpZFR5cGVFcnJvcihwYXJhbS50eXBlKTtcbn1cbmNvbnN0IHNpemVPZkxlbmd0aCA9IDMyO1xuY29uc3Qgc2l6ZU9mT2Zmc2V0ID0gMzI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQWRkcmVzcyhjdXJzb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2hlY2tzdW0gPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IGN1cnNvci5yZWFkQnl0ZXMoMzIpO1xuICAgIGNvbnN0IHdyYXAgPSAoYWRkcmVzcykgPT4gY2hlY2tzdW0gPyBBZGRyZXNzLmNoZWNrc3VtKGFkZHJlc3MpIDogYWRkcmVzcztcbiAgICByZXR1cm4gW3dyYXAoSGV4LmZyb21CeXRlcyhCeXRlcy5zbGljZSh2YWx1ZSwgLTIwKSkpLCAzMl07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQXJyYXkoY3Vyc29yLCBwYXJhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBsZW5ndGgsIHN0YXRpY1Bvc2l0aW9uIH0gPSBvcHRpb25zO1xuICAgIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IGlzIG5vdCBrbm93biBpbiBhZHZhbmNlIChkeW5hbWljIGFycmF5KSxcbiAgICAvLyB0aGlzIG1lYW5zIHdlIHdpbGwgbmVlZCB0byB3b25kZXIgb2ZmIHRvIHRoZSBwb2ludGVyIGFuZCBkZWNvZGUuXG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgLy8gRGVhbGluZyB3aXRoIGEgZHluYW1pYyB0eXBlLCBzbyBnZXQgdGhlIG9mZnNldCBvZiB0aGUgYXJyYXkgZGF0YS5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcbiAgICAgICAgLy8gU3RhcnQgaXMgdGhlIHN0YXRpYyBwb3NpdGlvbiBvZiBjdXJyZW50IHNsb3QgKyBvZmZzZXQuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZEYXRhID0gc3RhcnQgKyBzaXplT2ZMZW5ndGg7XG4gICAgICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBmcm9tIHRoZSBvZmZzZXQuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mTGVuZ3RoKSk7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhcnJheSBoYXMgYW55IGR5bmFtaWMgY2hpbGRyZW4uXG4gICAgICAgIGNvbnN0IGR5bmFtaWNDaGlsZCA9IGhhc0R5bmFtaWNDaGlsZChwYXJhbSk7XG4gICAgICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIC8vIElmIGFueSBvZiB0aGUgY2hpbGRyZW4gaXMgZHluYW1pYywgdGhlbiBhbGwgZWxlbWVudHMgd2lsbCBiZSBvZmZzZXQgcG9pbnRlciwgdGh1cyBzaXplIG9mIG9uZSBzbG90ICgzMiBieXRlcykuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGVsZW1lbnRzIHdpbGwgYmUgdGhlIHNpemUgb2YgdGhlaXIgZW5jb2RpbmcgKGNvbnN1bWVkIGJ5dGVzKS5cbiAgICAgICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydE9mRGF0YSArIChkeW5hbWljQ2hpbGQgPyBpICogMzIgOiBjb25zdW1lZCkpO1xuICAgICAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnRPZkRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgICAgIHZhbHVlLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBpcyBrbm93biBpbiBhZHZhbmNlLFxuICAgIC8vIGFuZCB0aGUgbGVuZ3RoIG9mIGFuIGVsZW1lbnQgZGVlcGx5IG5lc3RlZCBpbiB0aGUgYXJyYXkgaXMgbm90IGtub3duLFxuICAgIC8vIHdlIG5lZWQgdG8gZGVjb2RlIHRoZSBvZmZzZXQgb2YgdGhlIGFycmF5IGRhdGEuXG4gICAgaWYgKGhhc0R5bmFtaWNDaGlsZChwYXJhbSkpIHtcbiAgICAgICAgLy8gRGVhbGluZyB3aXRoIGR5bmFtaWMgdHlwZXMsIHNvIGdldCB0aGUgb2Zmc2V0IG9mIHRoZSBhcnJheSBkYXRhLlxuICAgICAgICBjb25zdCBvZmZzZXQgPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKHNpemVPZk9mZnNldCkpO1xuICAgICAgICAvLyBTdGFydCBpcyB0aGUgc3RhdGljIHBvc2l0aW9uIG9mIGN1cnJlbnQgc2xvdCArIG9mZnNldC5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGF0aWNQb3NpdGlvbiArIG9mZnNldDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy8gTW92ZSBjdXJzb3IgYWxvbmcgdG8gdGhlIG5leHQgc2xvdCAobmV4dCBvZmZzZXQgcG9pbnRlcikuXG4gICAgICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnQgKyBpICogMzIpO1xuICAgICAgICAgICAgY29uc3QgW2RhdGFdID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc3RhdGljUG9zaXRpb246IHN0YXJ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgaXMga25vd24gaW4gYWR2YW5jZSBhbmQgdGhlIGFycmF5IGlzIGRlZXBseSBzdGF0aWMsXG4gICAgLy8gdGhlbiB3ZSBjYW4ganVzdCBkZWNvZGUgZWFjaCBlbGVtZW50IGluIHNlcXVlbmNlLlxuICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGF0aWNQb3NpdGlvbiArIGNvbnN1bWVkLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICB2YWx1ZS5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gW3ZhbHVlLCBjb25zdW1lZF07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQm9vbChjdXJzb3IpIHtcbiAgICByZXR1cm4gW0J5dGVzLnRvQm9vbGVhbihjdXJzb3IucmVhZEJ5dGVzKDMyKSwgeyBzaXplOiAzMiB9KSwgMzJdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJ5dGVzKGN1cnNvciwgcGFyYW0sIHsgc3RhdGljUG9zaXRpb24gfSkge1xuICAgIGNvbnN0IFtfLCBzaXplXSA9IHBhcmFtLnR5cGUuc3BsaXQoJ2J5dGVzJyk7XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICAgIC8vIERlYWxpbmcgd2l0aCBkeW5hbWljIHR5cGVzLCBzbyBnZXQgdGhlIG9mZnNldCBvZiB0aGUgYnl0ZXMgZGF0YS5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgICAgICAvLyBTZXQgcG9zaXRpb24gb2YgdGhlIGN1cnNvciB0byBzdGFydCBvZiBieXRlcyBkYXRhLlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyBvZmZzZXQpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKDMyKSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGxlbmd0aCwgd2UgaGF2ZSB6ZXJvIGRhdGEuXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgICAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICAgICAgcmV0dXJuIFsnMHgnLCAzMl07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGN1cnNvci5yZWFkQnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgcmV0dXJuIFtIZXguZnJvbUJ5dGVzKGRhdGEpLCAzMl07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gSGV4LmZyb21CeXRlcyhjdXJzb3IucmVhZEJ5dGVzKE51bWJlci5wYXJzZUludChzaXplLCAxMCksIDMyKSk7XG4gICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU51bWJlcihjdXJzb3IsIHBhcmFtKSB7XG4gICAgY29uc3Qgc2lnbmVkID0gcGFyYW0udHlwZS5zdGFydHNXaXRoKCdpbnQnKTtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyLnBhcnNlSW50KHBhcmFtLnR5cGUuc3BsaXQoJ2ludCcpWzFdIHx8ICcyNTYnLCAxMCk7XG4gICAgY29uc3QgdmFsdWUgPSBjdXJzb3IucmVhZEJ5dGVzKDMyKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzaXplID4gNDhcbiAgICAgICAgICAgID8gQnl0ZXMudG9CaWdJbnQodmFsdWUsIHsgc2lnbmVkIH0pXG4gICAgICAgICAgICA6IEJ5dGVzLnRvTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCB9KSxcbiAgICAgICAgMzIsXG4gICAgXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUdXBsZShjdXJzb3IsIHBhcmFtLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIHN0YXRpY1Bvc2l0aW9uIH0gPSBvcHRpb25zO1xuICAgIC8vIFR1cGxlcyBjYW4gaGF2ZSB1bm5hbWVkIGNvbXBvbmVudHMgKGkuZS4gdGhleSBhcmUgYXJyYXlzKSwgc28gd2UgbXVzdFxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoZSB0dXBsZSBpcyBuYW1lZCBvciB1bm5hbWVkLiBJbiB0aGUgY2FzZSBvZiBhIG5hbWVkXG4gICAgLy8gdHVwbGUsIHRoZSB2YWx1ZSB3aWxsIGJlIGFuIG9iamVjdCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIHRoZSBuYW1lIG9mIHRoZVxuICAgIC8vIGNvbXBvbmVudC4gSW4gdGhlIGNhc2Ugb2YgYW4gdW5uYW1lZCB0dXBsZSwgdGhlIHZhbHVlIHdpbGwgYmUgYW4gYXJyYXkuXG4gICAgY29uc3QgaGFzVW5uYW1lZENoaWxkID0gcGFyYW0uY29tcG9uZW50cy5sZW5ndGggPT09IDAgfHwgcGFyYW0uY29tcG9uZW50cy5zb21lKCh7IG5hbWUgfSkgPT4gIW5hbWUpO1xuICAgIC8vIEluaXRpYWxpemUgdGhlIHZhbHVlIHRvIGFuIG9iamVjdCBvciBhbiBhcnJheSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlXG4gICAgLy8gdHVwbGUgaXMgbmFtZWQgb3IgdW5uYW1lZC5cbiAgICBjb25zdCB2YWx1ZSA9IGhhc1VubmFtZWRDaGlsZCA/IFtdIDoge307XG4gICAgbGV0IGNvbnN1bWVkID0gMDtcbiAgICAvLyBJZiB0aGUgdHVwbGUgaGFzIGEgZHluYW1pYyBjaGlsZCwgd2UgbXVzdCBmaXJzdCBkZWNvZGUgdGhlIG9mZnNldCB0byB0aGVcbiAgICAvLyB0dXBsZSBkYXRhLlxuICAgIGlmIChoYXNEeW5hbWljQ2hpbGQocGFyYW0pKSB7XG4gICAgICAgIC8vIERlYWxpbmcgd2l0aCBkeW5hbWljIHR5cGVzLCBzbyBnZXQgdGhlIG9mZnNldCBvZiB0aGUgdHVwbGUgZGF0YS5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcbiAgICAgICAgLy8gU3RhcnQgaXMgdGhlIHN0YXRpYyBwb3NpdGlvbiBvZiByZWZlcmVuY2luZyBzbG90ICsgb2Zmc2V0LlxuICAgICAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHBhcmFtLmNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnQgKyBjb25zdW1lZCk7XG4gICAgICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIGNvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgICAgIHZhbHVlW2hhc1VubmFtZWRDaGlsZCA/IGkgOiBjb21wb25lbnQ/Lm5hbWVdID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG4gICAgfVxuICAgIC8vIElmIHRoZSB0dXBsZSBoYXMgc3RhdGljIGNoaWxkcmVuLCB3ZSBjYW4ganVzdCBkZWNvZGUgZWFjaCBjb21wb25lbnRcbiAgICAvLyBpbiBzZXF1ZW5jZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcGFyYW0uY29tcG9uZW50c1tpXTtcbiAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBjb21wb25lbnQsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWVbaGFzVW5uYW1lZENoaWxkID8gaSA6IGNvbXBvbmVudD8ubmFtZV0gPSBkYXRhO1xuICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIGNvbnN1bWVkXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmcoY3Vyc29yLCB7IHN0YXRpY1Bvc2l0aW9uIH0pIHtcbiAgICAvLyBHZXQgb2Zmc2V0IHRvIHN0YXJ0IG9mIHN0cmluZyBkYXRhLlxuICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcbiAgICAvLyBTdGFydCBpcyB0aGUgc3RhdGljIHBvc2l0aW9uIG9mIGN1cnJlbnQgc2xvdCArIG9mZnNldC5cbiAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCk7XG4gICAgY29uc3QgbGVuZ3RoID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGxlbmd0aCwgd2UgaGF2ZSB6ZXJvIGRhdGEgKGVtcHR5IHN0cmluZykuXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbJycsIDMyXTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGN1cnNvci5yZWFkQnl0ZXMobGVuZ3RoLCAzMik7XG4gICAgY29uc3QgdmFsdWUgPSBCeXRlcy50b1N0cmluZyhCeXRlcy50cmltTGVmdChkYXRhKSk7XG4gICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlUGFyYW1ldGVycyh7IGNoZWNrc3VtQWRkcmVzcywgcGFyYW1ldGVycywgdmFsdWVzLCB9KSB7XG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVQYXJhbWV0ZXIoe1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyOiBwYXJhbWV0ZXJzW2ldLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlcGFyZWRQYXJhbWV0ZXJzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVQYXJhbWV0ZXIoeyBjaGVja3N1bUFkZHJlc3MgPSBmYWxzZSwgcGFyYW1ldGVyOiBwYXJhbWV0ZXJfLCB2YWx1ZSwgfSkge1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IHBhcmFtZXRlcl87XG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzKHBhcmFtZXRlci50eXBlKTtcbiAgICBpZiAoYXJyYXlDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnN0IFtsZW5ndGgsIHR5cGVdID0gYXJyYXlDb21wb25lbnRzO1xuICAgICAgICByZXR1cm4gZW5jb2RlQXJyYXkodmFsdWUsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIHBhcmFtZXRlcjoge1xuICAgICAgICAgICAgICAgIC4uLnBhcmFtZXRlcixcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ3R1cGxlJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlVHVwbGUodmFsdWUsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHBhcmFtZXRlcjogcGFyYW1ldGVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUFkZHJlc3ModmFsdWUsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtOiBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdib29sJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlQm9vbGVhbih2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgcGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkID0gcGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aCgnaW50Jyk7XG4gICAgICAgIGNvbnN0IFssICwgc2l6ZSA9ICcyNTYnXSA9IGludGVnZXJSZWdleC5leGVjKHBhcmFtZXRlci50eXBlKSA/PyBbXTtcbiAgICAgICAgcmV0dXJuIGVuY29kZU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgc2l6ZTogTnVtYmVyKHNpemUpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJ5dGVzKHZhbHVlLCB7IHR5cGU6IHBhcmFtZXRlci50eXBlIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yKHBhcmFtZXRlci50eXBlKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUocHJlcGFyZWRQYXJhbWV0ZXJzKSB7XG4gICAgLy8gMS4gQ29tcHV0ZSB0aGUgc2l6ZSBvZiB0aGUgc3RhdGljIHBhcnQgb2YgdGhlIHBhcmFtZXRlcnMuXG4gICAgbGV0IHN0YXRpY1NpemUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgZHluYW1pYywgZW5jb2RlZCB9ID0gcHJlcGFyZWRQYXJhbWV0ZXJzW2ldO1xuICAgICAgICBpZiAoZHluYW1pYylcbiAgICAgICAgICAgIHN0YXRpY1NpemUgKz0gMzI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0YXRpY1NpemUgKz0gSGV4LnNpemUoZW5jb2RlZCk7XG4gICAgfVxuICAgIC8vIDIuIFNwbGl0IHRoZSBwYXJhbWV0ZXJzIGludG8gc3RhdGljIGFuZCBkeW5hbWljIHBhcnRzLlxuICAgIGNvbnN0IHN0YXRpY1BhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBkeW5hbWljUGFyYW1ldGVycyA9IFtdO1xuICAgIGxldCBkeW5hbWljU2l6ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBkeW5hbWljLCBlbmNvZGVkIH0gPSBwcmVwYXJlZFBhcmFtZXRlcnNbaV07XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBzdGF0aWNQYXJhbWV0ZXJzLnB1c2goSGV4LmZyb21OdW1iZXIoc3RhdGljU2l6ZSArIGR5bmFtaWNTaXplLCB7IHNpemU6IDMyIH0pKTtcbiAgICAgICAgICAgIGR5bmFtaWNQYXJhbWV0ZXJzLnB1c2goZW5jb2RlZCk7XG4gICAgICAgICAgICBkeW5hbWljU2l6ZSArPSBIZXguc2l6ZShlbmNvZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRpY1BhcmFtZXRlcnMucHVzaChlbmNvZGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAzLiBDb25jYXRlbmF0ZSBzdGF0aWMgYW5kIGR5bmFtaWMgcGFydHMuXG4gICAgcmV0dXJuIEhleC5jb25jYXQoLi4uc3RhdGljUGFyYW1ldGVycywgLi4uZHluYW1pY1BhcmFtZXRlcnMpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUFkZHJlc3ModmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgQWRkcmVzcy5hc3NlcnQodmFsdWUsIHsgc3RyaWN0OiBjaGVja3N1bSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LnBhZExlZnQodmFsdWUudG9Mb3dlckNhc2UoKSksXG4gICAgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVBcnJheSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBsZW5ndGgsIHBhcmFtZXRlciB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBkeW5hbWljID0gbGVuZ3RoID09PSBudWxsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkludmFsaWRBcnJheUVycm9yKHZhbHVlKTtcbiAgICBpZiAoIWR5bmFtaWMgJiYgdmFsdWUubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZExlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgIHR5cGU6IGAke3BhcmFtZXRlci50eXBlfVske2xlbmd0aH1dYCxcbiAgICAgICAgfSk7XG4gICAgbGV0IGR5bmFtaWNDaGlsZCA9IGZhbHNlO1xuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRQYXJhbSA9IHByZXBhcmVQYXJhbWV0ZXIoe1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZCA9IHRydWU7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVkUGFyYW0pO1xuICAgIH1cbiAgICBpZiAoZHluYW1pYyB8fCBkeW5hbWljQ2hpbGQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gSGV4LmZyb21OdW1iZXIocHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aCwgeyBzaXplOiAzMiB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmNvZGVkOiBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoID4gMCA/IEhleC5jb25jYXQobGVuZ3RoLCBkYXRhKSA6IGxlbmd0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZClcbiAgICAgICAgICAgIHJldHVybiB7IGR5bmFtaWM6IHRydWUsIGVuY29kZWQ6IGRhdGEgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgIGVuY29kZWQ6IEhleC5jb25jYXQoLi4ucHJlcGFyZWRQYXJhbWV0ZXJzLm1hcCgoeyBlbmNvZGVkIH0pID0+IGVuY29kZWQpKSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJ5dGVzKHZhbHVlLCB7IHR5cGUgfSkge1xuICAgIGNvbnN0IFssIHBhcmFtZXRlcnNpemVdID0gdHlwZS5zcGxpdCgnYnl0ZXMnKTtcbiAgICBjb25zdCBieXRlc1NpemUgPSBIZXguc2l6ZSh2YWx1ZSk7XG4gICAgaWYgKCFwYXJhbWV0ZXJzaXplKSB7XG4gICAgICAgIGxldCB2YWx1ZV8gPSB2YWx1ZTtcbiAgICAgICAgLy8gSWYgdGhlIHNpemUgaXMgbm90IGRpdmlzaWJsZSBieSAzMiBieXRlcywgcGFkIHRoZSBlbmRcbiAgICAgICAgLy8gd2l0aCBlbXB0eSBieXRlcyB0byB0aGUgY2VpbGluZyAzMiBieXRlcy5cbiAgICAgICAgaWYgKGJ5dGVzU2l6ZSAlIDMyICE9PSAwKVxuICAgICAgICAgICAgdmFsdWVfID0gSGV4LnBhZFJpZ2h0KHZhbHVlXywgTWF0aC5jZWlsKCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIgLyAzMikgKiAzMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgICAgICAgZW5jb2RlZDogSGV4LmNvbmNhdChIZXgucGFkTGVmdChIZXguZnJvbU51bWJlcihieXRlc1NpemUsIHsgc2l6ZTogMzIgfSkpLCB2YWx1ZV8pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoYnl0ZXNTaXplICE9PSBOdW1iZXIucGFyc2VJbnQocGFyYW1ldGVyc2l6ZSwgMTApKVxuICAgICAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5CeXRlc1NpemVNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHBhcmFtZXRlcnNpemUsIDEwKSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICByZXR1cm4geyBkeW5hbWljOiBmYWxzZSwgZW5jb2RlZDogSGV4LnBhZFJpZ2h0KHZhbHVlKSB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJvb2xlYW4odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKGBJbnZhbGlkIGJvb2xlYW4gdmFsdWU6IFwiJHt2YWx1ZX1cIiAodHlwZTogJHt0eXBlb2YgdmFsdWV9KS4gRXhwZWN0ZWQ6IFxcYHRydWVcXGAgb3IgXFxgZmFsc2VcXGAuYCk7XG4gICAgcmV0dXJuIHsgZHluYW1pYzogZmFsc2UsIGVuY29kZWQ6IEhleC5wYWRMZWZ0KEhleC5mcm9tQm9vbGVhbih2YWx1ZSkpIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCwgc2l6ZSB9KSB7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBtYXggPSAybiAqKiAoQmlnSW50KHNpemUpIC0gKHNpZ25lZCA/IDFuIDogMG4pKSAtIDFuO1xuICAgICAgICBjb25zdCBtaW4gPSBzaWduZWQgPyAtbWF4IC0gMW4gOiAwbjtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEhleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yKHtcbiAgICAgICAgICAgICAgICBtYXg6IG1heC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG1pbjogbWluLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgICAgIHNpemU6IHNpemUgLyA4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS50b1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IGZhbHNlLFxuICAgICAgICBlbmNvZGVkOiBIZXguZnJvbU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgc2l6ZTogMzIsXG4gICAgICAgICAgICBzaWduZWQsXG4gICAgICAgIH0pLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgaGV4VmFsdWUgPSBIZXguZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgcGFydHNMZW5ndGggPSBNYXRoLmNlaWwoSGV4LnNpemUoaGV4VmFsdWUpIC8gMzIpO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goSGV4LnBhZFJpZ2h0KEhleC5zbGljZShoZXhWYWx1ZSwgaSAqIDMyLCAoaSArIDEpICogMzIpKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgIGVuY29kZWQ6IEhleC5jb25jYXQoSGV4LnBhZFJpZ2h0KEhleC5mcm9tTnVtYmVyKEhleC5zaXplKGhleFZhbHVlKSwgeyBzaXplOiAzMiB9KSksIC4uLnBhcnRzKSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVR1cGxlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIHBhcmFtZXRlciB9ID0gb3B0aW9ucztcbiAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVyLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyYW1fID0gcGFyYW1ldGVyLmNvbXBvbmVudHNbaV07XG4gICAgICAgIGNvbnN0IGluZGV4ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBpIDogcGFyYW1fLm5hbWU7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkUGFyYW0gPSBwcmVwYXJlUGFyYW1ldGVyKHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHBhcmFtZXRlcjogcGFyYW1fLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2luZGV4XSxcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVkUGFyYW0pO1xuICAgICAgICBpZiAocHJlcGFyZWRQYXJhbS5keW5hbWljKVxuICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWMsXG4gICAgICAgIGVuY29kZWQ6IGR5bmFtaWNcbiAgICAgICAgICAgID8gZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycylcbiAgICAgICAgICAgIDogSGV4LmNvbmNhdCguLi5wcmVwYXJlZFBhcmFtZXRlcnMubWFwKCh7IGVuY29kZWQgfSkgPT4gZW5jb2RlZCkpLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJyYXlDb21wb25lbnRzKHR5cGUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gdHlwZS5tYXRjaCgvXiguKilcXFsoXFxkKyk/XFxdJC8pO1xuICAgIHJldHVybiBtYXRjaGVzXG4gICAgICAgID8gLy8gUmV0dXJuIGBudWxsYCBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYy5cbiAgICAgICAgICAgIFttYXRjaGVzWzJdID8gTnVtYmVyKG1hdGNoZXNbMl0pIDogbnVsbCwgbWF0Y2hlc1sxXV1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRHluYW1pY0NoaWxkKHBhcmFtKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBwYXJhbTtcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZS5lbmRzV2l0aCgnW10nKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICd0dXBsZScpXG4gICAgICAgIHJldHVybiBwYXJhbS5jb21wb25lbnRzPy5zb21lKGhhc0R5bmFtaWNDaGlsZCk7XG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzKHBhcmFtLnR5cGUpO1xuICAgIGlmIChhcnJheUNvbXBvbmVudHMgJiZcbiAgICAgICAgaGFzRHluYW1pY0NoaWxkKHtcbiAgICAgICAgICAgIC4uLnBhcmFtLFxuICAgICAgICAgICAgdHlwZTogYXJyYXlDb21wb25lbnRzWzFdLFxuICAgICAgICB9KSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpUGFyYW1ldGVycy5qcy5tYXAiXSwibmFtZXMiOlsiQWJpUGFyYW1ldGVycyIsIkFkZHJlc3MiLCJCeXRlcyIsIkVycm9ycyIsIkhleCIsImludGVnZXJSZWdleCIsImRlY29kZVBhcmFtZXRlciIsImN1cnNvciIsInBhcmFtIiwib3B0aW9ucyIsImNoZWNrc3VtQWRkcmVzcyIsInN0YXRpY1Bvc2l0aW9uIiwiYXJyYXlDb21wb25lbnRzIiwiZ2V0QXJyYXlDb21wb25lbnRzIiwidHlwZSIsImxlbmd0aCIsImRlY29kZUFycmF5IiwiZGVjb2RlVHVwbGUiLCJkZWNvZGVBZGRyZXNzIiwiY2hlY2tzdW0iLCJkZWNvZGVCb29sIiwic3RhcnRzV2l0aCIsImRlY29kZUJ5dGVzIiwiZGVjb2RlTnVtYmVyIiwiZGVjb2RlU3RyaW5nIiwiSW52YWxpZFR5cGVFcnJvciIsInNpemVPZkxlbmd0aCIsInNpemVPZk9mZnNldCIsInZhbHVlIiwicmVhZEJ5dGVzIiwid3JhcCIsImFkZHJlc3MiLCJmcm9tQnl0ZXMiLCJzbGljZSIsIm9mZnNldCIsInRvTnVtYmVyIiwic3RhcnQiLCJzdGFydE9mRGF0YSIsInNldFBvc2l0aW9uIiwiZHluYW1pY0NoaWxkIiwiaGFzRHluYW1pY0NoaWxkIiwiY29uc3VtZWQiLCJpIiwiZGF0YSIsImNvbnN1bWVkXyIsInB1c2giLCJ0b0Jvb2xlYW4iLCJzaXplIiwiXyIsInNwbGl0IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJzaWduZWQiLCJ0b0JpZ0ludCIsImhhc1VubmFtZWRDaGlsZCIsImNvbXBvbmVudHMiLCJzb21lIiwibmFtZSIsImNvbXBvbmVudCIsInRvU3RyaW5nIiwidHJpbUxlZnQiLCJwcmVwYXJlUGFyYW1ldGVycyIsInBhcmFtZXRlcnMiLCJ2YWx1ZXMiLCJwcmVwYXJlZFBhcmFtZXRlcnMiLCJwcmVwYXJlUGFyYW1ldGVyIiwicGFyYW1ldGVyIiwicGFyYW1ldGVyXyIsImVuY29kZUFycmF5IiwiZW5jb2RlVHVwbGUiLCJlbmNvZGVBZGRyZXNzIiwiZW5jb2RlQm9vbGVhbiIsImV4ZWMiLCJlbmNvZGVOdW1iZXIiLCJlbmNvZGVCeXRlcyIsImVuY29kZVN0cmluZyIsImVuY29kZSIsInN0YXRpY1NpemUiLCJkeW5hbWljIiwiZW5jb2RlZCIsInN0YXRpY1BhcmFtZXRlcnMiLCJkeW5hbWljUGFyYW1ldGVycyIsImR5bmFtaWNTaXplIiwiZnJvbU51bWJlciIsImNvbmNhdCIsImFzc2VydCIsInN0cmljdCIsInBhZExlZnQiLCJ0b0xvd2VyQ2FzZSIsIkFycmF5IiwiaXNBcnJheSIsIkludmFsaWRBcnJheUVycm9yIiwiQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yIiwiZXhwZWN0ZWRMZW5ndGgiLCJnaXZlbkxlbmd0aCIsInByZXBhcmVkUGFyYW0iLCJtYXAiLCJwYXJhbWV0ZXJzaXplIiwiYnl0ZXNTaXplIiwidmFsdWVfIiwicGFkUmlnaHQiLCJNYXRoIiwiY2VpbCIsIkJ5dGVzU2l6ZU1pc21hdGNoRXJyb3IiLCJleHBlY3RlZFNpemUiLCJCYXNlRXJyb3IiLCJmcm9tQm9vbGVhbiIsIm1heCIsIkJpZ0ludCIsIm1pbiIsIkludGVnZXJPdXRPZlJhbmdlRXJyb3IiLCJoZXhWYWx1ZSIsImZyb21TdHJpbmciLCJwYXJ0c0xlbmd0aCIsInBhcnRzIiwicGFyYW1fIiwiaW5kZXgiLCJtYXRjaGVzIiwibWF0Y2giLCJ1bmRlZmluZWQiLCJlbmRzV2l0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/abiParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/bytes.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/bytes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   charCodeMap: () => (/* binding */ charCodeMap),\n/* harmony export */   charCodeToBase16: () => (/* binding */ charCodeToBase16),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n\n/** @internal */ function assertSize(bytes, size_) {\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) > size_) throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n        givenSize: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n        maxSize: size_\n    });\n}\n/** @internal */ function assertStartOffset(value, start) {\n    if (typeof start === \"number\" && start > 0 && start > _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1) throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n        offset: start,\n        position: \"start\",\n        size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value)\n    });\n}\n/** @internal */ function assertEndOffset(value, start, end) {\n    if (typeof start === \"number\" && typeof end === \"number\" && _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: \"end\",\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value)\n        });\n    }\n}\n/** @internal */ const charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\n/** @internal */ function charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/** @internal */ function pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0) return bytes;\n    if (bytes.length > size) throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n        size: bytes.length,\n        targetSize: size,\n        type: \"Bytes\"\n    });\n    const paddedBytes = new Uint8Array(size);\n    for(let i = 0; i < size; i++){\n        const padEnd = dir === \"right\";\n        paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n/** @internal */ function trim(value, options = {}) {\n    const { dir = \"left\" } = options;\n    let data = value;\n    let sliceLength = 0;\n    for(let i = 0; i < data.length - 1; i++){\n        if (data[dir === \"left\" ? i : data.length - i - 1].toString() === \"0\") sliceLength++;\n        else break;\n    }\n    data = dir === \"left\" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\n    return data;\n} //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ3JDLGNBQWMsR0FDUCxTQUFTQyxXQUFXQyxLQUFLLEVBQUVDLEtBQUs7SUFDbkMsSUFBSUgsMkNBQVUsQ0FBQ0UsU0FBU0MsT0FDcEIsTUFBTSxJQUFJSCx3REFBdUIsQ0FBQztRQUM5Qk0sV0FBV04sMkNBQVUsQ0FBQ0U7UUFDdEJLLFNBQVNKO0lBQ2I7QUFDUjtBQUNBLGNBQWMsR0FDUCxTQUFTSyxrQkFBa0JDLEtBQUssRUFBRUMsS0FBSztJQUMxQyxJQUFJLE9BQU9BLFVBQVUsWUFBWUEsUUFBUSxLQUFLQSxRQUFRViwyQ0FBVSxDQUFDUyxTQUFTLEdBQ3RFLE1BQU0sSUFBSVQsa0VBQWlDLENBQUM7UUFDeENZLFFBQVFGO1FBQ1JHLFVBQVU7UUFDVlQsTUFBTUosMkNBQVUsQ0FBQ1M7SUFDckI7QUFDUjtBQUNBLGNBQWMsR0FDUCxTQUFTSyxnQkFBZ0JMLEtBQUssRUFBRUMsS0FBSyxFQUFFSyxHQUFHO0lBQzdDLElBQUksT0FBT0wsVUFBVSxZQUNqQixPQUFPSyxRQUFRLFlBQ2ZmLDJDQUFVLENBQUNTLFdBQVdNLE1BQU1MLE9BQU87UUFDbkMsTUFBTSxJQUFJVixrRUFBaUMsQ0FBQztZQUN4Q1ksUUFBUUc7WUFDUkYsVUFBVTtZQUNWVCxNQUFNSiwyQ0FBVSxDQUFDUztRQUNyQjtJQUNKO0FBQ0o7QUFDQSxjQUFjLEdBQ1AsTUFBTU8sY0FBYztJQUN2QkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7QUFDUCxFQUFFO0FBQ0YsY0FBYyxHQUNQLFNBQVNDLGlCQUFpQkMsSUFBSTtJQUNqQyxJQUFJQSxRQUFRUixZQUFZQyxJQUFJLElBQUlPLFFBQVFSLFlBQVlFLElBQUksRUFDcEQsT0FBT00sT0FBT1IsWUFBWUMsSUFBSTtJQUNsQyxJQUFJTyxRQUFRUixZQUFZRyxDQUFDLElBQUlLLFFBQVFSLFlBQVlJLENBQUMsRUFDOUMsT0FBT0ksT0FBUVIsQ0FBQUEsWUFBWUcsQ0FBQyxHQUFHLEVBQUM7SUFDcEMsSUFBSUssUUFBUVIsWUFBWUssQ0FBQyxJQUFJRyxRQUFRUixZQUFZTSxDQUFDLEVBQzlDLE9BQU9FLE9BQVFSLENBQUFBLFlBQVlLLENBQUMsR0FBRyxFQUFDO0lBQ3BDLE9BQU9JO0FBQ1g7QUFDQSxjQUFjLEdBQ1AsU0FBU0MsSUFBSXhCLEtBQUssRUFBRXlCLFVBQVUsQ0FBQyxDQUFDO0lBQ25DLE1BQU0sRUFBRUMsR0FBRyxFQUFFeEIsT0FBTyxFQUFFLEVBQUUsR0FBR3VCO0lBQzNCLElBQUl2QixTQUFTLEdBQ1QsT0FBT0Y7SUFDWCxJQUFJQSxNQUFNMkIsTUFBTSxHQUFHekIsTUFDZixNQUFNLElBQUlKLGtFQUFpQyxDQUFDO1FBQ3hDSSxNQUFNRixNQUFNMkIsTUFBTTtRQUNsQkUsWUFBWTNCO1FBQ1o0QixNQUFNO0lBQ1Y7SUFDSixNQUFNQyxjQUFjLElBQUlDLFdBQVc5QjtJQUNuQyxJQUFLLElBQUkrQixJQUFJLEdBQUdBLElBQUkvQixNQUFNK0IsSUFBSztRQUMzQixNQUFNQyxTQUFTUixRQUFRO1FBQ3ZCSyxXQUFXLENBQUNHLFNBQVNELElBQUkvQixPQUFPK0IsSUFBSSxFQUFFLEdBQ2xDakMsS0FBSyxDQUFDa0MsU0FBU0QsSUFBSWpDLE1BQU0yQixNQUFNLEdBQUdNLElBQUksRUFBRTtJQUNoRDtJQUNBLE9BQU9GO0FBQ1g7QUFDQSxjQUFjLEdBQ1AsU0FBU0ksS0FBSzVCLEtBQUssRUFBRWtCLFVBQVUsQ0FBQyxDQUFDO0lBQ3BDLE1BQU0sRUFBRUMsTUFBTSxNQUFNLEVBQUUsR0FBR0Q7SUFDekIsSUFBSVcsT0FBTzdCO0lBQ1gsSUFBSThCLGNBQWM7SUFDbEIsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUlHLEtBQUtULE1BQU0sR0FBRyxHQUFHTSxJQUFLO1FBQ3RDLElBQUlHLElBQUksQ0FBQ1YsUUFBUSxTQUFTTyxJQUFJRyxLQUFLVCxNQUFNLEdBQUdNLElBQUksRUFBRSxDQUFDSyxRQUFRLE9BQU8sS0FDOUREO2FBRUE7SUFDUjtJQUNBRCxPQUNJVixRQUFRLFNBQ0ZVLEtBQUtHLEtBQUssQ0FBQ0YsZUFDWEQsS0FBS0csS0FBSyxDQUFDLEdBQUdILEtBQUtULE1BQU0sR0FBR1U7SUFDdEMsT0FBT0Q7QUFDWCxFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYzQzMzctZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2J5dGVzLmpzPzUxMGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi4vQnl0ZXMuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFNpemUoYnl0ZXMsIHNpemVfKSB7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpID4gc2l6ZV8pXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEJ5dGVzLnNpemUoYnl0ZXMpLFxuICAgICAgICAgICAgbWF4U2l6ZTogc2l6ZV8sXG4gICAgICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmIHN0YXJ0ID4gMCAmJiBzdGFydCA+IEJ5dGVzLnNpemUodmFsdWUpIC0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEJ5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICAgICAgcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgQnl0ZXMuc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBlbmQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2VuZCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGNoYXJDb2RlTWFwID0ge1xuICAgIHplcm86IDQ4LFxuICAgIG5pbmU6IDU3LFxuICAgIEE6IDY1LFxuICAgIEY6IDcwLFxuICAgIGE6IDk3LFxuICAgIGY6IDEwMixcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gY2hhckNvZGVUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuemVybyAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLm5pbmUpXG4gICAgICAgIHJldHVybiBjaGFyIC0gY2hhckNvZGVNYXAuemVybztcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5BICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5hICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuYSAtIDEwKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZChieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIsIHNpemUgPSAzMiB9ID0gb3B0aW9ucztcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIGlmIChieXRlcy5sZW5ndGggPiBzaXplKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yKHtcbiAgICAgICAgICAgIHNpemU6IGJ5dGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnQnl0ZXMnLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhZEVuZCA9IGRpciA9PT0gJ3JpZ2h0JztcbiAgICAgICAgcGFkZGVkQnl0ZXNbcGFkRW5kID8gaSA6IHNpemUgLSBpIC0gMV0gPVxuICAgICAgICAgICAgYnl0ZXNbcGFkRW5kID8gaSA6IGJ5dGVzLmxlbmd0aCAtIGkgLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW0odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyID0gJ2xlZnQnIH0gPSBvcHRpb25zO1xuICAgIGxldCBkYXRhID0gdmFsdWU7XG4gICAgbGV0IHNsaWNlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2RpciA9PT0gJ2xlZnQnID8gaSA6IGRhdGEubGVuZ3RoIC0gaSAtIDFdLnRvU3RyaW5nKCkgPT09ICcwJylcbiAgICAgICAgICAgIHNsaWNlTGVuZ3RoKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkYXRhID1cbiAgICAgICAgZGlyID09PSAnbGVmdCdcbiAgICAgICAgICAgID8gZGF0YS5zbGljZShzbGljZUxlbmd0aClcbiAgICAgICAgICAgIDogZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHNsaWNlTGVuZ3RoKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJCeXRlcyIsImFzc2VydFNpemUiLCJieXRlcyIsInNpemVfIiwic2l6ZSIsIlNpemVPdmVyZmxvd0Vycm9yIiwiZ2l2ZW5TaXplIiwibWF4U2l6ZSIsImFzc2VydFN0YXJ0T2Zmc2V0IiwidmFsdWUiLCJzdGFydCIsIlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciIsIm9mZnNldCIsInBvc2l0aW9uIiwiYXNzZXJ0RW5kT2Zmc2V0IiwiZW5kIiwiY2hhckNvZGVNYXAiLCJ6ZXJvIiwibmluZSIsIkEiLCJGIiwiYSIsImYiLCJjaGFyQ29kZVRvQmFzZTE2IiwiY2hhciIsInVuZGVmaW5lZCIsInBhZCIsIm9wdGlvbnMiLCJkaXIiLCJsZW5ndGgiLCJTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IiLCJ0YXJnZXRTaXplIiwidHlwZSIsInBhZGRlZEJ5dGVzIiwiVWludDhBcnJheSIsImkiLCJwYWRFbmQiLCJ0cmltIiwiZGF0YSIsInNsaWNlTGVuZ3RoIiwidG9TdHJpbmciLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/cursor.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/cursor.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NegativeOffsetError: () => (/* binding */ NegativeOffsetError),\n/* harmony export */   PositionOutOfBoundsError: () => (/* binding */ PositionOutOfBoundsError),\n/* harmony export */   RecursiveReadLimitExceededError: () => (/* binding */ RecursiveReadLimitExceededError),\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n\nconst staticCursor = {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit () {\n        if (this.recursiveReadCount >= this.recursiveReadLimit) throw new RecursiveReadLimitExceededError({\n            count: this.recursiveReadCount + 1,\n            limit: this.recursiveReadLimit\n        });\n    },\n    assertPosition (position) {\n        if (position < 0 || position > this.bytes.length - 1) throw new PositionOutOfBoundsError({\n            length: this.bytes.length,\n            position\n        });\n    },\n    decrementPosition (offset) {\n        if (offset < 0) throw new NegativeOffsetError({\n            offset\n        });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount (position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition (offset) {\n        if (offset < 0) throw new NegativeOffsetError({\n            offset\n        });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes (length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8 (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16 (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24 (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);\n    },\n    inspectUint32 (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte (byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes (bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8 (value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16 (value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24 (value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32 (value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes (length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8 () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16 () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24 () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32 () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining () {\n        return this.bytes.length - this.position;\n    },\n    setPosition (position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return ()=>this.position = oldPosition;\n    },\n    _touch () {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0) this.recursiveReadCount++;\n    }\n};\n/** @internal */ function create(bytes, { recursiveReadLimit = 8192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\n/** @internal */ class NegativeOffsetError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ offset }){\n        super(`Offset \\`${offset}\\` cannot be negative.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Cursor.NegativeOffsetError\"\n        });\n    }\n}\n/** @internal */ class PositionOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ length, position }){\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Cursor.PositionOutOfBoundsError\"\n        });\n    }\n}\n/** @internal */ class RecursiveReadLimitExceededError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ count, limit }){\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Cursor.RecursiveReadLimitExceededError\"\n        });\n    }\n} //# sourceMappingURL=cursor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2N1cnNvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1QztBQUN2QyxNQUFNQyxlQUFlO0lBQ2pCQyxPQUFPLElBQUlDO0lBQ1hDLFVBQVUsSUFBSUMsU0FBUyxJQUFJQyxZQUFZO0lBQ3ZDQyxVQUFVO0lBQ1ZDLG1CQUFtQixJQUFJQztJQUN2QkMsb0JBQW9CO0lBQ3BCQyxvQkFBb0JDLE9BQU9DLGlCQUFpQjtJQUM1Q0M7UUFDSSxJQUFJLElBQUksQ0FBQ0osa0JBQWtCLElBQUksSUFBSSxDQUFDQyxrQkFBa0IsRUFDbEQsTUFBTSxJQUFJSSxnQ0FBZ0M7WUFDdENDLE9BQU8sSUFBSSxDQUFDTixrQkFBa0IsR0FBRztZQUNqQ08sT0FBTyxJQUFJLENBQUNOLGtCQUFrQjtRQUNsQztJQUNSO0lBQ0FPLGdCQUFlWCxRQUFRO1FBQ25CLElBQUlBLFdBQVcsS0FBS0EsV0FBVyxJQUFJLENBQUNMLEtBQUssQ0FBQ2lCLE1BQU0sR0FBRyxHQUMvQyxNQUFNLElBQUlDLHlCQUF5QjtZQUMvQkQsUUFBUSxJQUFJLENBQUNqQixLQUFLLENBQUNpQixNQUFNO1lBQ3pCWjtRQUNKO0lBQ1I7SUFDQWMsbUJBQWtCQyxNQUFNO1FBQ3BCLElBQUlBLFNBQVMsR0FDVCxNQUFNLElBQUlDLG9CQUFvQjtZQUFFRDtRQUFPO1FBQzNDLE1BQU1mLFdBQVcsSUFBSSxDQUFDQSxRQUFRLEdBQUdlO1FBQ2pDLElBQUksQ0FBQ0osY0FBYyxDQUFDWDtRQUNwQixJQUFJLENBQUNBLFFBQVEsR0FBR0E7SUFDcEI7SUFDQWlCLGNBQWFqQixRQUFRO1FBQ2pCLE9BQU8sSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ2lCLEdBQUcsQ0FBQ2xCLFlBQVksSUFBSSxDQUFDQSxRQUFRLEtBQUs7SUFDcEU7SUFDQW1CLG1CQUFrQkosTUFBTTtRQUNwQixJQUFJQSxTQUFTLEdBQ1QsTUFBTSxJQUFJQyxvQkFBb0I7WUFBRUQ7UUFB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SUFBSUM7SUFDL0JxRCxPQUFPbkQsa0JBQWtCLEdBQUdBO0lBQzVCLE9BQU9tRDtBQUNYO0FBQ0EsY0FBYyxHQUNQLE1BQU12Qyw0QkFBNEJ2QixpREFBZ0I7SUFDckRvRSxZQUFZLEVBQUU5QyxNQUFNLEVBQUUsQ0FBRTtRQUNwQixLQUFLLENBQUMsQ0FBQyxTQUFTLEVBQUVBLE9BQU8sc0JBQXNCLENBQUM7UUFDaER5QyxPQUFPTSxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1Y3QixPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0EsY0FBYyxHQUNQLE1BQU12QixpQ0FBaUNwQixpREFBZ0I7SUFDMURvRSxZQUFZLEVBQUVqRCxNQUFNLEVBQUVaLFFBQVEsRUFBRSxDQUFFO1FBQzlCLEtBQUssQ0FBQyxDQUFDLFdBQVcsRUFBRUEsU0FBUyxzQ0FBc0MsRUFBRVksT0FBTyxJQUFJLENBQUM7UUFDakY0QyxPQUFPTSxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1Y3QixPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0EsY0FBYyxHQUNQLE1BQU01Qix3Q0FBd0NmLGlEQUFnQjtJQUNqRW9FLFlBQVksRUFBRXBELEtBQUssRUFBRUMsS0FBSyxFQUFFLENBQUU7UUFDMUIsS0FBSyxDQUFDLENBQUMsMEJBQTBCLEVBQUVBLE1BQU0scUNBQXFDLEVBQUVELE1BQU0sSUFBSSxDQUFDO1FBQzNGK0MsT0FBT00sY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWN0IsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYzQzMzctZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2N1cnNvci5qcz83YWQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuLi9FcnJvcnMuanMnO1xuY29uc3Qgc3RhdGljQ3Vyc29yID0ge1xuICAgIGJ5dGVzOiBuZXcgVWludDhBcnJheSgpLFxuICAgIGRhdGFWaWV3OiBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKSxcbiAgICBwb3NpdGlvbjogMCxcbiAgICBwb3NpdGlvblJlYWRDb3VudDogbmV3IE1hcCgpLFxuICAgIHJlY3Vyc2l2ZVJlYWRDb3VudDogMCxcbiAgICByZWN1cnNpdmVSZWFkTGltaXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBhc3NlcnRSZWFkTGltaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY3Vyc2l2ZVJlYWRDb3VudCA+PSB0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yKHtcbiAgICAgICAgICAgICAgICBjb3VudDogdGhpcy5yZWN1cnNpdmVSZWFkQ291bnQgKyAxLFxuICAgICAgICAgICAgICAgIGxpbWl0OiB0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdCxcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG4gICAgYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+IHRoaXMuYnl0ZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBQb3NpdGlvbk91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy5ieXRlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRlY3JlbWVudFBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBOZWdhdGl2ZU9mZnNldEVycm9yKHsgb2Zmc2V0IH0pO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gLSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfSxcbiAgICBnZXRSZWFkQ291bnQocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25SZWFkQ291bnQuZ2V0KHBvc2l0aW9uIHx8IHRoaXMucG9zaXRpb24pIHx8IDA7XG4gICAgfSxcbiAgICBpbmNyZW1lbnRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgTmVnYXRpdmVPZmZzZXRFcnJvcih7IG9mZnNldCB9KTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0sXG4gICAgaW5zcGVjdEJ5dGUocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc1twb3NpdGlvbl07XG4gICAgfSxcbiAgICBpbnNwZWN0Qnl0ZXMobGVuZ3RoLCBwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIGxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQ4KHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNbcG9zaXRpb25dO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQxNihwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQyNChwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDIpO1xuICAgICAgICByZXR1cm4gKCh0aGlzLmRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbikgPDwgOCkgK1xuICAgICAgICAgICAgdGhpcy5kYXRhVmlldy5nZXRVaW50OChwb3NpdGlvbiArIDIpKTtcbiAgICB9LFxuICAgIGluc3BlY3RVaW50MzIocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyAzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHB1c2hCeXRlKGJ5dGUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5ieXRlc1t0aGlzLnBvc2l0aW9uXSA9IGJ5dGU7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9LFxuICAgIHB1c2hCeXRlcyhieXRlcykge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyBieXRlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5ieXRlcy5zZXQoYnl0ZXMsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGJ5dGVzLmxlbmd0aDtcbiAgICB9LFxuICAgIHB1c2hVaW50OCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLmJ5dGVzW3RoaXMucG9zaXRpb25dID0gdmFsdWU7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9LFxuICAgIHB1c2hVaW50MTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uICsgMSk7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgIH0sXG4gICAgcHVzaFVpbnQyNCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAyKTtcbiAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgdmFsdWUgPj4gOCk7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDgodGhpcy5wb3NpdGlvbiArIDIsIHZhbHVlICYgfjQyOTQ5NjcwNDApO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDM7XG4gICAgfSxcbiAgICBwdXNoVWludDMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbiArIDMpO1xuICAgICAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQzMih0aGlzLnBvc2l0aW9uLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICB9LFxuICAgIHJlYWRCeXRlKCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdEJ5dGUoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBzaXplKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0Qnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBzaXplID8/IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQ4KCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQ4KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQxNigpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RVaW50MTYoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkVWludDI0KCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQyNCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDM7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRVaW50MzIoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDMyKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0IHJlbWFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMubGVuZ3RoIC0gdGhpcy5wb3NpdGlvbjtcbiAgICB9LFxuICAgIHNldFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuICgpID0+ICh0aGlzLnBvc2l0aW9uID0gb2xkUG9zaXRpb24pO1xuICAgIH0sXG4gICAgX3RvdWNoKCkge1xuICAgICAgICBpZiAodGhpcy5yZWN1cnNpdmVSZWFkTGltaXQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmdldFJlYWRDb3VudCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uUmVhZENvdW50LnNldCh0aGlzLnBvc2l0aW9uLCBjb3VudCArIDEpO1xuICAgICAgICBpZiAoY291bnQgPiAwKVxuICAgICAgICAgICAgdGhpcy5yZWN1cnNpdmVSZWFkQ291bnQrKztcbiAgICB9LFxufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoYnl0ZXMsIHsgcmVjdXJzaXZlUmVhZExpbWl0ID0gOF8xOTIgfSA9IHt9KSB7XG4gICAgY29uc3QgY3Vyc29yID0gT2JqZWN0LmNyZWF0ZShzdGF0aWNDdXJzb3IpO1xuICAgIGN1cnNvci5ieXRlcyA9IGJ5dGVzO1xuICAgIGN1cnNvci5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgIGN1cnNvci5wb3NpdGlvblJlYWRDb3VudCA9IG5ldyBNYXAoKTtcbiAgICBjdXJzb3IucmVjdXJzaXZlUmVhZExpbWl0ID0gcmVjdXJzaXZlUmVhZExpbWl0O1xuICAgIHJldHVybiBjdXJzb3I7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgTmVnYXRpdmVPZmZzZXRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgb2Zmc2V0IH0pIHtcbiAgICAgICAgc3VwZXIoYE9mZnNldCBcXGAke29mZnNldH1cXGAgY2Fubm90IGJlIG5lZ2F0aXZlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQ3Vyc29yLk5lZ2F0aXZlT2Zmc2V0RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBQb3NpdGlvbk91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGxlbmd0aCwgcG9zaXRpb24gfSkge1xuICAgICAgICBzdXBlcihgUG9zaXRpb24gXFxgJHtwb3NpdGlvbn1cXGAgaXMgb3V0IG9mIGJvdW5kcyAoXFxgMCA8IHBvc2l0aW9uIDwgJHtsZW5ndGh9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0N1cnNvci5Qb3NpdGlvbk91dE9mQm91bmRzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBjb3VudCwgbGltaXQgfSkge1xuICAgICAgICBzdXBlcihgUmVjdXJzaXZlIHJlYWQgbGltaXQgb2YgXFxgJHtsaW1pdH1cXGAgZXhjZWVkZWQgKHJlY3Vyc2l2ZSByZWFkIGNvdW50OiBcXGAke2NvdW50fVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdDdXJzb3IuUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3Vyc29yLmpzLm1hcCJdLCJuYW1lcyI6WyJFcnJvcnMiLCJzdGF0aWNDdXJzb3IiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJkYXRhVmlldyIsIkRhdGFWaWV3IiwiQXJyYXlCdWZmZXIiLCJwb3NpdGlvbiIsInBvc2l0aW9uUmVhZENvdW50IiwiTWFwIiwicmVjdXJzaXZlUmVhZENvdW50IiwicmVjdXJzaXZlUmVhZExpbWl0IiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJhc3NlcnRSZWFkTGltaXQiLCJSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yIiwiY291bnQiLCJsaW1pdCIsImFzc2VydFBvc2l0aW9uIiwibGVuZ3RoIiwiUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yIiwiZGVjcmVtZW50UG9zaXRpb24iLCJvZmZzZXQiLCJOZWdhdGl2ZU9mZnNldEVycm9yIiwiZ2V0UmVhZENvdW50IiwiZ2V0IiwiaW5jcmVtZW50UG9zaXRpb24iLCJpbnNwZWN0Qnl0ZSIsInBvc2l0aW9uXyIsImluc3BlY3RCeXRlcyIsInN1YmFycmF5IiwiaW5zcGVjdFVpbnQ4IiwiaW5zcGVjdFVpbnQxNiIsImdldFVpbnQxNiIsImluc3BlY3RVaW50MjQiLCJnZXRVaW50OCIsImluc3BlY3RVaW50MzIiLCJnZXRVaW50MzIiLCJwdXNoQnl0ZSIsImJ5dGUiLCJwdXNoQnl0ZXMiLCJzZXQiLCJwdXNoVWludDgiLCJ2YWx1ZSIsInB1c2hVaW50MTYiLCJzZXRVaW50MTYiLCJwdXNoVWludDI0Iiwic2V0VWludDgiLCJwdXNoVWludDMyIiwic2V0VWludDMyIiwicmVhZEJ5dGUiLCJfdG91Y2giLCJyZWFkQnl0ZXMiLCJzaXplIiwicmVhZFVpbnQ4IiwicmVhZFVpbnQxNiIsInJlYWRVaW50MjQiLCJyZWFkVWludDMyIiwicmVtYWluaW5nIiwic2V0UG9zaXRpb24iLCJvbGRQb3NpdGlvbiIsImNyZWF0ZSIsImN1cnNvciIsIk9iamVjdCIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/cursor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/entropy.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/entropy.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extraEntropy: () => (/* binding */ extraEntropy),\n/* harmony export */   setExtraEntropy: () => (/* binding */ setExtraEntropy)\n/* harmony export */ });\nlet extraEntropy = false;\n/** @internal */ function setExtraEntropy(entropy) {\n    extraEntropy = entropy;\n} //# sourceMappingURL=entropy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2VudHJvcHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxJQUFJQSxlQUFlLE1BQU07QUFDaEMsY0FBYyxHQUNQLFNBQVNDLGdCQUFnQkMsT0FBTztJQUNuQ0YsZUFBZUU7QUFDbkIsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmM0MzM3LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lbnRyb3B5LmpzPzU0YzkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGxldCBleHRyYUVudHJvcHkgPSBmYWxzZTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFeHRyYUVudHJvcHkoZW50cm9weSkge1xuICAgIGV4dHJhRW50cm9weSA9IGVudHJvcHk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnRyb3B5LmpzLm1hcCJdLCJuYW1lcyI6WyJleHRyYUVudHJvcHkiLCJzZXRFeHRyYUVudHJvcHkiLCJlbnRyb3B5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/entropy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl),\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   prettyPrint: () => (/* binding */ prettyPrint)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version.js */ \"(ssr)/./node_modules/ox/_esm/core/version.js\");\n\n/** @internal */ function getUrl(url) {\n    return url;\n}\n/** @internal */ function getVersion() {\n    return _version_js__WEBPACK_IMPORTED_MODULE_0__.version;\n}\n/** @internal */ function prettyPrint(args) {\n    if (!args) return \"\";\n    const entries = Object.entries(args).map(([key, value])=>{\n        if (value === undefined || value === false) return null;\n        return [\n            key,\n            value\n        ];\n    }).filter(Boolean);\n    const maxLength = entries.reduce((acc, [key])=>Math.max(acc, key.length), 0);\n    return entries.map(([key, value])=>`  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join(\"\\n\");\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdDO0FBQ3hDLGNBQWMsR0FDUCxTQUFTQyxPQUFPQyxHQUFHO0lBQ3RCLE9BQU9BO0FBQ1g7QUFDQSxjQUFjLEdBQ1AsU0FBU0M7SUFDWixPQUFPSCxnREFBT0E7QUFDbEI7QUFDQSxjQUFjLEdBQ1AsU0FBU0ksWUFBWUMsSUFBSTtJQUM1QixJQUFJLENBQUNBLE1BQ0QsT0FBTztJQUNYLE1BQU1DLFVBQVVDLE9BQU9ELE9BQU8sQ0FBQ0QsTUFDMUJHLEdBQUcsQ0FBQyxDQUFDLENBQUNDLEtBQUtDLE1BQU07UUFDbEIsSUFBSUEsVUFBVUMsYUFBYUQsVUFBVSxPQUNqQyxPQUFPO1FBQ1gsT0FBTztZQUFDRDtZQUFLQztTQUFNO0lBQ3ZCLEdBQ0tFLE1BQU0sQ0FBQ0M7SUFDWixNQUFNQyxZQUFZUixRQUFRUyxNQUFNLENBQUMsQ0FBQ0MsS0FBSyxDQUFDUCxJQUFJLEdBQUtRLEtBQUtDLEdBQUcsQ0FBQ0YsS0FBS1AsSUFBSVUsTUFBTSxHQUFHO0lBQzVFLE9BQU9iLFFBQ0ZFLEdBQUcsQ0FBQyxDQUFDLENBQUNDLEtBQUtDLE1BQU0sR0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUVELElBQUksQ0FBQyxDQUFDLENBQUNXLE1BQU0sQ0FBQ04sWUFBWSxHQUFHLEVBQUUsRUFBRUosTUFBTSxDQUFDLEVBQ3RFVyxJQUFJLENBQUM7QUFDZCxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYzQzMzctZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vycm9ycy5qcz9hZTZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi92ZXJzaW9uLmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVcmwodXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJzaW9uKCkge1xuICAgIHJldHVybiB2ZXJzaW9uO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXR0eVByaW50KGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoYXJncylcbiAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gZW50cmllcy5yZWR1Y2UoKGFjYywgW2tleV0pID0+IE1hdGgubWF4KGFjYywga2V5Lmxlbmd0aCksIDApO1xuICAgIHJldHVybiBlbnRyaWVzXG4gICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCAgJHtgJHtrZXl9OmAucGFkRW5kKG1heExlbmd0aCArIDEpfSAgJHt2YWx1ZX1gKVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJnZXRVcmwiLCJ1cmwiLCJnZXRWZXJzaW9uIiwicHJldHR5UHJpbnQiLCJhcmdzIiwiZW50cmllcyIsIk9iamVjdCIsIm1hcCIsImtleSIsInZhbHVlIiwidW5kZWZpbmVkIiwiZmlsdGVyIiwiQm9vbGVhbiIsIm1heExlbmd0aCIsInJlZHVjZSIsImFjYyIsIk1hdGgiLCJtYXgiLCJsZW5ndGgiLCJwYWRFbmQiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/hex.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/hex.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n/** @internal */ function assertSize(hex, size_) {\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex) > size_) throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n        givenSize: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex),\n        maxSize: size_\n    });\n}\n/** @internal */ function assertStartOffset(value, start) {\n    if (typeof start === \"number\" && start > 0 && start > _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1) throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n        offset: start,\n        position: \"start\",\n        size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value)\n    });\n}\n/** @internal */ function assertEndOffset(value, start, end) {\n    if (typeof start === \"number\" && typeof end === \"number\" && _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: \"end\",\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value)\n        });\n    }\n}\n/** @internal */ function pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0) return hex_;\n    const hex = hex_.replace(\"0x\", \"\");\n    if (hex.length > size * 2) throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n        size: Math.ceil(hex.length / 2),\n        targetSize: size,\n        type: \"Hex\"\n    });\n    return `0x${hex[dir === \"right\" ? \"padEnd\" : \"padStart\"](size * 2, \"0\")}`;\n}\n/** @internal */ function trim(value, options = {}) {\n    const { dir = \"left\" } = options;\n    let data = value.replace(\"0x\", \"\");\n    let sliceLength = 0;\n    for(let i = 0; i < data.length - 1; i++){\n        if (data[dir === \"left\" ? i : data.length - i - 1].toString() === \"0\") sliceLength++;\n        else break;\n    }\n    data = dir === \"left\" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\n    if (data === \"0\") return \"0x\";\n    if (dir === \"right\" && data.length % 2 === 1) return `0x${data}0`;\n    return `0x${data}`;\n} //# sourceMappingURL=hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUM7QUFDakMsY0FBYyxHQUNQLFNBQVNDLFdBQVdDLEdBQUcsRUFBRUMsS0FBSztJQUNqQyxJQUFJSCx5Q0FBUSxDQUFDRSxPQUFPQyxPQUNoQixNQUFNLElBQUlILHNEQUFxQixDQUFDO1FBQzVCTSxXQUFXTix5Q0FBUSxDQUFDRTtRQUNwQkssU0FBU0o7SUFDYjtBQUNSO0FBQ0EsY0FBYyxHQUNQLFNBQVNLLGtCQUFrQkMsS0FBSyxFQUFFQyxLQUFLO0lBQzFDLElBQUksT0FBT0EsVUFBVSxZQUFZQSxRQUFRLEtBQUtBLFFBQVFWLHlDQUFRLENBQUNTLFNBQVMsR0FDcEUsTUFBTSxJQUFJVCxnRUFBK0IsQ0FBQztRQUN0Q1ksUUFBUUY7UUFDUkcsVUFBVTtRQUNWVCxNQUFNSix5Q0FBUSxDQUFDUztJQUNuQjtBQUNSO0FBQ0EsY0FBYyxHQUNQLFNBQVNLLGdCQUFnQkwsS0FBSyxFQUFFQyxLQUFLLEVBQUVLLEdBQUc7SUFDN0MsSUFBSSxPQUFPTCxVQUFVLFlBQ2pCLE9BQU9LLFFBQVEsWUFDZmYseUNBQVEsQ0FBQ1MsV0FBV00sTUFBTUwsT0FBTztRQUNqQyxNQUFNLElBQUlWLGdFQUErQixDQUFDO1lBQ3RDWSxRQUFRRztZQUNSRixVQUFVO1lBQ1ZULE1BQU1KLHlDQUFRLENBQUNTO1FBQ25CO0lBQ0o7QUFDSjtBQUNBLGNBQWMsR0FDUCxTQUFTTyxJQUFJQyxJQUFJLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ2xDLE1BQU0sRUFBRUMsR0FBRyxFQUFFZixPQUFPLEVBQUUsRUFBRSxHQUFHYztJQUMzQixJQUFJZCxTQUFTLEdBQ1QsT0FBT2E7SUFDWCxNQUFNZixNQUFNZSxLQUFLRyxPQUFPLENBQUMsTUFBTTtJQUMvQixJQUFJbEIsSUFBSW1CLE1BQU0sR0FBR2pCLE9BQU8sR0FDcEIsTUFBTSxJQUFJSixnRUFBK0IsQ0FBQztRQUN0Q0ksTUFBTW1CLEtBQUtDLElBQUksQ0FBQ3RCLElBQUltQixNQUFNLEdBQUc7UUFDN0JJLFlBQVlyQjtRQUNac0IsTUFBTTtJQUNWO0lBQ0osT0FBTyxDQUFDLEVBQUUsRUFBRXhCLEdBQUcsQ0FBQ2lCLFFBQVEsVUFBVSxXQUFXLFdBQVcsQ0FBQ2YsT0FBTyxHQUFHLEtBQUssQ0FBQztBQUM3RTtBQUNBLGNBQWMsR0FDUCxTQUFTdUIsS0FBS2xCLEtBQUssRUFBRVMsVUFBVSxDQUFDLENBQUM7SUFDcEMsTUFBTSxFQUFFQyxNQUFNLE1BQU0sRUFBRSxHQUFHRDtJQUN6QixJQUFJVSxPQUFPbkIsTUFBTVcsT0FBTyxDQUFDLE1BQU07SUFDL0IsSUFBSVMsY0FBYztJQUNsQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsS0FBS1AsTUFBTSxHQUFHLEdBQUdTLElBQUs7UUFDdEMsSUFBSUYsSUFBSSxDQUFDVCxRQUFRLFNBQVNXLElBQUlGLEtBQUtQLE1BQU0sR0FBR1MsSUFBSSxFQUFFLENBQUNDLFFBQVEsT0FBTyxLQUM5REY7YUFFQTtJQUNSO0lBQ0FELE9BQ0lULFFBQVEsU0FDRlMsS0FBS0ksS0FBSyxDQUFDSCxlQUNYRCxLQUFLSSxLQUFLLENBQUMsR0FBR0osS0FBS1AsTUFBTSxHQUFHUTtJQUN0QyxJQUFJRCxTQUFTLEtBQ1QsT0FBTztJQUNYLElBQUlULFFBQVEsV0FBV1MsS0FBS1AsTUFBTSxHQUFHLE1BQU0sR0FDdkMsT0FBTyxDQUFDLEVBQUUsRUFBRU8sS0FBSyxDQUFDLENBQUM7SUFDdkIsT0FBTyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDO0FBQ3RCLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjNDMzNy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvaGV4LmpzPzlmYzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL0hleC5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U2l6ZShoZXgsIHNpemVfKSB7XG4gICAgaWYgKEhleC5zaXplKGhleCkgPiBzaXplXylcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEhleC5zaXplKGhleCksXG4gICAgICAgICAgICBtYXhTaXplOiBzaXplXyxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiYgc3RhcnQgPiAwICYmIHN0YXJ0ID4gSGV4LnNpemUodmFsdWUpIC0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnc3RhcnQnLFxuICAgICAgICAgICAgc2l6ZTogSGV4LnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFbmRPZmZzZXQodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0eXBlb2YgZW5kID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBIZXguc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogZW5kLFxuICAgICAgICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgICAgICAgc2l6ZTogSGV4LnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcGFkKGhleF8sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyLCBzaXplID0gMzIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHNpemUgPT09IDApXG4gICAgICAgIHJldHVybiBoZXhfO1xuICAgIGNvbnN0IGhleCA9IGhleF8ucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgaWYgKGhleC5sZW5ndGggPiBzaXplICogMilcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3Ioe1xuICAgICAgICAgICAgc2l6ZTogTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnSGV4JyxcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIGAweCR7aGV4W2RpciA9PT0gJ3JpZ2h0JyA/ICdwYWRFbmQnIDogJ3BhZFN0YXJ0J10oc2l6ZSAqIDIsICcwJyl9YDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRpciA9ICdsZWZ0JyB9ID0gb3B0aW9ucztcbiAgICBsZXQgZGF0YSA9IHZhbHVlLnJlcGxhY2UoJzB4JywgJycpO1xuICAgIGxldCBzbGljZUxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtkaXIgPT09ICdsZWZ0JyA/IGkgOiBkYXRhLmxlbmd0aCAtIGkgLSAxXS50b1N0cmluZygpID09PSAnMCcpXG4gICAgICAgICAgICBzbGljZUxlbmd0aCsrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZGF0YSA9XG4gICAgICAgIGRpciA9PT0gJ2xlZnQnXG4gICAgICAgICAgICA/IGRhdGEuc2xpY2Uoc2xpY2VMZW5ndGgpXG4gICAgICAgICAgICA6IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSBzbGljZUxlbmd0aCk7XG4gICAgaWYgKGRhdGEgPT09ICcwJylcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgaWYgKGRpciA9PT0gJ3JpZ2h0JyAmJiBkYXRhLmxlbmd0aCAlIDIgPT09IDEpXG4gICAgICAgIHJldHVybiBgMHgke2RhdGF9MGA7XG4gICAgcmV0dXJuIGAweCR7ZGF0YX1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJIZXgiLCJhc3NlcnRTaXplIiwiaGV4Iiwic2l6ZV8iLCJzaXplIiwiU2l6ZU92ZXJmbG93RXJyb3IiLCJnaXZlblNpemUiLCJtYXhTaXplIiwiYXNzZXJ0U3RhcnRPZmZzZXQiLCJ2YWx1ZSIsInN0YXJ0IiwiU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yIiwib2Zmc2V0IiwicG9zaXRpb24iLCJhc3NlcnRFbmRPZmZzZXQiLCJlbmQiLCJwYWQiLCJoZXhfIiwib3B0aW9ucyIsImRpciIsInJlcGxhY2UiLCJsZW5ndGgiLCJTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IiLCJNYXRoIiwiY2VpbCIsInRhcmdldFNpemUiLCJ0eXBlIiwidHJpbSIsImRhdGEiLCJzbGljZUxlbmd0aCIsImkiLCJ0b1N0cmluZyIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/lru.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/lru.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LruMap: () => (/* binding */ LruMap)\n/* harmony export */ });\n/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */ class LruMap extends Map {\n    constructor(size){\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey) this.delete(firstKey);\n        }\n        return this;\n    }\n} //# sourceMappingURL=lru.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2xydS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0NBS0MsR0FDTSxNQUFNQSxlQUFlQztJQUN4QkMsWUFBWUMsSUFBSSxDQUFFO1FBQ2QsS0FBSztRQUNMQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVc7WUFDbkNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBLElBQUksQ0FBQ0MsT0FBTyxHQUFHUDtJQUNuQjtJQUNBUSxJQUFJQyxHQUFHLEVBQUU7UUFDTCxNQUFNSCxRQUFRLEtBQUssQ0FBQ0UsSUFBSUM7UUFDeEIsSUFBSSxLQUFLLENBQUNDLElBQUlELFFBQVFILFVBQVVLLFdBQVc7WUFDdkMsSUFBSSxDQUFDQyxNQUFNLENBQUNIO1lBQ1osS0FBSyxDQUFDSSxJQUFJSixLQUFLSDtRQUNuQjtRQUNBLE9BQU9BO0lBQ1g7SUFDQU8sSUFBSUosR0FBRyxFQUFFSCxLQUFLLEVBQUU7UUFDWixLQUFLLENBQUNPLElBQUlKLEtBQUtIO1FBQ2YsSUFBSSxJQUFJLENBQUNDLE9BQU8sSUFBSSxJQUFJLENBQUNQLElBQUksR0FBRyxJQUFJLENBQUNPLE9BQU8sRUFBRTtZQUMxQyxNQUFNTyxXQUFXLElBQUksQ0FBQ0MsSUFBSSxHQUFHQyxJQUFJLEdBQUdWLEtBQUs7WUFDekMsSUFBSVEsVUFDQSxJQUFJLENBQUNGLE1BQU0sQ0FBQ0U7UUFDcEI7UUFDQSxPQUFPLElBQUk7SUFDZjtBQUNKLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjNDMzNy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvbHJ1LmpzPzVkMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBNYXAgd2l0aCBhIExSVSAoTGVhc3QgcmVjZW50bHkgdXNlZCkgcG9saWN5LlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWNoZV9yZXBsYWNlbWVudF9wb2xpY2llcyNMUlVcbiAqL1xuZXhwb3J0IGNsYXNzIExydU1hcCBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdXBlci5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHN1cGVyLmhhcyhrZXkpICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm1heFNpemUgJiYgdGhpcy5zaXplID4gdGhpcy5tYXhTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEtleSA9IHRoaXMua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChmaXJzdEtleSlcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZShmaXJzdEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bHJ1LmpzLm1hcCJdLCJuYW1lcyI6WyJMcnVNYXAiLCJNYXAiLCJjb25zdHJ1Y3RvciIsInNpemUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwibWF4U2l6ZSIsImdldCIsImtleSIsImhhcyIsInVuZGVmaW5lZCIsImRlbGV0ZSIsInNldCIsImZpcnN0S2V5Iiwia2V5cyIsIm5leHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/lru.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/version.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/version.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/** @internal */ const version = \"0.1.1\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGNBQWMsR0FDUCxNQUFNQSxVQUFVLFFBQVEsQ0FDL0IsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjNDMzNy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvdmVyc2lvbi5qcz84MmNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzAuMS4xJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/erc6492/SignatureErc6492.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/erc6492/SignatureErc6492.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidWrappedSignatureError: () => (/* binding */ InvalidWrappedSignatureError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   magicBytes: () => (/* binding */ magicBytes),\n/* harmony export */   universalSignatureValidatorAbi: () => (/* binding */ universalSignatureValidatorAbi),\n/* harmony export */   universalSignatureValidatorBytecode: () => (/* binding */ universalSignatureValidatorBytecode),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n/**\n * Magic bytes used to identify ERC-6492 wrapped signatures.\n */ const magicBytes = \"0x6492649264926492649264926492649264926492649264926492649264926492\";\n/**\n * Deployless ERC-6492 signature verification bytecode.\n */ const universalSignatureValidatorBytecode = \"0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572\";\n/**\n * ABI for the ERC-6492 universal deployless signature validator contract.\n *\n * Constructor return value is `0x1` (valid) or `0x0` (invalid).\n */ const universalSignatureValidatorAbi = [\n    {\n        inputs: [\n            {\n                name: \"_signer\",\n                type: \"address\"\n            },\n            {\n                name: \"_hash\",\n                type: \"bytes32\"\n            },\n            {\n                name: \"_signature\",\n                type: \"bytes\"\n            }\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"constructor\"\n    },\n    {\n        inputs: [\n            {\n                name: \"_signer\",\n                type: \"address\"\n            },\n            {\n                name: \"_hash\",\n                type: \"bytes32\"\n            },\n            {\n                name: \"_signature\",\n                type: \"bytes\"\n            }\n        ],\n        outputs: [\n            {\n                type: \"bool\"\n            }\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n        name: \"isValidSig\"\n    }\n];\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * SignatureErc6492.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-6492 wrapped signature.\n * ```\n *\n * @param wrapped - The wrapped signature to assert.\n */ function assert(wrapped) {\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(wrapped, -32) !== magicBytes) throw new InvalidWrappedSignatureError(wrapped);\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc6492.from('0x...') // [!code focus]\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc6492.from({ // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x...', // [!code focus]\n * })\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', }\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */ function from(wrapped) {\n    if (typeof wrapped === \"string\") return unwrap(wrapped);\n    return wrapped;\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const { data, signature, to } = SignatureErc6492.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */ function unwrap(wrapped) {\n    assert(wrapped);\n    const [to, data, signature] = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.decode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.from(\"address, bytes, bytes\"), wrapped);\n    return {\n        data,\n        signature,\n        to\n    };\n}\n/**\n * Serializes an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc6492.wrap({ // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n *   to: '0x00000000219ab540356cBB839Cbe05303d7705Fa', // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Wrapped signature to serialize.\n * @returns Serialized wrapped signature.\n */ function wrap(value) {\n    const { data, signature, to } = value;\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.encode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.from(\"address, bytes, bytes\"), [\n        to,\n        data,\n        signature\n    ]), magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const valid = SignatureErc6492.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param wrapped - The wrapped signature to validate.\n * @returns `true` if the wrapped signature is valid, `false` otherwise.\n */ function validate(wrapped) {\n    try {\n        assert(wrapped);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/** Thrown when the ERC-6492 wrapped signature is invalid. */ class InvalidWrappedSignatureError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor(wrapped){\n        super(`Value \\`${wrapped}\\` is an invalid ERC-6492 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"SignatureErc6492.InvalidWrappedSignatureError\"\n        });\n    }\n} //# sourceMappingURL=SignatureErc6492.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM2NDkyL1NpZ25hdHVyZUVyYzY0OTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQ2Q7QUFDTjtBQUN0Qzs7Q0FFQyxHQUNNLE1BQU1HLGFBQWEscUVBQXFFO0FBQy9GOztDQUVDLEdBQ00sTUFBTUMsc0NBQXNDLDZ5R0FBNnlHO0FBQ2gyRzs7OztDQUlDLEdBQ00sTUFBTUMsaUNBQWlDO0lBQzFDO1FBQ0lDLFFBQVE7WUFDSjtnQkFDSUMsTUFBTTtnQkFDTkMsTUFBTTtZQUNWO1lBQ0E7Z0JBQ0lELE1BQU07Z0JBQ05DLE1BQU07WUFDVjtZQUNBO2dCQUNJRCxNQUFNO2dCQUNOQyxNQUFNO1lBQ1Y7U0FDSDtRQUNEQyxpQkFBaUI7UUFDakJELE1BQU07SUFDVjtJQUNBO1FBQ0lGLFFBQVE7WUFDSjtnQkFDSUMsTUFBTTtnQkFDTkMsTUFBTTtZQUNWO1lBQ0E7Z0JBQ0lELE1BQU07Z0JBQ05DLE1BQU07WUFDVjtZQUNBO2dCQUNJRCxNQUFNO2dCQUNOQyxNQUFNO1lBQ1Y7U0FDSDtRQUNERSxTQUFTO1lBQ0w7Z0JBQ0lGLE1BQU07WUFDVjtTQUNIO1FBQ0RDLGlCQUFpQjtRQUNqQkQsTUFBTTtRQUNORCxNQUFNO0lBQ1Y7Q0FDSCxDQUFDO0FBQ0Y7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU0ksT0FBT0MsT0FBTztJQUMxQixJQUFJViwrQ0FBUyxDQUFDVSxTQUFTLENBQUMsUUFBUVQsWUFDNUIsTUFBTSxJQUFJVyw2QkFBNkJGO0FBQy9DO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkJDLEdBQ00sU0FBU0csS0FBS0gsT0FBTztJQUN4QixJQUFJLE9BQU9BLFlBQVksVUFDbkIsT0FBT0ksT0FBT0o7SUFDbEIsT0FBT0E7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNJLE9BQU9KLE9BQU87SUFDMUJELE9BQU9DO0lBQ1AsTUFBTSxDQUFDSyxJQUFJQyxNQUFNQyxVQUFVLEdBQUduQiwwREFBb0IsQ0FBQ0Esd0RBQWtCLENBQUMsMEJBQTBCWTtJQUNoRyxPQUFPO1FBQUVNO1FBQU1DO1FBQVdGO0lBQUc7QUFDakM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNNLFNBQVNJLEtBQUtDLEtBQUs7SUFDdEIsTUFBTSxFQUFFSixJQUFJLEVBQUVDLFNBQVMsRUFBRUYsRUFBRSxFQUFFLEdBQUdLO0lBQ2hDLE9BQU9wQixnREFBVSxDQUFDRiwwREFBb0IsQ0FBQ0Esd0RBQWtCLENBQUMsMEJBQTBCO1FBQ2hGaUI7UUFDQUM7UUFDQUM7S0FDSCxHQUFHaEI7QUFDUjtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTc0IsU0FBU2IsT0FBTztJQUM1QixJQUFJO1FBQ0FELE9BQU9DO1FBQ1AsT0FBTztJQUNYLEVBQ0EsT0FBTTtRQUNGLE9BQU87SUFDWDtBQUNKO0FBQ0EsMkRBQTJELEdBQ3BELE1BQU1FLHFDQUFxQ2Isc0RBQWdCO0lBQzlEMEIsWUFBWWYsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRUEsUUFBUSw0Q0FBNEMsQ0FBQztRQUN0RWdCLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVlYsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYzQzMzctZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM2NDkyL1NpZ25hdHVyZUVyYzY0OTIuanM/ZWM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4uL2NvcmUvQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vY29yZS9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL2NvcmUvSGV4LmpzJztcbi8qKlxuICogTWFnaWMgYnl0ZXMgdXNlZCB0byBpZGVudGlmeSBFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYWdpY0J5dGVzID0gJzB4NjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5Mic7XG4vKipcbiAqIERlcGxveWxlc3MgRVJDLTY0OTIgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBieXRlY29kZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckJ5dGVjb2RlID0gJzB4NjA4MDYwNDA1MjM0ODAxNTYxMDAxMDU3NjAwMDgwZmQ1YjUwNjA0MDUxNjEwNjk0MzgwMzgwNjEwNjk0ODMzOTgxMDE2MDQwODE5MDUyNjEwMDJmOTE2MTA1MWU1NjViNjAwMDYxMDAzYzg0ODQ4NDYxMDA0ODU2NWI5MDUwODA2MDAwNTI2MDAxNjAxZmYzNWI2MDAwN2Y2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjEwMDc0ODM2MTA0MGM1NjViMDM2MTAxZTc1NzYwMDA2MDYwODA4NDgwNjAyMDAxOTA1MTgxMDE5MDYxMDA5MjkxOTA2MTA1Nzc1NjViNjA0MDUxOTI5NTUwOTA5MzUwOTE1MDYwMDA5MDYwMDE2MDAxNjBhMDFiMDM4NTE2OTA2MTAwYjY5MDg1OTA2MTA1ZGQ1NjViNjAwMDYwNDA1MTgwODMwMzgxNjAwMDg2NWFmMTkxNTA1MDNkODA2MDAwODExNDYxMDBmMzU3NjA0MDUxOTE1MDYwMWYxOTYwM2YzZDAxMTY4MjAxNjA0MDUyM2Q4MjUyM2Q2MDAwNjAyMDg0MDEzZTYxMDBmODU2NWI2MDYwOTE1MDViNTA1MDkwNTA4NzYwMDE2MDAxNjBhMDFiMDMxNjNiNjAwMDAzNjEwMTYwNTc4MDYxMDE2MDU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDFlNjAyNDgyMDE1MjdmNTM2OTY3NmU2MTc0NzU3MjY1NTY2MTZjNjk2NDYxNzQ2ZjcyM2EyMDY0NjU3MDZjNmY3OTZkNjU2ZTc0MDAwMDYwNDQ4MjAxNTI2MDY0MDE1YjYwNDA1MTgwOTEwMzkwZmQ1YjYwNDA1MTYzMGIxMzVkM2Y2MGUxMWI4MDgyNTI5MDYwMDE2MDAxNjBhMDFiMDM4YTE2OTA2MzE2MjZiYTdlOTA2MTAxOTA5MDhiOTA4NzkwNjAwNDAxNjEwNWY5NTY1YjYwMjA2MDQwNTE4MDgzMDM4MTg2NWFmYTE1ODAxNTYxMDFhZDU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA1MDYwNDA1MTNkNjAxZjE5NjAxZjgyMDExNjgyMDE4MDYwNDA1MjUwODEwMTkwNjEwMWQxOTE5MDYxMDYzMzU2NWI2MDAxNjAwMTYwZTAxYjAzMTkxNjE0OTQ1MDUwNTA1MDUwNjEwNDA1NTY1YjYwMDE2MDAxNjBhMDFiMDM4NDE2M2IxNTYxMDI3YTU3NjA0MDUxNjMwYjEzNWQzZjYwZTExYjgwODI1MjkwNjAwMTYwMDE2MGEwMWIwMzg2MTY5MDYzMTYyNmJhN2U5MDYxMDIyNzkwODc5MDg3OTA2MDA0MDE2MTA1Zjk1NjViNjAyMDYwNDA1MTgwODMwMzgxODY1YWZhMTU4MDE1NjEwMjQ0NTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDUwNjA0MDUxM2Q2MDFmMTk2MDFmODIwMTE2ODIwMTgwNjA0MDUyNTA4MTAxOTA2MTAyNjg5MTkwNjEwNjMzNTY1YjYwMDE2MDAxNjBlMDFiMDMxOTE2MTQ5MDUwNjEwNDA1NTY1YjgxNTE2MDQxMTQ2MTAyZGY1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMjA2MDA0ODIwMTUyNjAzYTYwMjQ4MjAxNTI2MDAwODA1MTYwMjA2MTA2NzQ4MzM5ODE1MTkxNTI2MDQ0ODIwMTUyN2YzYTIwNjk2ZTc2NjE2YzY5NjQyMDczNjk2NzZlNjE3NDc1NzI2NTIwNmM2NTZlNjc3NDY4MDAwMDAwMDAwMDAwNjA2NDgyMDE1MjYwODQwMTYxMDE1NzU2NWI2MTAyZTc2MTA0MjU1NjViNTA2MDIwODIwMTUxNjA0MDgwODQwMTUxODQ1MTg1OTM5MjYwMDA5MTg1OTE5MDgxMTA2MTAzMGM1NzYxMDMwYzYxMDY1ZDU2NWIwMTYwMjAwMTUxNjBmODFjOTA1MDYwMWI4MTE0ODAxNTkwNjEwMzJiNTc1MDgwNjBmZjE2NjAxYzE0MTU1YjE1NjEwMzhjNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwM2I2MDI0ODIwMTUyNjAwMDgwNTE2MDIwNjEwNjc0ODMzOTgxNTE5MTUyNjA0NDgyMDE1MjdmM2EyMDY5NmU3NjYxNmM2OTY0MjA3MzY5Njc2ZTYxNzQ3NTcyNjUyMDc2MjA3NjYxNmM3NTY1MDAwMDAwMDAwMDYwNjQ4MjAxNTI2MDg0MDE2MTAxNTc1NjViNjA0MDgwNTE2MDAwODE1MjYwMjA4MTAxODA4MzUyODk5MDUyNjBmZjgzMTY5MTgxMDE5MTkwOTE1MjYwNjA4MTAxODQ5MDUyNjA4MDgxMDE4MzkwNTI2MDAxNjAwMTYwYTAxYjAzODkxNjkwNjAwMTkwNjBhMDAxNjAyMDYwNDA1MTYwMjA4MTAzOTA4MDg0MDM5MDg1NWFmYTE1ODAxNTYxMDNlYTU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA2MDIwNjA0MDUxMDM1MTYwMDE2MDAxNjBhMDFiMDMxNjE0OTQ1MDUwNTA1MDUwNWI5MzkyNTA1MDUwNTY1YjYwMDA2MDIwODI1MTEwMTU2MTA0MWQ1NzYwMDA4MGZkNWI1MDgwNTEwMTUxOTA1NjViNjA0MDUxODA2MDYwMDE2MDQwNTI4MDYwMDM5MDYwMjA4MjAyODAzNjgzMzc1MDkxOTI5MTUwNTA1NjViNjAwMTYwMDE2MGEwMWIwMzgxMTY4MTE0NjEwNDU4NTc2MDAwODBmZDViNTA1NjViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwNDE2MDA0NTI2MDI0NjAwMGZkNWI2MDAwNWI4MzgxMTAxNTYxMDQ4YzU3ODE4MTAxNTE4MzgyMDE1MjYwMjAwMTYxMDQ3NDU2NWI1MDUwNjAwMDkxMDE1MjU2NWI2MDAwODI2MDFmODMwMTEyNjEwNGE2NTc2MDAwODBmZDViODE1MTYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTA0YmY1NzYxMDRiZjYxMDQ1YjU2NWI2MDQwNTE2MDFmODIwMTYwMWYxOTkwODExNjYwM2YwMTE2ODEwMTYwMDE2MDAxNjA0MDFiMDM4MTExODI4MjEwMTcxNTYxMDRlZDU3NjEwNGVkNjEwNDViNTY1YjYwNDA1MjgxODE1MjgzODIwMTYwMjAwMTg1MTAxNTYxMDUwNTU3NjAwMDgwZmQ1YjYxMDUxNjgyNjAyMDgzMDE2MDIwODcwMTYxMDQ3MTU2NWI5NDkzNTA1MDUwNTA1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjEwNTMzNTc2MDAwODBmZDViODM1MTYxMDUzZTgxNjEwNDQzNTY1YjYwMjA4NTAxNTE2MDQwODYwMTUxOTE5NDUwOTI1MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTA1NjE1NzYwMDA4MGZkNWI2MTA1NmQ4NjgyODcwMTYxMDQ5NTU2NWI5MTUwNTA5MjUwOTI1MDkyNTY1YjYwMDA4MDYwMDA2MDYwODQ4NjAzMTIxNTYxMDU4YzU3NjAwMDgwZmQ1YjgzNTE2MTA1OTc4MTYxMDQ0MzU2NWI2MDIwODUwMTUxOTA5MzUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDViMzU3NjAwMDgwZmQ1YjYxMDViZjg2ODI4NzAxNjEwNDk1NTY1YjYwNDA4NjAxNTE5MDkzNTA5MDUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDU2MTU3NjAwMDgwZmQ1YjYwMDA4MjUxNjEwNWVmODE4NDYwMjA4NzAxNjEwNDcxNTY1YjkxOTA5MTAxOTI5MTUwNTA1NjViODI4MTUyNjA0MDYwMjA4MjAxNTI2MDAwODI1MTgwNjA0MDg0MDE1MjYxMDYxZTgxNjA2MDg1MDE2MDIwODcwMTYxMDQ3MTU2NWI2MDFmMDE2MDFmMTkxNjkxOTA5MTAxNjA2MDAxOTM5MjUwNTA1MDU2NWI2MDAwNjAyMDgyODQwMzEyMTU2MTA2NDU1NzYwMDA4MGZkNWI4MTUxNjAwMTYwMDE2MGUwMWIwMzE5ODExNjgxMTQ2MTA0MDU1NzYwMDA4MGZkNWI2MzRlNDg3YjcxNjBlMDFiNjAwMDUyNjAzMjYwMDQ1MjYwMjQ2MDAwZmRmZTUzNjk2NzZlNjE3NDc1NzI2NTU2NjE2YzY5NjQ2MTc0NmY3MjIzNzI2NTYzNmY3NjY1NzI1MzY5Njc2ZTY1NzInO1xuLyoqXG4gKiBBQkkgZm9yIHRoZSBFUkMtNjQ5MiB1bml2ZXJzYWwgZGVwbG95bGVzcyBzaWduYXR1cmUgdmFsaWRhdG9yIGNvbnRyYWN0LlxuICpcbiAqIENvbnN0cnVjdG9yIHJldHVybiB2YWx1ZSBpcyBgMHgxYCAodmFsaWQpIG9yIGAweDBgIChpbnZhbGlkKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckFiaSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfc2lnbmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfaGFzaCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzMzInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3NpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnY29uc3RydWN0b3InLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3NpZ25lcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX2hhc2gnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlczMyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ19zaWduYXR1cmUnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIG5hbWU6ICdpc1ZhbGlkU2lnJyxcbiAgICB9LFxuXTtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSB3cmFwcGVkIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzY0OTIgfSBmcm9tICdveC9lcmM2NDkyJ1xuICpcbiAqIFNpZ25hdHVyZUVyYzY0OTIuYXNzZXJ0KCcweGRlYWRiZWVmJylcbiAqIC8vIEBlcnJvcjogSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvcjogVmFsdWUgYDB4ZGVhZGJlZWZgIGlzIGFuIGludmFsaWQgRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmUuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFRoZSB3cmFwcGVkIHNpZ25hdHVyZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQod3JhcHBlZCkge1xuICAgIGlmIChIZXguc2xpY2Uod3JhcHBlZCwgLTMyKSAhPT0gbWFnaWNCeXRlcylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3Iod3JhcHBlZCk7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBbRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmVdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNjQ5MiNzcGVjaWZpY2F0aW9uKSBpbnRvIGl0cyBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM2NDkyIH0gZnJvbSAnb3gvZXJjNjQ5MicgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogJzB4Li4uJyxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogLy8gSW5zdGFudGlhdGUgZnJvbSBzZXJpYWxpemVkIGZvcm1hdC4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3Qgd3JhcHBlZCA9IFNpZ25hdHVyZUVyYzY0OTIuZnJvbSgnMHguLi4nKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7IGRhdGE6ICcweC4uLicsIHNpZ25hdHVyZTogeyAuLi4gfSwgdG86ICcweC4uLicsIH0gLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIEluc3RhbnRpYXRlIGZyb20gY29uc3RpdHVlbnQgcGFydHMuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IHdyYXBwZWQgPSBTaWduYXR1cmVFcmM2NDkyLmZyb20oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6ICcweC4uLicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHRvOiAnMHguLi4nLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KVxuICogLy8gQGxvZzogeyBkYXRhOiAnMHguLi4nLCBzaWduYXR1cmU6IHsgLi4uIH0sIHRvOiAnMHguLi4nLCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFdyYXBwZWQgc2lnbmF0dXJlIHRvIHBhcnNlLlxuICogQHJldHVybnMgV3JhcHBlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHdyYXBwZWQpIHtcbiAgICBpZiAodHlwZW9mIHdyYXBwZWQgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdW53cmFwKHdyYXBwZWQpO1xuICAgIHJldHVybiB3cmFwcGVkO1xufVxuLyoqXG4gKiBQYXJzZXMgYW4gW0VSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTY0OTIjc3BlY2lmaWNhdGlvbikgaW50byBpdHMgY29uc3RpdHVlbnQgcGFydHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM2NDkyIH0gZnJvbSAnb3gvZXJjNjQ5MidcbiAqXG4gKiBjb25zdCB7IGRhdGEsIHNpZ25hdHVyZSwgdG8gfSA9IFNpZ25hdHVyZUVyYzY0OTIudW53cmFwKCcweC4uLicpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFdyYXBwZWQgc2lnbmF0dXJlIHRvIHBhcnNlLlxuICogQHJldHVybnMgV3JhcHBlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXAod3JhcHBlZCkge1xuICAgIGFzc2VydCh3cmFwcGVkKTtcbiAgICBjb25zdCBbdG8sIGRhdGEsIHNpZ25hdHVyZV0gPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oJ2FkZHJlc3MsIGJ5dGVzLCBieXRlcycpLCB3cmFwcGVkKTtcbiAgICByZXR1cm4geyBkYXRhLCBzaWduYXR1cmUsIHRvIH07XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYW4gW0VSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTY0OTIjc3BlY2lmaWNhdGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjNjQ5MiB9IGZyb20gJ294L2VyYzY0OTInIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6ICcweC4uLicsXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHdyYXBwZWQgPSBTaWduYXR1cmVFcmM2NDkyLndyYXAoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmU6IFNpZ25hdHVyZS50b0hleChzaWduYXR1cmUpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhJywgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gV3JhcHBlZCBzaWduYXR1cmUgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgU2VyaWFsaXplZCB3cmFwcGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXAodmFsdWUpIHtcbiAgICBjb25zdCB7IGRhdGEsIHNpZ25hdHVyZSwgdG8gfSA9IHZhbHVlO1xuICAgIHJldHVybiBIZXguY29uY2F0KEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbSgnYWRkcmVzcywgYnl0ZXMsIGJ5dGVzJyksIFtcbiAgICAgICAgdG8sXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICBdKSwgbWFnaWNCeXRlcyk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHdyYXBwZWQgc2lnbmF0dXJlLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgd3JhcHBlZCBzaWduYXR1cmUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjNjQ5MiB9IGZyb20gJ294L2VyYzY0OTInXG4gKlxuICogY29uc3QgdmFsaWQgPSBTaWduYXR1cmVFcmM2NDkyLnZhbGlkYXRlKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFRoZSB3cmFwcGVkIHNpZ25hdHVyZSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgd3JhcHBlZCBzaWduYXR1cmUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUod3JhcHBlZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydCh3cmFwcGVkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmUgaXMgaW52YWxpZC4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3Iod3JhcHBlZCkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt3cmFwcGVkfVxcYCBpcyBhbiBpbnZhbGlkIEVSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlRXJjNjQ5Mi5JbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaWduYXR1cmVFcmM2NDkyLmpzLm1hcCJdLCJuYW1lcyI6WyJBYmlQYXJhbWV0ZXJzIiwiRXJyb3JzIiwiSGV4IiwibWFnaWNCeXRlcyIsInVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckJ5dGVjb2RlIiwidW5pdmVyc2FsU2lnbmF0dXJlVmFsaWRhdG9yQWJpIiwiaW5wdXRzIiwibmFtZSIsInR5cGUiLCJzdGF0ZU11dGFiaWxpdHkiLCJvdXRwdXRzIiwiYXNzZXJ0Iiwid3JhcHBlZCIsInNsaWNlIiwiSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvciIsImZyb20iLCJ1bndyYXAiLCJ0byIsImRhdGEiLCJzaWduYXR1cmUiLCJkZWNvZGUiLCJ3cmFwIiwidmFsdWUiLCJjb25jYXQiLCJlbmNvZGUiLCJ2YWxpZGF0ZSIsIkJhc2VFcnJvciIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/erc6492/SignatureErc6492.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/erc8010/SignatureErc8010.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/erc8010/SignatureErc8010.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidWrappedSignatureError: () => (/* binding */ InvalidWrappedSignatureError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   magicBytes: () => (/* binding */ magicBytes),\n/* harmony export */   suffixParameters: () => (/* binding */ suffixParameters),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Authorization.js */ \"(ssr)/./node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Secp256k1.js */ \"(ssr)/./node_modules/ox/_esm/core/Secp256k1.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n\n\n/**\n * Magic bytes used to identify ERC-8010 wrapped signatures.\n */ const magicBytes = \"0x8010801080108010801080108010801080108010801080108010801080108010\";\n/** Suffix ABI parameters for the ERC-8010 wrapped signature. */ const suffixParameters = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.from(\"(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data\");\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * SignatureErc8010.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-8010 wrapped signature.\n * ```\n *\n * @param value - The value to assert.\n */ function assert(value) {\n    if (typeof value === \"string\") {\n        if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(value, -32) !== magicBytes) throw new InvalidWrappedSignatureError(value);\n    } else _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__.assert(value.authorization);\n}\n/**\n * Parses an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc8010.from('0x...') // [!code focus]\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc8010.from({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n * })\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } }\n * ```\n *\n * @param value - Value to parse.\n * @returns Parsed value.\n */ function from(value) {\n    if (typeof value === \"string\") return unwrap(value);\n    return value;\n}\n/**\n * Unwraps an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const { authorization, data, signature } = SignatureErc8010.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to unwrap.\n * @returns Unwrapped signature.\n */ function unwrap(wrapped) {\n    assert(wrapped);\n    const suffixLength = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, -64, -32));\n    const suffix = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, -suffixLength - 64, -64);\n    const signature = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, 0, -suffixLength - 64);\n    const [auth, to, data] = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.decode(suffixParameters, suffix);\n    const authorization = _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__.from({\n        address: auth.delegation,\n        chainId: Number(auth.chainId),\n        nonce: auth.nonce,\n        yParity: auth.yParity,\n        r: auth.r,\n        s: auth.s\n    });\n    return {\n        authorization,\n        signature,\n        ...data && data !== \"0x\" ? {\n            data,\n            to\n        } : {}\n    };\n}\n/**\n * Wraps a signature into [ERC-8010 format](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md).\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc8010.wrap({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Values to wrap.\n * @returns Wrapped signature.\n */ function wrap(value) {\n    const { data, signature } = value;\n    assert(value);\n    const self = _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_4__.recoverAddress({\n        payload: _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__.getSignPayload(value.authorization),\n        signature: _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__.from(value.authorization)\n    });\n    const suffix = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.encode(suffixParameters, [\n        {\n            ...value.authorization,\n            delegation: value.authorization.address,\n            chainId: BigInt(value.authorization.chainId)\n        },\n        value.to ?? self,\n        data ?? \"0x\"\n    ]);\n    const suffixLength = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(suffix), {\n        size: 32\n    });\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(signature, suffix, suffixLength, magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const valid = SignatureErc8010.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param value - The value to validate.\n * @returns `true` if the value is valid, `false` otherwise.\n */ function validate(value) {\n    try {\n        assert(value);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/** Thrown when the ERC-8010 wrapped signature is invalid. */ class InvalidWrappedSignatureError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor(wrapped){\n        super(`Value \\`${wrapped}\\` is an invalid ERC-8010 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"SignatureErc8010.InvalidWrappedSignatureError\"\n        });\n    }\n} //# sourceMappingURL=SignatureErc8010.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM4MDEwL1NpZ25hdHVyZUVyYzgwMTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDQTtBQUNkO0FBQ047QUFDWTtBQUNBO0FBQ2xEOztDQUVDLEdBQ00sTUFBTU0sYUFBYSxxRUFBcUU7QUFDL0YsOERBQThELEdBQ3ZELE1BQU1DLG1CQUFtQlAsd0RBQWtCLENBQUMscUhBQXFIO0FBQ3hLOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNTLE9BQU9DLEtBQUs7SUFDeEIsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsSUFBSVAsK0NBQVMsQ0FBQ08sT0FBTyxDQUFDLFFBQVFKLFlBQzFCLE1BQU0sSUFBSU0sNkJBQTZCRjtJQUMvQyxPQUVJTCxzREFBZ0IsQ0FBQ0ssTUFBTUcsYUFBYTtBQUM1QztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZCQyxHQUNNLFNBQVNMLEtBQUtFLEtBQUs7SUFDdEIsSUFBSSxPQUFPQSxVQUFVLFVBQ2pCLE9BQU9JLE9BQU9KO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTSSxPQUFPQyxPQUFPO0lBQzFCTixPQUFPTTtJQUNQLE1BQU1DLGVBQWViLGtEQUFZLENBQUNBLCtDQUFTLENBQUNZLFNBQVMsQ0FBQyxJQUFJLENBQUM7SUFDM0QsTUFBTUcsU0FBU2YsK0NBQVMsQ0FBQ1ksU0FBUyxDQUFDQyxlQUFlLElBQUksQ0FBQztJQUN2RCxNQUFNRyxZQUFZaEIsK0NBQVMsQ0FBQ1ksU0FBUyxHQUFHLENBQUNDLGVBQWU7SUFDeEQsTUFBTSxDQUFDSSxNQUFNQyxJQUFJQyxLQUFLLEdBQUd0QiwwREFBb0IsQ0FBQ08sa0JBQWtCVztJQUNoRSxNQUFNTCxnQkFBZ0JaLHdEQUFrQixDQUFDO1FBQ3JDdUIsU0FBU0osS0FBS0ssVUFBVTtRQUN4QkMsU0FBU0MsT0FBT1AsS0FBS00sT0FBTztRQUM1QkUsT0FBT1IsS0FBS1EsS0FBSztRQUNqQkMsU0FBU1QsS0FBS1MsT0FBTztRQUNyQkMsR0FBR1YsS0FBS1UsQ0FBQztRQUNUQyxHQUFHWCxLQUFLVyxDQUFDO0lBQ2I7SUFDQSxPQUFPO1FBQ0hsQjtRQUNBTTtRQUNBLEdBQUlHLFFBQVFBLFNBQVMsT0FBTztZQUFFQTtZQUFNRDtRQUFHLElBQUksQ0FBQyxDQUFDO0lBQ2pEO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDTSxTQUFTVyxLQUFLdEIsS0FBSztJQUN0QixNQUFNLEVBQUVZLElBQUksRUFBRUgsU0FBUyxFQUFFLEdBQUdUO0lBQzVCRCxPQUFPQztJQUNQLE1BQU11QixPQUFPN0IsOERBQXdCLENBQUM7UUFDbEMrQixTQUFTbEMsa0VBQTRCLENBQUNTLE1BQU1HLGFBQWE7UUFDekRNLFdBQVdkLG9EQUFjLENBQUNLLE1BQU1HLGFBQWE7SUFDakQ7SUFDQSxNQUFNSyxTQUFTbEIsMERBQW9CLENBQUNPLGtCQUFrQjtRQUNsRDtZQUNJLEdBQUdHLE1BQU1HLGFBQWE7WUFDdEJZLFlBQVlmLE1BQU1HLGFBQWEsQ0FBQ1csT0FBTztZQUN2Q0UsU0FBU1ksT0FBTzVCLE1BQU1HLGFBQWEsQ0FBQ2EsT0FBTztRQUMvQztRQUNBaEIsTUFBTVcsRUFBRSxJQUFJWTtRQUNaWCxRQUFRO0tBQ1g7SUFDRCxNQUFNTixlQUFlYixvREFBYyxDQUFDQSw4Q0FBUSxDQUFDZSxTQUFTO1FBQUVzQixNQUFNO0lBQUc7SUFDakUsT0FBT3JDLGdEQUFVLENBQUNnQixXQUFXRCxRQUFRRixjQUFjVjtBQUN2RDtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTb0MsU0FBU2hDLEtBQUs7SUFDMUIsSUFBSTtRQUNBRCxPQUFPQztRQUNQLE9BQU87SUFDWCxFQUNBLE9BQU07UUFDRixPQUFPO0lBQ1g7QUFDSjtBQUNBLDJEQUEyRCxHQUNwRCxNQUFNRSxxQ0FBcUNWLHNEQUFnQjtJQUM5RDBDLFlBQVk3QixPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDLENBQUMsUUFBUSxFQUFFQSxRQUFRLDRDQUE0QyxDQUFDO1FBQ3RFOEIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWdkMsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYzQzMzctZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM4MDEwL1NpZ25hdHVyZUVyYzgwMTAuanM/MDg5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4uL2NvcmUvQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBBdXRob3JpemF0aW9uIGZyb20gJy4uL2NvcmUvQXV0aG9yaXphdGlvbi5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vY29yZS9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL2NvcmUvSGV4LmpzJztcbmltcG9ydCAqIGFzIFNlY3AyNTZrMSBmcm9tICcuLi9jb3JlL1NlY3AyNTZrMS5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi4vY29yZS9TaWduYXR1cmUuanMnO1xuLyoqXG4gKiBNYWdpYyBieXRlcyB1c2VkIHRvIGlkZW50aWZ5IEVSQy04MDEwIHdyYXBwZWQgc2lnbmF0dXJlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hZ2ljQnl0ZXMgPSAnMHg4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwJztcbi8qKiBTdWZmaXggQUJJIHBhcmFtZXRlcnMgZm9yIHRoZSBFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZS4gKi9cbmV4cG9ydCBjb25zdCBzdWZmaXhQYXJhbWV0ZXJzID0gQWJpUGFyYW1ldGVycy5mcm9tKCcodWludDI1NiBjaGFpbklkLCBhZGRyZXNzIGRlbGVnYXRpb24sIHVpbnQyNTYgbm9uY2UsIHVpbnQ4IHlQYXJpdHksIHVpbnQyNTYgciwgdWludDI1NiBzKSwgYWRkcmVzcyB0bywgYnl0ZXMgZGF0YScpO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIHdyYXBwZWQgc2lnbmF0dXJlIGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjODAxMCB9IGZyb20gJ294L2VyYzgwMTAnXG4gKlxuICogU2lnbmF0dXJlRXJjODAxMC5hc3NlcnQoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yOiBWYWx1ZSBgMHhkZWFkYmVlZmAgaXMgYW4gaW52YWxpZCBFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZS5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoSGV4LnNsaWNlKHZhbHVlLCAtMzIpICE9PSBtYWdpY0J5dGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3IodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIFNpZ25hdHVyZS5hc3NlcnQodmFsdWUuYXV0aG9yaXphdGlvbik7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBbRVJDLTgwMTAgd3JhcHBlZCBzaWduYXR1cmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9qeG9tL0VSQ3MvYmxvYi8xNmY3ZTM4OTFmZmYyZTFlOWMyNWRlYTA0ODU0OTc3MzlkYjhhODE2L0VSQ1MvZXJjLTgwMTAubWQpIGludG8gaXRzIGNvbnN0aXR1ZW50IHBhcnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzgwMTAgfSBmcm9tICdveC9lcmM4MDEwJyAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiAnMHguLi4nLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiAvLyBJbnN0YW50aWF0ZSBmcm9tIHNlcmlhbGl6ZWQgZm9ybWF0LiAvLyBbIWNvZGUgZm9jdXNdXG4gKiBjb25zdCB3cmFwcGVkID0gU2lnbmF0dXJlRXJjODAxMC5mcm9tKCcweC4uLicpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHsgYXV0aG9yaXphdGlvbjogeyAuLi4gfSwgZGF0YTogJzB4Li4uJywgc2lnbmF0dXJlOiB7IC4uLiB9IH0gLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIEluc3RhbnRpYXRlIGZyb20gY29uc3RpdHVlbnQgcGFydHMuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IHdyYXBwZWQgPSBTaWduYXR1cmVFcmM4MDEwLmZyb20oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGF1dGhvcml6YXRpb246IHsgLi4uIH0sIC8vIFshY29kZSBmb2N1c11cbiAqICAgZGF0YTogJzB4Li4uJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pXG4gKiAvLyBAbG9nOiB7IGF1dGhvcml6YXRpb246IHsgLi4uIH0sIGRhdGE6ICcweC4uLicsIHNpZ25hdHVyZTogeyAuLi4gfSB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFBhcnNlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHVud3JhcCh2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBVbndyYXBzIGFuIFtFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZV0oaHR0cHM6Ly9naXRodWIuY29tL2p4b20vRVJDcy9ibG9iLzE2ZjdlMzg5MWZmZjJlMWU5YzI1ZGVhMDQ4NTQ5NzczOWRiOGE4MTYvRVJDUy9lcmMtODAxMC5tZCkgaW50byBpdHMgY29uc3RpdHVlbnQgcGFydHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM4MDEwIH0gZnJvbSAnb3gvZXJjODAxMCdcbiAqXG4gKiBjb25zdCB7IGF1dGhvcml6YXRpb24sIGRhdGEsIHNpZ25hdHVyZSB9ID0gU2lnbmF0dXJlRXJjODAxMC51bndyYXAoJzB4Li4uJylcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3cmFwcGVkIC0gV3JhcHBlZCBzaWduYXR1cmUgdG8gdW53cmFwLlxuICogQHJldHVybnMgVW53cmFwcGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcCh3cmFwcGVkKSB7XG4gICAgYXNzZXJ0KHdyYXBwZWQpO1xuICAgIGNvbnN0IHN1ZmZpeExlbmd0aCA9IEhleC50b051bWJlcihIZXguc2xpY2Uod3JhcHBlZCwgLTY0LCAtMzIpKTtcbiAgICBjb25zdCBzdWZmaXggPSBIZXguc2xpY2Uod3JhcHBlZCwgLXN1ZmZpeExlbmd0aCAtIDY0LCAtNjQpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IEhleC5zbGljZSh3cmFwcGVkLCAwLCAtc3VmZml4TGVuZ3RoIC0gNjQpO1xuICAgIGNvbnN0IFthdXRoLCB0bywgZGF0YV0gPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShzdWZmaXhQYXJhbWV0ZXJzLCBzdWZmaXgpO1xuICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICAgICAgICBhZGRyZXNzOiBhdXRoLmRlbGVnYXRpb24sXG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihhdXRoLmNoYWluSWQpLFxuICAgICAgICBub25jZTogYXV0aC5ub25jZSxcbiAgICAgICAgeVBhcml0eTogYXV0aC55UGFyaXR5LFxuICAgICAgICByOiBhdXRoLnIsXG4gICAgICAgIHM6IGF1dGgucyxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3JpemF0aW9uLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIC4uLihkYXRhICYmIGRhdGEgIT09ICcweCcgPyB7IGRhdGEsIHRvIH0gOiB7fSksXG4gICAgfTtcbn1cbi8qKlxuICogV3JhcHMgYSBzaWduYXR1cmUgaW50byBbRVJDLTgwMTAgZm9ybWF0XShodHRwczovL2dpdGh1Yi5jb20vanhvbS9FUkNzL2Jsb2IvMTZmN2UzODkxZmZmMmUxZTljMjVkZWEwNDg1NDk3NzM5ZGI4YTgxNi9FUkNTL2VyYy04MDEwLm1kKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzgwMTAgfSBmcm9tICdveC9lcmM4MDEwJyAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiAnMHguLi4nLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCB3cmFwcGVkID0gU2lnbmF0dXJlRXJjODAxMC53cmFwKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBhdXRob3JpemF0aW9uOiB7IC4uLiB9LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmU6IFNpZ25hdHVyZS50b0hleChzaWduYXR1cmUpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZXMgdG8gd3JhcC5cbiAqIEByZXR1cm5zIFdyYXBwZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcCh2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2lnbmF0dXJlIH0gPSB2YWx1ZTtcbiAgICBhc3NlcnQodmFsdWUpO1xuICAgIGNvbnN0IHNlbGYgPSBTZWNwMjU2azEucmVjb3ZlckFkZHJlc3Moe1xuICAgICAgICBwYXlsb2FkOiBBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKHZhbHVlLmF1dGhvcml6YXRpb24pLFxuICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tKHZhbHVlLmF1dGhvcml6YXRpb24pLFxuICAgIH0pO1xuICAgIGNvbnN0IHN1ZmZpeCA9IEFiaVBhcmFtZXRlcnMuZW5jb2RlKHN1ZmZpeFBhcmFtZXRlcnMsIFtcbiAgICAgICAge1xuICAgICAgICAgICAgLi4udmFsdWUuYXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgIGRlbGVnYXRpb246IHZhbHVlLmF1dGhvcml6YXRpb24uYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IEJpZ0ludCh2YWx1ZS5hdXRob3JpemF0aW9uLmNoYWluSWQpLFxuICAgICAgICB9LFxuICAgICAgICB2YWx1ZS50byA/PyBzZWxmLFxuICAgICAgICBkYXRhID8/ICcweCcsXG4gICAgXSk7XG4gICAgY29uc3Qgc3VmZml4TGVuZ3RoID0gSGV4LmZyb21OdW1iZXIoSGV4LnNpemUoc3VmZml4KSwgeyBzaXplOiAzMiB9KTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChzaWduYXR1cmUsIHN1ZmZpeCwgc3VmZml4TGVuZ3RoLCBtYWdpY0J5dGVzKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgd3JhcHBlZCBzaWduYXR1cmUuIFJldHVybnMgYHRydWVgIGlmIHRoZSB3cmFwcGVkIHNpZ25hdHVyZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM4MDEwIH0gZnJvbSAnb3gvZXJjODAxMCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFNpZ25hdHVyZUVyYzgwMTAudmFsaWRhdGUoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZSBpcyBpbnZhbGlkLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih3cmFwcGVkKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3dyYXBwZWR9XFxgIGlzIGFuIGludmFsaWQgRVJDLTgwMTAgd3JhcHBlZCBzaWduYXR1cmUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmVFcmM4MDEwLkludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpZ25hdHVyZUVyYzgwMTAuanMubWFwIl0sIm5hbWVzIjpbIkFiaVBhcmFtZXRlcnMiLCJBdXRob3JpemF0aW9uIiwiRXJyb3JzIiwiSGV4IiwiU2VjcDI1NmsxIiwiU2lnbmF0dXJlIiwibWFnaWNCeXRlcyIsInN1ZmZpeFBhcmFtZXRlcnMiLCJmcm9tIiwiYXNzZXJ0IiwidmFsdWUiLCJzbGljZSIsIkludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3IiLCJhdXRob3JpemF0aW9uIiwidW53cmFwIiwid3JhcHBlZCIsInN1ZmZpeExlbmd0aCIsInRvTnVtYmVyIiwic3VmZml4Iiwic2lnbmF0dXJlIiwiYXV0aCIsInRvIiwiZGF0YSIsImRlY29kZSIsImFkZHJlc3MiLCJkZWxlZ2F0aW9uIiwiY2hhaW5JZCIsIk51bWJlciIsIm5vbmNlIiwieVBhcml0eSIsInIiLCJzIiwid3JhcCIsInNlbGYiLCJyZWNvdmVyQWRkcmVzcyIsInBheWxvYWQiLCJnZXRTaWduUGF5bG9hZCIsImVuY29kZSIsIkJpZ0ludCIsImZyb21OdW1iZXIiLCJzaXplIiwiY29uY2F0IiwidmFsaWRhdGUiLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/erc8010/SignatureErc8010.js\n");

/***/ })

};
;